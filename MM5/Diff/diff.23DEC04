===================================================================
CHANGES
diff -r3.38 -r3.47
11c11,428
< The current release is 3.6 (release-3-6, December 27, 2002).
---
> The current release is 3.7 (release-3-7, December 23, 2004).
> ============================================================
> 
> Bug fixes and changes in V3.7:
> 
> 1. Bug fixes:
> 
> - When IMOIAV is not zero and snow melts (IFSNOW=2), do not reset soil moisture 
>   to table value. Thanks to David Ovens from UW.
> 
>   Affected files:
>   Run/mm5.F
>   domain/boundary/lbdyin.F
>   domain/initial/init.F
>   domain/nest/initnest.F
>   dynamics/nonhydro/solve.F
> 
> - Change default soil input layers from 10,200, to the more commonly 
>   available layers of 10,40,100,200, and add ISTLYR and ISMLYR to lparam
>   in the deck, which makes it easier for users to change the soil layers 
>   that are used as input to the model.
> 
>   Affected file:
>   Templates/lparam
>   domain/initial/param.F
> 
> - Avoid negative PBL height in diagnostic when Eta PBL is used.
> 
>   Affected file:
>   physics/pbl_sfc/myepbl/myepbl.F
> 
> - Correction to Noah LSM for seaice initialization.
>   (in the code since version 3.6.1)
> 
>   physics/pbl_sfc/noahlsm/surfce.F
> 
> - Fix for allowing 2 nests on the same level when using 
>   the Noah LSM model.
> 
>   Affected files:
>   domain/nest/initnest.F
> 
> - Define Z0 when there is no snow in Noah LSM.
>   (in the code since version 3.6.1)
> 
>   Affected file:
>   physics/pbl_sfc/noahlsm/sflx.F
> 
> - Initialize variables to that FNDSOILW is now used correctly. 
>   Thanks to Barry Lynn from HUJ, Israel.
> 
>   Affected files:
>   domain/initial/init.F 
>   domain/io/rdinit.F
>   domain/nest/initnest.F
> 
> - Correct MPI feedback of XLAND. Only effect if running with IEXSI=2
>   (in the code since version 3.6.2)
> 
>   Affected file:
>   MPP/RSL/parallel_src/mp_feedbk.F
> 
> - Correct a dimension error for XLAND
>   (in the code since version 3.6.2).
> 
>   Affected file:
>   physics/cumulus/bm/cupara7.F
> 
> - Initialize seaice on nest from LOWBDY_DOMAIN1 if no LOWBDY_DOMAIN2 exist, 
>   for iexsi >= 1 (in the code since version 3.6.2).
> 
>   Affected files:
>   domain/nest/initnest.F
>   MPP/RSL/mpp_initnest_30.incl
> 
> - Add feedback of SEAICE and TGSI            
>   (in the code since version 3.6.2).
> 
>   Affected files:
>   domain/boundary/lbdyin.F
>   domain/initial/init.F
>   domain/nest/feedbk.F
>   MPP/RSL/parallel_src/mp_feedbk.F, define_comms.F
>   MPP/RSL/parallel_src/bcast_size.F, merge_size.F
> 
> - Fix for running with multiple input files, with FDDA on
>   and doing a restart. A new namelist variable IFRSFA is added
>   for this purpose, and it is used together with CDATEST. 
> 
>   Affected files:
>   Templates/oparam
>   domain/initial/param.F
>   include/param2.incl
>   MPP/namelist.data
> 
> - Syntax correction to lookup table version of Reisner 1 scheme
>   - to prevent compilation error. Also update two constants used
>   in the routine so that it is consistent to the non-lookup table
>   version of the code (in the code since version 3.6.1).
> 
>   Affected file:
>   domain/initial/param.F
>   physics/explicit/reisner1/lexmoisr.F
>   physics/explicit/simple/lexmoiss.F
> 
> - Add check to prevent IFSNOW=2 and ISOIL=3 to be used together.
>   Thanks to Tanya Otte of EPA.
> 
>   Affected files:
>   domain/initial/param.F
> 
> - Correct an error for filling outer row and column for GS TKE
>   (in the code since version 3.6.2).
> 
>   Affected file:
>   domain/io/outtap.F
> 
> - Fix an "out of bound" problem for TKEA in MPI code
>   (in the code since version 3.6.2).
> 
>   Affected file:
>   MPP/RSL/parallel_src/mp_stotndt.F
> 
> - Fix to allow the output of TKE when IADVTKE is set to 0.
> 
>   Affected file:
>   dynamics/nonhydro/solve.F
> 
> - Improvement in seasonal vegetation adjustment for ISOIL=3 option
>   (in the code since version 3.6.2).
> 
>   Affected file:
>   physics/pbl_sfc/pxpbl/vegeland.F
> 
> - Ensure that VEGFRAC is not updated every 24 hours for ISOIL=3 option
>   (in the code since version 3.6.2).
> 
>   Affected file:
>   dynamics/nonhydro/solve.F
> 
> - Correct the initialization of the SWDOWN field when 
>   the CCM2 radiation is used. This only affected the 
>   MPP version of the code.
>   (in the code since version 3.6.1)
> 
>   Affected file:
>   MPP/RSL/Makefile.RSL
> 
> - Prevent possible divide by zero in GS scheme.
> 
>   Affected file:
>   physics/pbl_sfc/gspbl/gspbl.F
> 
> - Correct print statements so that each TBL file has separate error 
>   information prints (in the code since version 3.6.2).
> 
>   Affected file:
>   domain/initial/param.F
> 
> - Soil temp adjustment changed from 6k/km to 6.5k/km, to be consistent 
>   with rest of programs, affect only if running with old REGRID input
>   (in the code since version 3.6.2).
> 
>   Affected files:
>   domain/io/rdinit.F
> 
> - Make the constant CP consistent throughout the code.
> 
>   Affected file:
>   physics/cumulus/kf2/dtfrz2.F, tpmix2.F
> 
> - Fix for OpenMP 
>   Thanks to Carlie Coats of BaronAMS.
> 
>   Affected files:
>   dynamics/nonhydro/solve.F
>   domain/nest/initnest.F
> 
> - Fix long line that creates compiler problems on Sun.
> 
>   Affected file:
>   physics/explicit/reisner1/exmoisr.F
> 
> - Prevent compilation error on some machines.
>   (in the code since version 3.6.1)
> 
>   Affected files:
>   domain/initial/init.F
>   domain/nest/initnest.F
> 
> 
> 2. Changes:
> 
> - Move the calls to cumulus schemes to below the calls to PBL schemes 
>   so the Grell scheme can make use of the updated PBL tendency.
>   Hence this change mainly has an effect on the Grell scheme.
>   Other cumulus schemes are only slightly affected (roundoff differences).
> 
>   Affected file:
>   dynamics/nonhydro/solve.F
> 
> - Update the Reisner2 scheme
>   (See comments at top of affected files for more details).
>   Thanks to Greg Thompson of NCAR/RAP.
> 
>   Affected files:
>   physics/explicit/reisner2/exmoisg.F
>   domain/initial/paramr.F
> 
> - Update of the Schultz scheme. The amount of cloud liquid at any given 
>   time is diagnosed as some fraction of (qv+qc)/qvsat. Change the method 
>   for computing saturation adjustment to MM5 one, replacing the iterative 
>   method. Thanks to Paul Schultz of FSL.
> 
>   Affected files:
>   physics/explicit/schultz/schultz.F, schultz_mic.F
> 
> - Change to convective velocity, PBL height and surface stress calculations
>   in MRF PBL. The net effects are reduced convective velocity, reduced PBL
>   height, and removed momentum dependency on convective velocity. 
>   Thanks to Yubao Liu of NCAR/RAP.
> 
>   Affected file:
>   physics/pbl_sfc/mrfpbl/mrfpbl.F
> 
> - Improve 2m temperature calculations for the Noah LSM scheme.
> 
>   Affected files:
>   physics/pbl_sfc/mrfpbl/mrfpbl.F
>   physics/pbl_sfc/myepbl/myepbl.F
>   physics/pbl_sfc/noahlsm/surfce.F
> 
> - Improve the CCM2 shortwave radiation result by modifying cloud ice radius.
>   The change reduces the effect of cloud on shortwave radiation.
>   Thanks to Cliff Mass of UW.
> 
>   Affected file:
>   physics/radiation/ccm2/radcsw.F
> 
> - Change the default maximum nest level from 3 to 5.
> 
>   Affected files:
>   domain/drivers/Makefile, nstlev3.F
>   domain/drivers/nstlev4.F, nstlev5.F (new)
>   MPP/mpp_objects_all
> 
> - Add a new switch, ISFMTHD, in LPARAM to allow for a different way 
>   to diagnose 2 m temperature/moisture and 10 m winds in stable regime. 
>   The general impact in a stable regime would be cooler temperature
>   and weaker winds. (Thanks to John Nielsen-Gammon of Texas A&M.)
>   (in the code since version 3.6.1)
> 
>   Affected files:
>   Templates/lparam
>   domain/initial/param.F
>   physics/pbl_sfc/hirpbl/hirpbl.F
>   physics/pbl_sfc/mrfpbl/mrfpbl.F
>   include/param2.incl
>   MPP/namelist.data
> 
> - KF2 code is cleaned up to avoid potential computational problems 
>   on Linux machines. Thanks to Jack Kain of NSSL.
> 
>   Affected file:
>   physics/cumulus/kf2/kfpara2.F, lutab.F, tpmix2.F
> 
> - Add TGSI to MMOUT_DOMAINx
>   (in the code since version 3.6.2)
> 
>   Affected file:
>   domain/io/outtap.F
> 
> - Change message written out when nest do not have a LOWBDY
>   file as input from "ERROR" to "ADVISORY"
> 
>   Affected file:
>   domain/boundary/lbdyin.F
> 
> 3. New in 3.7:
> 
> - Add Polar option (IPOLAR=1) to the MRF PBL scheme.
> 
>   Affected files:
>   domain/initial/param.F
>   dynamics/nonhydro/solve.F
>   physics/pbl_sfc/mrfpbl/mrfpbl.F
> 
> - Add horizontal diffusion modifications to the code. This allows for diffusion to be 
>   calculated truly horizontal. This option is turned on by setting ITPDIFF to 2.
>   Thanks to Guenther Zaengl from the University of Muenchen.
> 
>   Affected files:
>   Templates/lparam
>   domain/initial/Makefile, init.F, param.F
>   domain/nest/Makefile, feedbk.F
>   dynamics/nonhydro/Makefile, solve.F
>   include/param2.incl
>   include/zdiffu.incl, zdiffu2.incl (new)
>   physics/hzdiffu/simple/Makefile, coef_diffu.F
>   physics/hzdiffu/simple/diffintp.F, diffmoi.F (new)
>   physics/hzdiffu/simple/diffth.F, diffthd.F (new)
>   MPP/mpp_objects_all, namelist.data
>   MPP/RSL/parallel_src/mp_feedbk.F
> 
> - Add advection modifications to the code. This new code allow for the use
>   of an instability limiter when calculating advection.
>   Two new parameters are included for this option, ITADVM, which switches the
>   new temperature advection code on, and IQADVM which is used for the new
>   moisture advection code. This may have a benefit when using the new diffusion
>   scheme described above and in high-resolution, complex terrain domain.
>   Thanks to Guenther Zaengl from the University of Muenchen.
> 
>   Affected files:
>   Templates/lparam
>   domain/initial/param.F
>   dynamics/nonhydro/Makefile, solve.F
>   include/param2.incl
>   physics/advection/simple/Makefile, hadv.F
>   physics/advection/simple/vadv2.F (new)
>   MPP/namelist.data
> 
> - Solar slope and topography shadowing effects are included with 
>   two new switches, LEVSLP and OROSHAW. 
>   LEVSLP indicates the nest level at which solar radiation start
>   accounting for orography. (This will correspond to LEVIDN).
>   This is only recommended for very high resolution model runs.
>   To switch this off, set LEVSLP equals to a large number like 9.
>   OROSHAW include the effect of orography shadowing. This only has
>   an effect if LEVSLP is also set. OROSHAW is NOT included in 
>   the MPP version of the code.
>   Thanks to Guenther Zaengl from the University of Muenchen.
> 
>   Affected files:
>   Templates/lparam
>   domain/initial/param.F
>   dynamics/nonhydro/Makefile, solve.F
>   include/param2.incl, param3.incl
>   physics/radiation/cloud/swrad.F
>   MPP/namelist.data
> 
> - The Noah LSM now has urban effect, and considers emissivity in 
>   computing surface temperature. The second change generally 
>   increases the amplitude of the diurnal cycle. Note, one must
>   use the modified LANDUSE.TBL as well.
>   Thanks to Fei Chen and Mukul Tewari of NCAR/RAP.
> 
>   Affected files:
>   Run/LANDUSE.TBL
>   physics/pbl_sfc/mrfpbl/mrfpbl.F
>   physics/pbl_sfc/myepbl/myepbl.F
>   physics/pbl_sfc/noahlsm/sflx.F, surfce.F
> 
> - Optimized routines to ensure faster run times. The new routines 
>   especially improve run times on IBM computers. In order to give
>   users a choice, both the optimized and original code are available.
>   To switch to the optimized code, "-DIBMopt" needs to be added to
>   the compiler flags in configure.user. 
>   Users must also use the "massv" library to compile. If this 
>   library is not available, a second compiler flag "-DvsLIB"
>   needs to be added to the compiler flags.
>   During tests runs on the IBM, most of these changes reduced 
>   run times by approximately 2%. 
>   The optimization to the exmoisr routine reduced run times by 
>   up to 20%. This routine can be switched on separately from 
>   the other optimization routines, by setting MPHYSTBL=2 in 
>   the configure.user file. If this option is used, users must either
>   include the "massv" library or add the compiler flag "-DvsLIB".
>   These routines were kindly supply by Zaphiris Christidis of
>   IBM and Carlie Coats of BaronAMS.
> 
>   Affected files:
>   configure.user
>   Util/parseconfig.c
>   domain/initial/param.F
>   domain/util/dcpl3dwnd.F
>   dynamics/nonhydro/solve.F, sound.F
>   fdda/grid/blnudgd.F, bufslgd.F, nudgd.F, qsatgd.F
>   physics/advection/simple/hadv.F, vadv.F
>   physics/cumulus/grell/cup.F, cupara3.F
>   physics/explicit/Makefile
>   physics/explicit/reisner1/Makefile, zexmoisr.F
>   physics/pbl_sfc/mrfpbl/tridi2.F
>   physics/pbl_sfc/util/slab.F
>   physics/radiation/cloud/lwrad.F
>   MPP/FLICFILE, mpp_objects_all
>   MPP/FLIC/FLIC/FLICFILE
> 
> - New Cray X1 compiler options. Thanks to Peter Johnsen from
>   Cray.
> 
>   Affected files:
>   Makefile
>   configure.user
>   Run/mm5.F
>   dynamics/nonhydro/solve.F, sound.F
>   fdda/grid/in4dgd.F
>   include/addr0.incl
>   memory/address/addall.F, addrx1c.F, addrx1n.F
>   MPP/mhz.c, mpp_objects_all
>   MPP/FLIC/FLIC/Makefile
>   MPP/FLIC/Parser/Makefile
>   MPP/FLIC/Scanner/Makefile
>   MPP/RSL/Makefile.RSL
>   MPP/RSL/RSL/compat.h, debug.c, domain_def.c
>   MPP/RSL/RSL/exch_sten.c, makefile, makefile.x1
>   MPP/RSL/RSL/rsl.h, /rsl_io.h, rsl_ioserve.c
>   MPP/RSL/RSL/rsl_merge.c, rsl_remap_state.c
>   MPP/RSL/parallel_src/x1_feedbk.F
> 
> - Add INTEL compiler flags.
>   To accommodate the INTEL compiler, we also now close
>   SAVE files and change ABORT to STOP statements.
> 
>   Affected file:
>   configure.user
>   domain/io/initsav.F
>   domain/io/ouput.F
>   domain/io/rdter.F
13a431
> Bug fixes and changes in V3.6:
158c576
< - Winds in time series output are now rotated to earch winds.
---
> - Winds in time series output are now rotated to earth winds.
===================================================================
Makefile
diff -r3.9 -r3.11
7c7,8
< 	(cd Util; $(MAKE)); \
---
> # pjj/cray - X1 cross compiler
> 	(cd Util; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) ; else $(MAKE) ; fi )
18c19,20
< 	(cd Util; $(MAKE)); \
---
> # pjj/cray - X1 cross compiler
> 	(cd Util; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) ; else $(MAKE) ; fi )
83c85,86
< 	(cd Util; $(MAKE))
---
> # pjj/cray - X1 cross compiler
> 	(cd Util; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) ; else $(MAKE) ; fi )
89c92
< 	(cd MPP; $(MAKE) col_cutter)
---
> 	(cd MPP; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) col_cutter ; else $(MAKE) col_cutter ; fi)
93c96,99
<                 $(MAKE) -f Makefile.$(MPP_LAYER) )
---
>                 $(MAKE) -f Makefile.$(MPP_LAYER) parame ; )
> 	(cd MPP/build;                \
> 		$(MAKE) -f Makefile.$(MPP_LAYER) all)
> #                $(MAKE) -P -f Makefile.$(MPP_LAYER) all)
98,99c104,105
< 	(cd MPP/FLIC ; $(MAKE) ; $(MAKE) clean )
< 	(cd MPP/FLIC/FLIC ; $(MAKE) ; \
---
> 	(cd MPP/FLIC ; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) ; else $(MAKE) CC=cc ; $(MAKE) clean ; fi )
> 	(cd MPP/FLIC/FLIC ; if [ "$(X1_CROSS_COMP)" != "" ] ; then $(MAKE) CC="$(X1_CROSS_COMP)" CFLAGS=$(X1_CROSS_CFLG) ; else $(MAKE) CC=cc ; fi ; \
118c124
< 	(cd MPP/RSL/RSL; $(MAKE) super )
---
> 	(cd MPP/RSL/RSL; $(MAKE) superclean )
===================================================================
README
diff -r3.8 -r3.9
2c2
< VERSION 3 MM5 PROGRAM (release 3-6)
---
> VERSION 3 MM5 PROGRAM (release 3-7)
===================================================================
README.MPP
diff -r3.7 -r3.8
21a22,41
> Notes on Version 3-7 release of MPP-MM5
> ---------------------------------------
> 
> I.  Fixes, enhancements for 3-7:
> 
>   A. New physical options included in MPP version:
>      ITPDIF = 2 : z-diffusion
>      LEVSLP : level at which solar radiation starts to account
>               for the effect of orography
>      ITADVM & IQADVM = 1 : using an instability limiter for
>                            advection
> 
>   B. New physical options NOT included in MPP version:
>      OROSHAW = 1 : this option takes orography shadowing
>                    into account IF solar radiation is 
>                    accounted for. 
>                    If set to 1 during an MPP run, it will be
>                    reset to 0.
> 
> ---------------------------------------
===================================================================
configure.user
diff -r3.50 -r3.56
5a6
> #   3a2. Cray X1 Single Node OpenMP version
16a18,19
> #   3i1. PC_PGF (LINUX/Portland Group Inc.)
> #   3i2. PC_INTEL (LINUX/INTEL)
29c32,33
< #    7g.  Network of Linux PCs with MPI
---
> #   7g1.  Network of Linux PCs with MPI (PGI)
> #   7g2.  Network of Linux PCs with MPI (INTEL)
31a36,37
> #    7j.  Cray X1
> #    7k.  Cray XD1, PGI Fortran
63a70,91
> #   3a2. Cray X1 Single Node OpenMP version
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "crayx1"
> ## Use these for X1 cross compiler
> #X1_CROSS_COMP = "gcc"
> #X1_CROSS_CFLG = ""
> ## Use these for X1 native (trigger) compiler
> ##X1_CROSS_COMP = "cc"
> ##X1_CROSS_CFLG = "-hcommand"
> #FC = ftn
> ### OpenMP in SSP mode
> #FCFLAGS = -Ossp,task1,inline0 -xcsd,mic -sword_pointer -I$(LIBINCLUDE) -D$(RUNTIME_SYSTEM)
> #LDOPTIONS = -Ossp,task1
> ### Multi-streaming single MSP mode
> ###FCFLAGS = -O3 -Ogen_private_callee -xomp,mic -sword_pointer -I$(LIBINCLUDE) -D$(RUNTIME_SYSTEM)
> ### LDOPTIONS =
> #CFLAGS =
> #CPP = cpp
> #CPPFLAGS = -I$(LIBINCLUDE) -C -P
> #LOCAL_LIBRARIES =
> #MAKE = make -i -r
> #-----------------------------------------------------------------------------
153c181
< #FC = f77
---
> #FC = f90
167a196,197
> ###FCFLAGS = -cpp -D$(RUNTIME_SYSTEM) -DIBMopt -DvsLIB -I$(LIBINCLUDE) -c -O4 -Olimit 2000 -automatic \
> ###     -fpe0 -align dcommons -align records -convert big_endian
210c240
< #FCFLAGS = -I$(LIBINCLUDE) -O2 -qarch=auto -qmaxmem=-1 -qsmp=noauto -qnosave -qstrict
---
> #FCFLAGS = -I$(LIBINCLUDE) -O2 -qarch=auto -qmaxmem=-1 -qsmp=omp:noauto -qnosave -qstrict -qnocclines
255a286,314
> #    3i1. PC_PGF77 (LINUX/Portland Group Inc.)
> #         pgf77 version 1.6 and above
> #         May use pgf90 if the version is 3.1-4
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "linux"
> #FC = pgf90
> #FCFLAGS = -I$(LIBINCLUDE) -O2 -Mcray=pointer -tp p6 -pc 32 -Mnoframe -byteswapio
> ##FCFLAGS = -I$(LIBINCLUDE) -O2 -Mcray=pointer -tp p6 -pc 32 -Mnoframe -byteswapio -mp \
> ##-Mnosgimp
> #CPP = /lib/cpp
> #CFLAGS = -O
> #CPPFLAGS = -I$(LIBINCLUDE)
> #LDOPTIONS = -O2 -Mcray=pointer -tp p6 -pc 32 -Mnoframe -byteswapio
> ##LDOPTIONS = -O2 -Mcray=pointer -tp p6 -pc 32 -Mnoframe -byteswapio -mp
> #LOCAL_LIBRARIES =
> #MAKE = make -i -r
> #-----------------------------------------------------------------------------
> #    3i2. PC_INTEL (LINUX/INTEL)
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "linux"
> #FC = ifort
> #FCFLAGS = -I$(LIBINCLUDE) -O2 -tp p6 -pc 32 -convert big_endian
> #CPP = /lib/cpp
> #CFLAGS = -O
> #CPPFLAGS = -I$(LIBINCLUDE)
> #LDOPTIONS = -O2 -tp p6 -pc 32 -convert big_endian
> #LOCAL_LIBRARIES =
> #MAKE = make -i -r
> #-----------------------------------------------------------------------------
302a362,363
> #                                   - 2=optimized exmoisr routine (need vslib, if not
> #                                       available set -DvsLIB in compile flags)
315a377
> #                                     0=none,1=simple,2=cloud,3=ccm2,rrtm=4
322c384
< #                                     0=none,1=simple,2=cloud,3=ccm2,4=rrtm
---
> # 
374c436
< #MFC = xlf_r
---
> #MFC = mpxlf_r
379,380c441,443
< #LOCAL_LIBRARIES = -lmass
< ##LOCAL_LIBRARIES = -lessl
---
> #LOCAL_LIBRARIES = -lmassv
> ##LOCAL_LIBRARIES = -lmass
> ###LOCAL_LIBRARIES = -lessl
389c452,453
< #CPPFLAGS = -DMPI -Drs6000 -DSYSTEM_CALL_OK
---
> #CPPFLAGS = -DMPI -Drs6000 -DSYSTEM_CALL_OK -DIBMopt
> ##CPPFLAGS = -DMPI -Drs6000 -DSYSTEM_CALL_OK -DIBMopt -DvsLIB
669c733
< #    7g. Linux PCs.  Need Portland Group pgf77 and MPICH.
---
> #   7g1. Linux PCs.  Need Portland Group pgf77 and MPICH.
722a787,813
> #   7g2. Linux PCs.  Need INTEL and MPICH.
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "linux"
> #MPP_TARGET=$(RUNTIME_SYSTEM)
> ### edit the following definition for your system
> #LINUX_MPIHOME = /usr/local/mpich-intel
> #MFC = $(LINUX_MPIHOME)/bin/mpif77
> #MCC = $(LINUX_MPIHOME)/bin/mpicc
> #MLD = $(LINUX_MPIHOME)/bin/mpif77
> #FCFLAGS = -O2 -convert big_endian -pc32
> #LDOPTIONS = -O2 -convert big_endian -pc32
> #LOCAL_LIBRARIES = -L$(LINUX_MPIHOME)/build/LINUX/ch_p4/lib -lfmpich -lmpich
> #MAKE = make -i -r
> #AWK = awk
> #SED = sed
> #CAT = cat
> #CUT = cut
> #EXPAND = /usr/bin/expand
> #M4 = m4
> #CPP = /lib/cpp -C -P
> #CPPFLAGS = -traditional -DMPI -Dlinux
> #CFLAGS = -DMPI -I/usr/local/mpi/include
> #ARCH_OBJS =  milliclock.o
> #IWORDSIZE = 4
> #RWORDSIZE = 4
> #LWORDSIZE = 4
> #-----------------------------------------------------------------------------
783a875,965
> #    7j. Cray X1
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "crayx1"
> #MPP_TARGET=$(RUNTIME_SYSTEM)
> #MFC = ftn
> #MCC = cc
> #MLD = $(MFC)
> ## Use these for X1 cross compiler
> #X1_CROSS_COMP = "gcc"
> #X1_CROSS_CFLG = ""
> ## Use these for X1 native (trigger) compiler
> ##X1_CROSS_COMP = "cc"
> ##X1_CROSS_CFLG = "-hcommand"
> #
> #FCFLAGS = -x omp,mic -O3 -Ofp3 -Ogen_private_callee -V -ra -sword_pointer -D$(RUNTIME_SYSTEM)
> ##FCFLAGS = -x omp,mic -Oscalar2,stream3,vector3 -Ofp3 -Ogen_private_callee -V -ra -sword_pointer -D$(RUNTIME_SYSTEM)
> #
> #LDOPTIONS =
> #LOCAL_LIBRARIES = -lmalloc
> #MAKE = make -i -r
> #AWK = awk
> #SED = sed
> #CAT = cat
> #CUT = cut
> #EXPAND = expand
> #M4 = m4
> #CPP = cpp -C -P
> #CPPFLAGS = -DMPI -D$(RUNTIME_SYSTEM) -DKMA
> #CFLAGS = -V -O3 -h display_opt -h report=imsvf -DMPI -D$(RUNTIME_SYSTEM)
> #ARCH_OBJS = error_dupt3d.o set_to_nan.o milliclock.o
> #IWORDSIZE = 4
> #RWORDSIZE = 4
> #LWORDSIZE = 4
> #-----------------------------------------------------------------------------
> #    7k. Cray XD1, Linux Opteron.  Need Portland Group pgf90.
> #
> # The following information has been added to this file with MM5v3.6.3:
> #
> # Information on Portland Group compiler:
> #
> #   http://www.pgroup.com
> #
> # If using a different Fortran compiler, modify FCFLAGS and LDOPTIONS as
> # needed.  The compiler should be capable of doing little- to big-endian
> # conversion and it should understand integer (Cray-style) pointers.  It
> # is recommended that the same fortran compiler be used to compile
> # mpich.  Edit the LINUX_MPIHOME macro, below, to point to the top level mpich
> # directory.  See also:
> #
> #   http://www.mmm.ucar.edu/mm5/mpp/linuxhelp.html (by Steve Webb, NCAR/RAP)
> #
> # Note for pgf77 on RedHat Linux6: patches available from Portland Group at:
> #
> #   http://www.pgroup.com/downloads/rh6patches.html
> #
> #-----------------------------------------------------------------------------
> #RUNTIME_SYSTEM = "linux"
> #MPP_TARGET=$(RUNTIME_SYSTEM)
> # edit the following definition for your system
> #LINUX_MPIHOME = /usr/mpich/mpich-1.2.5
> ### mpif77, mpicc are not yet installed on XD1
> #MFC = $(LINUX_MPIHOME)/bin/mpif77
> #MCC = $(LINUX_MPIHOME)/bin/mpicc
> #MLD = $(LINUX_MPIHOME)/bin/mpif77
> #MFC = pgf90
> #MCC = pgcc
> #MLD = pgf90
> #FCFLAGS = -DDEC_ALPHA -O3 -fastsse -Mnoreentrant -Mcray=pointer -Mnoframe -byteswapio
> #LDOPTIONS = -DDEC_ALPHA -O3 -Mcray=pointer -Mnoframe -byteswapio
> #
> ### need to point to header and libs for mpich explicitly for XD1
> #OBJS_PATH = /opt/benchmark/shome/CONTRIB
> #LOCAL_OBJS = $(OBJS_PATH)/if.o $(OBJS_PATH)/strdup.o $(OBJS_PATH)/farg.o
> #LIB_PATH = -L $(PGI)/linux86-64/5.1/lib -L $(LINUX_MPIHOME)/lib -L /lib64
> #LOCAL_LIBRARIES = $(LIB_PATH) -lgcc -lmpich -lfmpich -lrapl -lmpichfsup -lpthread $(LOCAL_OBJS)
> #
> #MAKE = make -i -r
> #AWK = awk
> #SED = sed
> #CAT = cat
> #CUT = cut
> #EXPAND = expand
> #M4 = m4
> #CPP = /lib/cpp -C -P -traditional
> #CPPFLAGS = -DDEC_ALPHA -DMPI -Dlinux -DSYSTEM_CALL_OK
> #CFLAGS = -O3 -DDEC_ALPHA -DMPI -I$(LINUX_MPIHOME)/include
> #ARCH_OBJS =  milliclock.o
> #IWORDSIZE = 4
> #RWORDSIZE = 4
> #LWORDSIZE = 4
> #-----------------------------------------------------------------------------
===================================================================
configure.user.linux
diff -r3.12 -r3.14
104a105,106
> #                                   - 2=optimized exmoisr routine (need vslib, if not
> #                                       available set -DvsLIB in compile flags)
120a123,127
> # IPOLAR - (integer) for polar model used only if ISOIL=1
> #                                     0=not polar (5-layer soil model)
> #                                     1=polar (7-layer snow/soil model)
> IPOLAR = 0
> #
===================================================================
Run/LANDUSE.TBL
diff -r3.4 -r3.5
13,14c13,14
< 10,     15.,   .50,   .92,   10.,    5.,   .60, 9.0e25,'Tundra'
< 11,     80.,   .95,   .95,  0.01,    5.,    0., 9.0e25,'Permanent ice'
---
> 10,     15.,   .50,   .92,   10.,    5.,    0., 9.0e25,'Tundra'
> 11,     55.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Permanent ice'
28c28
< 11,     82.,   .95,   .95,  0.01,    5.,    0., 9.0e25,'Permanent ice'
---
> 11,     70.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Permanent ice'
34,40c34,40
< 1,      18.,   .10,   .88,   50.,    3.,   .52, 18.9e5,'Urban and Built-Up Land'
< 2,      17.,   .30,   .92,   15.,    4.,   .60, 25.0e5,'Dryland Cropland and Pasture'
< 3,      18.,   .50,   .92,   15.,    4.,   .60, 25.0e5,'Irrigated Cropland and Pasture'
< 4,      18.,   .25,   .92,   15.,    4.,   .60, 25.0e5,'Mixed Dryland/Irrigated Cropland and Pasture'
< 5,      18.,   .25,   .92,   14.,    4.,   .60, 25.0e5,'Cropland/Grassland Mosaic'
< 6,      16.,   .35,   .93,   20.,    4.,   .60, 25.0e5,'Cropland/Woodland Mosaic'
< 7,      19.,   .15,   .92,   12.,    3.,   .60, 20.8e5,'Grassland'
---
> 1,      15.,   .10,   .88,   50.,    3.,   .52, 18.9e5,'Urban and Built-Up Land'
> 2,      17.,   .30,  .985,   15.,    4.,   .60, 25.0e5,'Dryland Cropland and Pasture'
> 3,      18.,   .50,  .985,   15.,    4.,   .60, 25.0e5,'Irrigated Cropland and Pasture'
> 4,      18.,   .25,  .985,   15.,    4.,   .60, 25.0e5,'Mixed Dryland/Irrigated Cropland and Pasture'
> 5,      18.,   .25,   .99,   14.,    4.,   .60, 25.0e5,'Cropland/Grassland Mosaic'
> 6,      16.,   .35,  .985,   20.,    4.,   .60, 25.0e5,'Cropland/Woodland Mosaic'
> 7,      19.,   .15,  .985,   12.,    3.,   .60, 20.8e5,'Grassland'
57c57
< 24,     80.,   .95,   .95,  0.01,    5.,    0., 9.0e25,'Snow or Ice'
---
> 24,     55.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Snow or Ice'
59c59
< 1,      18.,   .10,   .88,   50.,    3.,   .52, 18.9e5,'Urban and Built-Up Land'
---
> 1,      15.,   .10,   .88,   50.,    3.,   .52, 18.9e5,'Urban and Built-Up Land'
82c82
< 24,     82.,   .95,   .95,  0.01,    5.,    0., 9.0e25,'Snow or Ice'
---
> 24,     70.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Snow or Ice'
95c95
< 10,     15.,   .50,   .92,   10.,    5.,   .60, 9.0e25,'Groundcover with Dwarf Trees and Shrubs'
---
> 10,     15.,   .50,   .92,   10.,    5.,    0., 9.0e25,'Groundcover with Dwarf Trees and Shrubs'
101c101
< 16,     80.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Ice Cap and Glacier'
---
> 16,     55.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Ice Cap and Glacier'
118c118
< 16,     82.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Ice Cap and Glacier'
---
> 16,     70.,   .95,   .95,    5.,    5.,    0., 9.0e25,'Ice Cap and Glacier'
===================================================================
Run/mm5.F
diff -r3.12 -r3.15
70a71,76
> #ifdef CRAY_TIM                                                                  23DEC04.1
>       integer*8 flop_lclk_rate                                                   23DEC04.2
>       real*8    f0, f1, flop, f2, f3, ftot                                       23DEC04.3
>       integer*8 tick0, tick1, i0, i1, irtc_rate                                  23DEC04.4
>       integer*8 tick2, tick3, i2, i3, itot, ttot                                 23DEC04.5
> #endif                                                                           23DEC04.6
73a80,86
> #ifdef CRAY_TIM                                                                  23DEC04.7
>        ttot = 0                                                                  23DEC04.8
>        itot = 0                                                                  23DEC04.9
>        ftot = 0.0                                                                23DEC04.10
>        f0 = flop( tick0 )                                                        23DEC04.11
>        i0 = irtc()                                                               23DEC04.12
> #endif                                                                           23DEC04.13
182a196,199
> #ifdef CRAY_TIM                                                                  23DEC04.14
>       print *,'init wall time = ',                                               23DEC04.15
>      &         float(irtc()-i0)/float(irtc_rate()),' sec'                        23DEC04.16
> #endif                                                                           23DEC04.17
186a204,208
> C                                                                                23DEC04.18
> #ifdef CRAY_TIM                                                                  23DEC04.19
>       f2 = flop( tick2, 0 )                                                      23DEC04.20
>       i2 = irtc()                                                                23DEC04.21
> #endif                                                                           23DEC04.22
197c219
<      -     IFSNOW,IEXSI,IL,JL)                                                   19DEC02.1
---
>      -     IFSNOW,IEXSI,IMOIAV,IL,JL)                                            23DEC04.23
204c226
<      -          IFSNOW,IEXSI,IL,JL)                                              19DEC02.2
---
>      -          IFSNOW,IEXSI,IMOIAV,IL,JL)                                       23DEC04.24
266c288
< #if (defined(CRAY) && !defined(T3E))
---
> #if (defined(CRAY) && !defined(T3E) && !defined(crayx1))                         
278a301,311
> #ifdef CRAY_TIM                                                                  23DEC04.26
>       i3 = irtc()                                                                23DEC04.27
>       f3 = flop( tick3, 0 )                                                      23DEC04.28
>       itot = itot + (i3 - i2)                                                    23DEC04.29
>       ftot = ftot + (f3 - f2)                                                    23DEC04.30
>       ttot = ttot + (tick3 - tick2)                                              23DEC04.31
> cfck                                                                             23DEC04.32
>       print *,'tstep time=',float(i3-i2)/float(irtc_rate()),' flops=',           23DEC04.33
>      & (f3-f2),' mflops/sec=',(f3-f2)*1.e-6*irtc_rate()/(i3-i2)                  23DEC04.34
> #endif                                                                           23DEC04.35
> C                                                                                23DEC04.36
281a315,327
> #ifdef CRAY_TIM                                                                  23DEC04.37
>       i1 = irtc()                                                                23DEC04.38
>       f1 = flop( tick1 )                                                         23DEC04.39
>       print *,'inner flops =',ftot                                               23DEC04.40
>       print *,'inner wall mflops/sec = ',                                        23DEC04.41
>      &         (ftot)*1.e-6*irtc_rate()/(itot)                                   23DEC04.42
>       print *,'inner wall time = ',                                              23DEC04.43
>      &         float(itot)/float(irtc_rate()),' sec'                             23DEC04.44
>       print *,'flops =',f1-f0                                                    23DEC04.45
>       print *,'wall mflops/sec = ',(f1-f0)*1.e-6*irtc_rate()/(i1-i0)             23DEC04.46
>       print *,'wall time = ',float(i1-i0)/float(irtc_rate()),' sec'              23DEC04.47
> #endif                                                                           23DEC04.48
> C                                                                                23DEC04.49
===================================================================
Templates/lparam
diff -r3.8 -r3.12
9c9,12
<  ITPDIF    = 1,    ;diffusion using perturbation temperature - 0,1
---
>  ITPDIF    = 1,    ;sigma-diffusion using temperature - 0, sigma-diffusion using perturbation 
>  ;                 ;temperature - 1, z-diffusion - 2
>  TDKORR    = 2,    ;temperature gradient correction for z-diffusion at ground level
>  ;                 ;uses -1- ground temp, -2- one-sided difference of air temp
12a16,27
>  LEVSLP    = 9,    ;nest level (correspond to LEVIDN) at which solar radiation starts to 
>                    ;account for orography
>                    ;set large to switch off
>                    ;only have an effect for very high resolution model domains
>  OROSHAW   = 0,    ;include effect of orography shadowing 
>                    ;ONLY has an effect if LEVSLP is also set
>                    ;0=no effect (default), 
>                    ;1=orography shadowing taken into account - NOT AVAILABLE FOR MPI RUNS
>  ITADVM = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ; 0: default - instability limiter not used 
>                                         ; 1: use instability limiter for temp advection
>  IQADVM = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ; 0: default - instability limiter not used 
>                                         ; 1: use instability limiter for QV/CLW advection
28a44,45
>  ISFMTHD= 1,                            ;method for calculation of 2m/10m diagnostics
>                                         ;0 - old method, 1 - new method for stable conditions
40a58,68
>  ;
>  ; Default soil layers expected as input for ISOIL 2 & 3
>  ; These values reflect the BOTTOM of the soil layer available
>  ISTLYR = 10,40,100,200,
>  ISMLYR = 10,40,100,200,
>  ;ISTLYR = 10,200,0,0,    
>  ;ISMLYR = 10,200,0,0,    
>  ; Other common layers used by EC models (for instance ERA40)
>  ;ISTLYR = 7,28,100,255, 
>  ;ISMLYR = 7,28,100,255, 
>  ;
===================================================================
Templates/mm5.deck.ibm-mpp
diff -r3.3 -r3.4
19,21c19,22
< set TMPDIR = /ptmp/mm5$$
< mkdir $TMPDIR
< cd $TMPDIR
---
> if ( ! -e /ptmp/$USER ) then
>    mkdir /ptmp/$USER
> endif
> set TMPDIR=/ptmp/$USER
224a226,230
> # IPOLAR - (integer) for polar model used only if ISOIL=1
> #                                     0=not polar (5-layer soil model)
> #                                     1=polar (7-layer snow/soil model)
> IPOLAR = 0
> #
===================================================================
Templates/oparam
diff -r3.3 -r3.5
19a20,22
>  IFRSFA = .FALSE.,      ; IF this is a RESTART run, AND IF FDDA is ON, 
>                         ; AND IF multiple input FILES are used, set this to .TRUE.
>                         ; set CDATEST to the INITIAL time of the first run
21c24,26
<     CDATEST = '1993-03-13_00:00:00', ; the DATE for the starting file
---
>                         ; also need to set CDATEST if set to .TRUE.
>     CDATEST = '1993-03-13_00:00:00', ; IF IFSKIP=.TRUE., this will be the date from which the code should start
>                                      ; IF IFRSFA=.TRUE., this will be the INITIAL date from the first model run
===================================================================
Util/parseconfig.c
diff -r3.6 -r3.7
436a437,438
> 	    } else if (MPHYSTBL == 2) {
> 		fprintf(fd,"#define MPHYSTBL2 1\n");
===================================================================
domain/boundary/lbdyin.F
diff -r3.28 -r3.32
2c2
<      -     ,IFSNOW,IEXSI,IX,JX)                                                  19DEC02.26
---
>      -     ,IFSNOW,IEXSI,IMOIAV,IX,JX)                                           23DEC04.50
42c42
<       INTEGER IACTIV(MAXSES),IFSNOW(MAXSES)                                      05DEC01.7
---
>       INTEGER IACTIV(MAXSES),IFSNOW(MAXSES),IMOIAV(MAXSES)                       23DEC04.51
296a297
>           CALL DM_BCAST_INTEGERS(IFOUNDSIF,1)                                    23DEC04.52
339c340
<             MAVAIL(I,J)=SLMO(IS,ISN)                                             05DEC01.27
---
>             IF(IMOIAV(INEST).EQ.0)MAVAIL(I,J)=SLMO(IS,ISN)                       23DEC04.53
408c409
<                   MAVAIN(I,J)=SLMO(IS,ISN)                                       05DEC01.48
---
>                   IF(IMOIAV(NN).EQ.0)MAVAIN(I,J)=SLMO(IS,ISN)                    23DEC04.54
453c454
< 9020  PRINT *,'ERROR OPENING LOWBDY FILE'                                        LBDYIN.380
---
> 9020  CONTINUE                                                                   23DEC04.55
454a456
>         PRINT *,'ERROR OPENING LOWBDY FILE'                                      23DEC04.56
456a459
>         PRINT *,'ADVISORY:'                                                      23DEC04.57
===================================================================
domain/drivers/Makefile
diff -r3.0 -r3.1
11c11,13
< 	nstlev3.o
---
> 	nstlev3.o \
> 	nstlev4.o \
> 	nstlev5.o
16c18,20
< 	nstlev3.i
---
> 	nstlev3.i \
> 	nstlev4.i \
> 	nstlev5.i
21c25,27
< 	nstlev3.f
---
> 	nstlev3.f \
> 	nstlev4.f \
> 	nstlev5.f
57a64,71
> nstlev4.o: ../../include/defines.incl ../../include/parame.incl
> nstlev4.o: ../../include/param2.incl ../../include/param3.incl
> nstlev4.o: ../../include/varia.incl ../../include/addr0.incl
> nstlev4.o: ../../include/various.incl ../../include/variousn.incl
> nstlev5.o: ../../include/defines.incl ../../include/parame.incl
> nstlev5.o: ../../include/param2.incl ../../include/param3.incl
> nstlev5.o: ../../include/varia.incl ../../include/addr0.incl
> nstlev5.o: ../../include/various.incl ../../include/variousn.incl
===================================================================
domain/drivers/nstlev3.F
diff -r3.2 -r3.4
55c55
< C          IF(NUMLV(IDLEV+1,L).GT.0)CALL NSTLEV4(IEXEC,L)                        25JAN00.22
---
>           IF(NUMLV(IDLEV+1,L).GT.0)CALL NSTLEV4(IEXEC,L)                         23DEC04.58
===================================================================
domain/initial/Makefile
diff -r3.5 -r3.6
61a62
> init.o: ../../include/zdiffu.incl ../../include/zdiffu2.incl
===================================================================
domain/initial/init.F
diff -r3.36 -r3.43
39a40,41
> #     include <zdiffu.incl>                                                      23DEC04.59
> #     include <zdiffu2.incl>                                                     23DEC04.60
58a61,62
>           SEAICE(I,J)=0.                                                         23DEC04.61
>           SNOWC(I,J)=0.                                                          23DEC04.62
148a153,182
>                                                                                  23DEC04.63
> C                                                                                23DEC04.64
> C   -----SET INITIAL VARIABLES FOR ITPDIF=2                                      23DEC04.65
>         oldnest = 0                                                              23DEC04.66
>         diffpar = .true.                                                         23DEC04.67
> C                                                                                23DEC04.68
>       IF (ITPDIF .ge. 2) THEN                                                    23DEC04.69
>         DO K=1,KL                                                                23DEC04.70
>           DO I=1,ILX                                                             23DEC04.71
>             DO J=1,JLX                                                           23DEC04.72
>               MRKJP2(i,j,k) = 0.                                                 23DEC04.73
>               MRKJM2(i,j,k) = 0.                                                 23DEC04.74
>               MRKJP1(i,j,k) = 0.                                                 23DEC04.75
>               MRKJM1(i,j,k) = 0.                                                 23DEC04.76
>               MRKIP2(i,j,k) = 0.                                                 23DEC04.77
>               MRKIM2(i,j,k) = 0.                                                 23DEC04.78
>               MRKIP1(i,j,k) = 0.                                                 23DEC04.79
>               MRKIM1(i,j,k) = 0.                                                 23DEC04.80
>               IRKJP2(i,j,k) = 0                                                  23DEC04.81
>               IRKJM2(i,j,k) = 0                                                  23DEC04.82
>               IRKJP1(i,j,k) = 0                                                  23DEC04.83
>               IRKJM1(i,j,k) = 0                                                  23DEC04.84
>               IRKIP2(i,j,k) = 0                                                  23DEC04.85
>               IRKIM2(i,j,k) = 0                                                  23DEC04.86
>               IRKIP1(i,j,k) = 0                                                  23DEC04.87
>               IRKIM1(i,j,k) = 0                                                  23DEC04.88
>             ENDDO                                                                23DEC04.89
>           ENDDO                                                                  23DEC04.90
>         ENDDO                                                                    23DEC04.91
>       ENDIF                                                                      23DEC04.92
173c207
<      -     IFSNOW,IEXSI,IX,JX)                                                   19DEC02.66
---
>      -     IFSNOW,IEXSI,IMOIAV,IX,JX)                                            23DEC04.93
478a513,514
> C COMMENT THE FOLLOWING LINE IF USING THIS ADJUSTMENT                            23DEC04.94
> C IF CHANGING THIS ALSO DO THE SAME IN INITNEST                                  23DEC04.95
520c556
< 	      else                                                               19DEC02.80
---
>               else                                                               23DEC04.96
779,780d814
<              TSLA(I,J,1)=273.16                                                  05DEC01.66
<              TSLB(I,J,1)=273.16                                                  05DEC01.67
784,799d817
<           IF(SNOWC(I,J)*0.01.GT.ZS(2).AND.TSLA(I,J,2).GT.273.16)THEN             05DEC01.71
<              TSLA(I,J,2)=273.16                                                  05DEC01.72
<              TSLB(I,J,2)=273.16                                                  05DEC01.73
<           ENDIF                                                                  05DEC01.74
<           IF(SNOWC(I,J)*0.01.GT.ZS(3).AND.TSLA(I,J,3).GT.273.16)THEN             05DEC01.75
<              TSLA(I,J,3)=273.16                                                  05DEC01.76
<              TSLB(I,J,3)=273.16                                                  05DEC01.77
<           ENDIF                                                                  05DEC01.78
<           IF(SNOWC(I,J)*0.01.GT.ZS(4).AND.TSLA(I,J,4).GT.273.16)THEN             05DEC01.79
<              TSLA(I,J,4)=273.16                                                  05DEC01.80
<              TSLB(I,J,4)=273.16                                                  05DEC01.81
<           ENDIF                                                                  05DEC01.82
<           IF(SNOWC(I,J)*0.01.GT.ZS(5).AND.TSLA(I,J,5).GT.273.16)THEN             05DEC01.83
<              TSLA(I,J,5)=273.16                                                  05DEC01.84
<              TSLB(I,J,5)=273.16                                                  05DEC01.85
<           ENDIF                                                                  05DEC01.86
801a820,829
>       DO L=1,MLX                                                                 23DEC04.97
>         DO J=1,JLX                                                               23DEC04.98
>           DO I=1,ILX                                                             23DEC04.99
>           IF(SNOWC(I,J)*0.01.GT.ZS(L).AND.TSLA(I,J,L).GT.273.16)THEN             23DEC04.100
>              TSLA(I,J,L)=273.16                                                  23DEC04.101
>              TSLB(I,J,L)=273.16                                                  23DEC04.102
>           ENDIF                                                                  23DEC04.103
>           ENDDO                                                                  23DEC04.104
>         ENDDO                                                                    23DEC04.105
>       ENDDO                                                                      23DEC04.106
===================================================================
domain/initial/param.F
diff -r3.66 -r3.76
83c83
<       INTEGER I_FRAD,I_ICUPA,I_IBLT,I_IMPHYS,I_ISOIL                             PARAM.73
---
>       INTEGER I_FRAD,I_ICUPA,I_IBLT,I_IMPHYS,I_ISOIL,I_MPHYSTBL                  23DEC04.107
85c85
<      -          I_ISOIL(0:10)                                                    PARAM.75
---
>      -          I_ISOIL(0:10),I_MPHYSTBL(0:10)                                   23DEC04.108
99c99,100
<       INTEGER I_NESTED,I_ISHALLO1,I_MPHYSTBL1                                    PARAM.89
---
> CB      INTEGER I_NESTED,I_ISHALLO1,I_MPHYSTBL1                                  23DEC04.109
>       INTEGER I_NESTED,I_ISHALLO1                                                23DEC04.110
106c107,108
<      2                 IFSKIP,CDATEST,IFPRT,PRTFRQ,MASCHK,ISFOUT,                PARAM.96
---
>      2                 IFSKIP,CDATEST,IFRSFA,                                    23DEC04.111
>      +                 IFPRT,PRTFRQ,MASCHK,ISFOUT,                               23DEC04.112
118a121
>      &        ,ISFMTHD,LEVSLP,OROSHAW,ITADVM,IQADVM,TDKORR                       23DEC04.113
186a190,194
> C     IFRSFA : USED IF THIS IS A RESTART RUN, FDDA IS ACTIVE AND MULTIPLE        23DEC04.114
> C              BOUNDARY FILES ARE USED                                           23DEC04.115
> C              = .TRUE. ; YES (NEED ALSO TO SPECIFY CDATEST)                     23DEC04.116
> C              = .FALSE. ; NO                                                    23DEC04.117
> C                                                                                23DEC04.118
247a256,259
> C     ISFMTHD : METHOD USED TO CALCULATE 2M AND 10M DIAGNOSTICS                  23DEC04.119
> C               IN HIRPBL AND MRFPBL REGIMES 1 AND 2 ONLY                        23DEC04.120
> C              = 0 ; OLD METHOD (CONSTANT RI BELOW LOWEST LEVEL)                 23DEC04.121
> C              = 1 ; NEW METHOD (USE CONSTANT M-O LENGTH INSTEAD)                23DEC04.122
734c746
<      -              ERR=9006)                                                    19DEC02.252
---
>      -              ERR=9007)                                                    23DEC04.123
810c822
<      -              ERR=9006)                                                    19DEC02.328
---
>      -              ERR=9008)                                                    23DEC04.124
890c902
<      -              ERR=9006)                                                    19DEC02.408
---
>      -              ERR=9009)                                                    23DEC04.125
956a969
>       IFRSFA=.FALSE.                                                             23DEC04.126
1003a1017
>       ISFMTHD=1                                                                  23DEC04.127
1022a1037
>       TDKORR=2                                                                   23DEC04.128
1024a1040,1043
>       LEVSLP=9                                                                   23DEC04.129
>       OROSHAW=0                                                                  23DEC04.130
>       ITADVM(1)=0                                                                23DEC04.131
>       IQADVM(1)=0                                                                23DEC04.132
1052,1055c1071,1078
<       ISTLYR(1)=10                                                               24SEP99.81
<       ISTLYR(2)=200                                                              24SEP99.82
<       ISMLYR(1)=10                                                               24SEP99.84
<       ISMLYR(2)=200                                                              24SEP99.85
---
>       ISTLYR(1)=10                                                               23DEC04.133
>       ISTLYR(2)=40                                                               23DEC04.134
>       ISTLYR(3)=100                                                              23DEC04.135
>       ISTLYR(4)=200                                                              23DEC04.136
>       ISMLYR(1)=10                                                               23DEC04.137
>       ISMLYR(2)=40                                                               23DEC04.138
>       ISMLYR(3)=100                                                              23DEC04.139
>       ISMLYR(4)=200                                                              23DEC04.140
1086a1110,1111
>           ITADVM(n)=ITADVM(1)                                                    23DEC04.141
>           IQADVM(n)=IQADVM(1)                                                    23DEC04.142
1408a1434,1439
>       IF (OROSHAW.EQ.1) THEN                                                     23DEC04.143
>          OROSHAW=0                                                               23DEC04.144
>          PRINT *,'* ADVISORY                                      *'             23DEC04.145
>          PRINT *,'* OROSHAW=1 IS NOT AVALIABLE FOR MPP VERSION    *'             23DEC04.146
>          PRINT *,'* OROSHAW has been RESET to 0                   *'             23DEC04.147
>       ENDIF                                                                      23DEC04.148
1446a1478,1482
> #ifdef MPHYSTBL2                                                                 23DEC04.149
>       BHI(29,13)=2                                                               23DEC04.150
>       BHIC(29,13)='MPHYSTBL: 2=USE OPTIMIZED VERSION OF '                        23DEC04.151
>      *    //      'THE EXPLICIT MOISTURE SCHEME         '                        23DEC04.152
> #endif                                                                           23DEC04.153
1751,1755c1787,1801
< #ifdef MPHYSTBL1                                                                 PARAM.1342
<       I_MPHYSTBL1=1                                                              PARAM.1343
< #else                                                                            PARAM.1344
<       I_MPHYSTBL1=0                                                              PARAM.1345
< #endif                                                                           PARAM.1346
---
> #ifdef MPHYSTBL0                                                                 23DEC04.154
>       I_MPHYSTBL(0)=1                                                            23DEC04.155
> #else                                                                            23DEC04.156
>       I_MPHYSTBL(0)=0                                                            23DEC04.157
> #endif                                                                           23DEC04.158
> #ifdef MPHYSTBL1                                                                 23DEC04.159
>       I_MPHYSTBL(1)=1                                                            23DEC04.160
> #else                                                                            23DEC04.161
>       I_MPHYSTBL(1)=0                                                            23DEC04.162
> #endif                                                                           23DEC04.163
> #ifdef MPHYSTBL2                                                                 23DEC04.164
>       I_MPHYSTBL(2)=1                                                            23DEC04.165
> #else                                                                            23DEC04.166
>       I_MPHYSTBL(2)=0                                                            23DEC04.167
> #endif                                                                           23DEC04.168
1930a1977,1980
>       IF(ITPDIF.EQ.2 .AND. (TDKORR.LT.1.OR.TDKORR.GT.2))THEN                     23DEC04.169
>         PRINT *,'ERROR: ITPDIF=2 REQUIRES TDKORR=1 OR 2'                         23DEC04.170
>         IWARN=IWARN+1                                                            23DEC04.171
>       ENDIF                                                                      23DEC04.172
1998,1999c2048,2049
<       IF(IBLTYP(1).NE.4.AND.IEXSI.GE.1)THEN                                      19DEC02.466
<         PRINT *,'ERROR: IEXSI.GE.1 REQUIRES IBLTYP=4'                            19DEC02.467
---
>       IF((IBLTYP(1).NE.4.AND.IBLTYP(1).NE.5).AND.IEXSI.GE.1)THEN                 23DEC04.173
>         PRINT *,'ERROR: IEXSI.GE.1 REQUIRES IBLTYP=4 OR 5'                       23DEC04.174
2007,2008c2057,2058
<       IF(IFSNOW(1).EQ.2.AND.ISOIL.EQ.2)THEN                                      19DEC02.470
<         PRINT *,'ERROR: IFSNOW=2 CANNOT BE USED WHEN ISOIL=2'                    19DEC02.471
---
>       IF(IFSNOW(1).EQ.2.AND.ISOIL.GE.2)THEN                                      23DEC04.175
>         PRINT *,'ERROR: IFSNOW=2 CANNOT BE USED WHEN ISOIL=2 or ISOIL=3'         23DEC04.176
2090,2091c2140,2141
<           IF(IBLTYP(N).NE.4.AND.IEXSI.GE.1)THEN                                  19DEC02.475
<             PRINT *,'ERROR: IEXSI.GE.1 REQUIRES IBLTYP=4'                        19DEC02.476
---
>           IF((IBLTYP(N).NE.4.AND.IBLTYP(N).NE.5).AND.IEXSI.GE.1)THEN             23DEC04.177
>             PRINT *,'ERROR: IEXSI.GE.1 REQUIRES IBLTYP=4 OR 5'                   23DEC04.178
2212c2262
<       IF(IFSKIP)CDATE=CDATEST                                                    PARAM.1713
---
>       IF(IFSKIP .OR. IFRSFA)CDATE=CDATEST                                        23DEC04.179
2651a2702,2714
>       IF(IMPHYS(1).EQ.5) THEN                                                    23DEC04.180
> C CONSTANT IN COOPER CURVES (CONSISTENT WITH CONSTANTS USED IN EXMOISR)          23DEC04.181
>         BETAI=0.304                                                              23DEC04.182
>         XN0=5.                                                                   23DEC04.183
>       END IF                                                                     23DEC04.184
> C WHEN LOOKUP TABLE IS USED, USE SAME IMPHYS IN ALL DOMAINS                      23DEC04.185
> C   OTHERWISE CONSTANTS USED IN DIFFERENT SCHEMES WILL NOT BE THE SAME           23DEC04.186
> C   AS THEY WOULD BE WHEN USING THE NON-LOOKUP TABLE VERSION                     23DEC04.187
>       DO N = 2,MAXNES                                                            23DEC04.188
>          IF(IMPHYS(N).NE.IMPHYS(1)) PRINT 3110                                   23DEC04.189
>       END DO                                                                     23DEC04.190
> 3110  FORMAT(/,'WARNING: DIFF IMPHYS ARE USED IN DIFF DOMAINS - USING ',         23DEC04.191
>      +       'SAME IMPHYS IN ALL DOMAINS IS RECOMMENDED')                        23DEC04.192
2950c3013
< 9004  PRINT *, 'ERRPR OPENING BUCKET MODEL DATA FILE FROM UNIT 18'               07NOV00.307
---
> 9004  PRINT *, 'ERROR OPENING BUCKET MODEL DATA FILE FROM UNIT 18'               23DEC04.193
2952c3015
< 9005  PRINT *, 'ERRPR OPENING NAMELIST FILE mmlif'                               07NOV00.309
---
> 9005  PRINT *, 'ERROR OPENING NAMELIST FILE mmlif'                               23DEC04.194
2954c3017
< 9006  PRINT *, 'ERRPR OPENING LANDUSE.TBL FILE FROM UNIT 19'                     07NOV00.311
---
> 9006  PRINT *, 'ERROR OPENING LANDUSE.TBL FILE FROM UNIT 19'                     23DEC04.195
2955a3019,3024
> 9007  PRINT *, 'ERROR OPENING VEGPARM.TBL FILE FROM UNIT 19'                     23DEC04.196
>       STOP '9007 IN PARAM'                                                       23DEC04.197
> 9008  PRINT *, 'ERROR OPENING SOILPARM.TBL FILE FROM UNIT 19'                    23DEC04.198
>       STOP '9008 IN PARAM'                                                       23DEC04.199
> 9009  PRINT *, 'ERROR OPENING GENPARM.TBL FILE FROM UNIT 19'                     23DEC04.200
>       STOP '9009 IN PARAM'                                                       23DEC04.201
2964c3033
< 9004  PRINT *, 'ERRPR OPENING BUCKET MODEL DATA FILE FROM UNIT 18'               07NOV00.313
---
> 9004  PRINT *, 'ERROR OPENING BUCKET MODEL DATA FILE FROM UNIT 18'               23DEC04.202
2968c3037
< 9006  PRINT *, 'ERRPR OPENING LANDUSE.TBL FILE FROM UNIT 19'                     07NOV00.317
---
> 9006  PRINT *, 'ERROR OPENING LANDUSE.TBL FILE FROM UNIT 19'                     23DEC04.203
2969a3039,3044
> 9007  PRINT *, 'ERROR OPENING VEGPARM.TBL FILE FROM UNIT 19'                     23DEC04.204
>       CALL FKILL_MODEL( '9007 IN PARAM' )                                        23DEC04.205
> 9008  PRINT *, 'ERROR OPENING SOILPARM.TBL FILE FROM UNIT 19'                    23DEC04.206
>       CALL FKILL_MODEL( '9008 IN PARAM' )                                        23DEC04.207
> 9009  PRINT *, 'ERROR OPENING GENPARM.TBL FILE FROM UNIT 19'                     23DEC04.208
>       CALL FKILL_MODEL( '9009 IN PARAM' )                                        23DEC04.209
===================================================================
domain/initial/paramr.F
diff -r3.5 -r3.8
28c28
<      1 .4149,.4320,.4406,.4483,.4460,.4433,.4413,.4382,                          PARAMR.28
---
>      1 .4149,.4320,.4506,.4483,.4460,.4433,.4413,.4382,                          23DEC04.210
35c35,36
<       RON2=1.E10                                                                 19DEC02.507
---
> c     RON2=1.E10                                                                 23DEC04.211
>       RON2=1.E9                                                                  23DEC04.212
37,40c38,45
<       GON=5.E7                                                                   PARAMR.37
<       ron_min = 8.e6                                                             19DEC02.508
<       ron_qr0 = 0.00010                                                          19DEC02.509
<       ron_delqr0 = 0.25*ron_qr0                                                  19DEC02.510
---
> c     GON=5.E7                                                                   23DEC04.213
>       GON=4.E6                                                                   23DEC04.214
> c     ron_min = 8.e6                                                             23DEC04.215
>       ron_min = 2.e7                                                             23DEC04.216
> c     ron_qr0 = 0.00010                                                          23DEC04.217
>       ron_qr0 = 0.00020                                                          23DEC04.218
> c     ron_delqr0 = 0.25*ron_qr0                                                  23DEC04.219
>       ron_delqr0 = 0.5*ron_qr0                                                   23DEC04.220
57,58c62,63
<       XR0S=0.75E-4                                                               PARAMR.52
<       XR0G=0.457E-4                                                              PARAMR.53
---
>       XR0S= 75.E-6                                                               23DEC04.221
>       XR0G=150.E-6                                                               23DEC04.222
85,88c90
< C Number of cloud droplets. Walko autoconv is Kessler-like with min diameter     19DEC02.514
< C of cloud drops exceed 17 microns before conversion to rain.  Using             19DEC02.515
< C 132 drops per cc, implies qc>0.35 g/kg before rain is produced.                19DEC02.516
<       CNP=132.E6                                                                 19DEC02.517
---
>       CNP=100.E6                                                                 23DEC04.223
145,146c147,148
< C     GI=3.+BG                                                                   05DEC01.204
<       GI=4.+BG                                                                   05DEC01.205
---
>       GI=3.+BG                                                                   23DEC04.224
> C     GI=4.+BG                                                                   23DEC04.225
149c151,152
<       BACRCG=4.+BG                                                               19DEC02.518
---
>       BACRCG=3.+BG                                                               23DEC04.226
> C     BACRCG=4.+BG                                                               23DEC04.227
===================================================================
domain/io/initsav.F
diff -r3.11 -r3.13
67a68
>         CLOSE (IUTSAV)                                                           23DEC04.228
===================================================================
domain/io/output.F
diff -r3.13 -r3.15
53c53
<             REWIND IUTSAV                                                        OUTPUT.51
---
>             CLOSE  (IUTSAV)                                                      23DEC04.229
55c55
<    50       FORMAT(6X,'+++ REWINDING SAVE FILE FOR DOMAIN ',I2)                  OUTPUT.53
---
>    50       FORMAT(6X,'+++ CLOSING SAVE FILE FOR DOMAIN ',I2)                    23DEC04.230
===================================================================
domain/io/outtap.F
diff -r3.66 -r3.72
316c316
<       JBHI (3,11)=6                                                              19DEC02.556
---
>       JBHI (3,11)=7                                                              23DEC04.231
874c874
<          CALL FILLCRS(TKEA,MIX,MJX,MKX,IL,JL,KL+1)                               07NOV00.428
---
>          CALL FILLCRS(TKEA,MIX,MJX,MKX+1,IL,JL,KL+1)                             23DEC04.232
1129a1130,1135
>         CALL EQUATO(TGSI,MIX,MJX,1,HDOTH,IL,JL,1)                                23DEC04.233
>         CALL WRITE_FIELDREC( iutl,D2,nescou,HDOTH,XTIME,                         23DEC04.234
>      +                     'TGSI    ',CURRENT_DATE,                              23DEC04.235
>      +                     'C','YX','K',                                         23DEC04.236
>      +                     'SEA ICE TEMPERATURE',                                23DEC04.237
>      +                     IX,JX,1,MIX,MJX,1 )                                   23DEC04.238
===================================================================
domain/io/rdinit.F
diff -r3.38 -r3.42
722,723c722,723
< C       USE SURFACE GEOPOTENTIAL FROM ANALYSIS TO ADJUST SOILT (6K/KM)           RDINIT.551
<         TLAPSE=.006                                                              RDINIT.552
---
> C       USE SURFACE GEOPOTENTIAL FROM ANALYSIS TO ADJUST SOILT (6.5K/KM)         23DEC04.239
>         TLAPSE=.0065                                                             23DEC04.240
792c792
<               IF(FNDSOILW(L))THEN                                                19DEC02.777
---
>               IF(FNDSOILW(1))THEN                                                23DEC04.241
800c800
<               IF(FNDSOILW(L))THEN                                                19DEC02.781
---
>               IF(FNDSOILW(NSML))THEN                                             23DEC04.242
812c812
<                   IF(FNDSOILW(L))THEN                                            19DEC02.785
---
>                   IF(FNDSOILW(NL))THEN                                           23DEC04.243
837d836
<          IF(.NOT.FNDSOILW(L))THEN                                                19DEC02.804
869d867
<            ENDIF                                                                 19DEC02.836
===================================================================
domain/io/rdter.F
diff -r3.16 -r3.18
55c55
<               call abort()                                                       RDTER.46
---
>               STOP                                                               23DEC04.244
===================================================================
domain/nest/Makefile
diff -r3.3 -r3.4
110a111
> feedbk.o: ../../include/zdiffu.incl
===================================================================
domain/nest/feedbk.F
diff -r3.13 -r3.17
40a41
> #     include <zdiffu.incl>                                                      23DEC04.245
82a84,90
>         if ((ITPDIF.gt.1).and.(IOVERW(inest).EQ.2)) then                         23DEC04.246
>           print*, 'Opening new domain with IOVERW=2 and z-diffusion'             23DEC04.247
>           print*, 'requires recomputing interpolation coefficients'              23DEC04.248
>           do i=1,numnc(inest)                                                    23DEC04.249
>             diffpar(i)=.true.                                                    23DEC04.250
>           enddo                                                                  23DEC04.251
>         endif                                                                    23DEC04.252
159,163c167
<             TGSI(ICY,JCX)=F1*TGSIN(IFY,JFX)+F2*(TGSIN(IFP,JFX)+                  19DEC02.897
<      &      TGSIN(IFM,JFX)+TGSIN(IFY,JFP)+TGSIN(IFY,JFM))+F3*                    19DEC02.898
<      &      (TGSIN(IFP,JFP)+TGSIN(IFP,JFM)+TGSIN(IFM,JFP)+                       19DEC02.899
<      &      TGSIN(IFM,JFM))                                                      19DEC02.900
< 	  endif                                                                  19DEC02.901
---
>           endif                                                                  23DEC04.253
166d169
<             TGSI(ICY,JCX)=TGSIN(IFY,JFX)                                         19DEC02.904
273a277,299
> C                                                                                23DEC04.254
> C--- SEA-ICE FEEDBACK                                                            23DEC04.255
> C                                                                                23DEC04.256
>       IF(IEXSI.GE.1)THEN                                                         23DEC04.257
> cmic$ do all autoscope                                                           23DEC04.258
> c$omp parallel do default(shared)                                                23DEC04.259
> c$omp&private(icy,jcx,jfx,jfp,jfm,ify,ifp,ifm)                                   23DEC04.260
>       DO JCX=JWP1,JEM2                                                           23DEC04.261
>         JFX=2+(JCX-JWEST)*IRAX                                                   23DEC04.262
>         JFP=JFX+1                                                                23DEC04.263
>         JFM=JFX-1                                                                23DEC04.264
>         DO ICY=ISP1,INM2                                                         23DEC04.265
>           IFY=2+(ICY-ISOUTH)*IRAX                                                23DEC04.266
>           IFP=IFY+1                                                              23DEC04.267
>           IFM=IFY-1                                                              23DEC04.268
>           IF(IFEED.GE.1) then                                                    23DEC04.269
>             SEAICE(ICY,JCX)=SEAICN(IFY,JFX)                                      23DEC04.270
>             TGSI(ICY,JCX)=TGSIN(IFY,JFX)                                         23DEC04.271
>           ENDIF                                                                  23DEC04.272
>         ENDDO                                                                    23DEC04.273
>       ENDDO                                                                      23DEC04.274
>       ENDIF                                                                      23DEC04.275
>                                                                                  23DEC04.276
===================================================================
domain/nest/initnest.F
diff -r3.52 -r3.60
775a776,780
>         IF(IEXSI.GE.1)THEN                                                       23DEC04.277
>           CALL FILL(SEAICE,HELP1,MIX,MJX,IYY,JXX,IYY-1,JXX-1)                    23DEC04.278
>           CALL EXAINT(HELP1,IYY,JXX,HSCR1N,IYYN,JXXN,ISOUTH,JWEST,1)             23DEC04.279
>           CALL FILL(HSCR1N,SEAICN,IYYN,JXXN,MIX,MJX,IYYN-1,JXXN-1)               23DEC04.280
>         ENDIF                                                                    23DEC04.281
1075,1076d1079
<              TSLA(I,J,1)=273.16                                                  05DEC01.395
<              TSLB(I,J,1)=273.16                                                  05DEC01.396
1080,1099d1082
<           IF(SNOWC(I,J)*0.01.GT.ZS(2).AND.TSLA(I,J,2).GT.273.16)THEN             05DEC01.400
<              TSLA(I,J,2)=273.16                                                  05DEC01.401
<              TSLB(I,J,2)=273.16                                                  05DEC01.402
<           ENDIF                                                                  05DEC01.403
<           IF(SNOWC(I,J)*0.01.GT.ZS(3).AND.TSLA(I,J,3).GT.273.16)THEN             05DEC01.404
<              TSLA(I,J,3)=273.16                                                  05DEC01.405
<              TSLB(I,J,3)=273.16                                                  05DEC01.406
<           ENDIF                                                                  05DEC01.407
<           IF(SNOWC(I,J)*0.01.GT.ZS(4).AND.TSLA(I,J,4).GT.273.16)THEN             05DEC01.408
<              TSLA(I,J,4)=273.16                                                  05DEC01.409
<              TSLB(I,J,4)=273.16                                                  05DEC01.410
<           ENDIF                                                                  05DEC01.411
<           IF(SNOWC(I,J)*0.01.GT.ZS(4).AND.TSLA(I,J,4).GT.273.16)THEN             05DEC01.412
<              TSLA(I,J,4)=273.16                                                  05DEC01.413
<              TSLB(I,J,4)=273.16                                                  05DEC01.414
<           ENDIF                                                                  05DEC01.415
<           IF(SNOWC(I,J)*0.01.GT.ZS(5).AND.TSLA(I,J,5).GT.273.16)THEN             05DEC01.416
<              TSLA(I,J,5)=273.16                                                  05DEC01.417
<              TSLB(I,J,5)=273.16                                                  05DEC01.418
<           ENDIF                                                                  05DEC01.419
1101a1085,1094
>       DO L=1,MLX                                                                 23DEC04.282
>         DO J=1,JLX                                                               23DEC04.283
>           DO I=1,ILX                                                             23DEC04.284
>           IF(SNOWC(I,J)*0.01.GT.ZS(L).AND.TSLA(I,J,L).GT.273.16)THEN             23DEC04.285
>              TSLA(I,J,L)=273.16                                                  23DEC04.286
>              TSLB(I,J,L)=273.16                                                  23DEC04.287
>           ENDIF                                                                  23DEC04.288
>           ENDDO                                                                  23DEC04.289
>         ENDDO                                                                    23DEC04.290
>       ENDDO                                                                      23DEC04.291
1264c1257
<            CALL ADDRX1C(IAXALL(1,NUMNES-1))                                      07NOV00.861
---
>            CALL ADDRX1C(IAXALL(1,NUMNC(NUMNES)))                                 23DEC04.292
1334c1327
<      -     IFSNOW,IEXSI,IL,JL)                                                   19DEC02.1017
---
>      -     IFSNOW,IEXSI,IMOIAV,IL,JL)                                            23DEC04.293
1807a1801,1802
> c$omp parallel do default(shared)                                                23DEC04.294
> c$omp&private(i,j)                                                               23DEC04.295
1826a1822
> C COMMENT THE FOLLOWING LINE IF USING THIS ADJUSTMENT (ALSO IN INIT)             23DEC04.296
===================================================================
domain/util/dcpl3dwnd.F
diff -r3.4 -r3.6
1,66c1,144
<       SUBROUTINE DCPL3DWND(IB,U,V,UA,VA,RPSD,IL,JL,KL,ILX,JLX)                   DCPL3DWND.1
< #       include <parame.incl>                                                    DCPL3DWND.2
<       DIMENSION U (MIX,MJX,MKX),V (MIX,MJX,MKX),                                 DCPL3DWND.3
<      1          UA(MIX,MJX,MKX),VA(MIX,MJX,MKX),RPSD(MIX,MJX)                    DCPL3DWND.4
< C                                                                                DCPL3DWND.5
< C_FLIC_RUNPAD(2)                                                                 DCPL3DWND.6
< cmic$ do all autoscope                                                           DCPL3DWND.7
< c$doacross                                                                       DCPL3DWND.8
< c$& local(i,j,k)                                                                 DCPL3DWND.9
< c$omp parallel do default(shared)                                                DCPL3DWND.10
< c$omp&private(i,j,k)                                                             DCPL3DWND.11
<       DO J=1,JL                                                                  DCPL3DWND.12
<         DO K=1,KL                                                                DCPL3DWND.13
<           DO I=1,IL                                                              DCPL3DWND.14
<             U(I,J,K)=UA(I,J,K)*RPSD(I,J)                                         DCPL3DWND.15
<             V(I,J,K)=VA(I,J,K)*RPSD(I,J)                                         DCPL3DWND.16
<           ENDDO                                                                  DCPL3DWND.17
<         ENDDO                                                                    DCPL3DWND.18
<       ENDDO                                                                      DCPL3DWND.19
< C                                                                                DCPL3DWND.20
<       IF(IB.GT.2)THEN                                                            DCPL3DWND.21
< c$omp parallel                                                                   05DEC01.451
< c$omp&private(i,k)                                                               05DEC01.452
< c$        IF(OMP_GET_THREAD_NUM().EQ.0)THEN                                      05DEC01.453
<             DO K=1,KL                                                            DCPL3DWND.29
<               DO I=1,IL                                                          DCPL3DWND.30
<                 IF(U(I,1,K).LT.0.)THEN                                           DCPL3DWND.31
<                   U(I,1,K)=U(I,2,K)                                              DCPL3DWND.32
<                   V(I,1,K)=V(I,2,K)                                              DCPL3DWND.33
<                 ENDIF                                                            DCPL3DWND.34
<               ENDDO                                                              DCPL3DWND.35
<             ENDDO                                                                DCPL3DWND.36
< c$        ENDIF                                                                  05DEC01.454
< c$        IF(OMP_GET_THREAD_NUM().EQ.OMP_GET_NUM_THREADS()-1)THEN                05DEC01.455
<             DO K=1,KL                                                            DCPL3DWND.39
<               DO I=1,IL                                                          DCPL3DWND.40
<                 IF(U(I,JL,K).GT.0.)THEN                                          DCPL3DWND.41
<                   U(I,JL,K)=U(I,JLX,K)                                           DCPL3DWND.42
<                   V(I,JL,K)=V(I,JLX,K)                                           DCPL3DWND.43
<                 ENDIF                                                            DCPL3DWND.44
<               ENDDO                                                              DCPL3DWND.45
<             ENDDO                                                                DCPL3DWND.46
< c$        ENDIF                                                                  05DEC01.456
< c$omp end parallel                                                               05DEC01.457
< cmic$ do all autoscope                                                           05DEC01.458
< c$doacross                                                                       05DEC01.459
< c$& local(i,j,k)                                                                 05DEC01.460
< c$omp parallel do default(shared)                                                05DEC01.461
< c$omp&private(i,j,k)                                                             05DEC01.462
<         DO J=1,JL                                                                05DEC01.463
<           DO K=1,KL                                                              DCPL3DWND.48
<             IF(V(1,J,K).LT.0.)THEN                                               DCPL3DWND.49
<               V(1,J,K)=V(2,J,K)                                                  DCPL3DWND.50
<               U(1,J,K)=U(2,J,K)                                                  DCPL3DWND.51
<             ENDIF                                                                DCPL3DWND.52
< C                                                                                DCPL3DWND.53
<             IF(V(IL,J,K).GT.0.)THEN                                              DCPL3DWND.54
<               V(IL,J,K)=V(ILX,J,K)                                               DCPL3DWND.55
<               U(IL,J,K)=U(ILX,J,K)                                               DCPL3DWND.56
<             ENDIF                                                                DCPL3DWND.57
<           ENDDO                                                                  DCPL3DWND.58
<         ENDDO                                                                    DCPL3DWND.59
<       ENDIF                                                                      DCPL3DWND.60
<       RETURN                                                                     DCPL3DWND.61
<       END                                                                        DCPL3DWND.62
<                                                                                  DCPL3DWND.63
---
> CB Routine replaced entirely by a new optimized version                            23DEC04.4360
> CB      SUBROUTINE DCPL3DWND(IB,U,V,UA,VA,RPSD,IL,JL,KL,ILX,JLX)                   DCPL3DWND.1
> CB#       include <parame.incl>                                                    DCPL3DWND.2
> CB      DIMENSION U (MIX,MJX,MKX),V (MIX,MJX,MKX),                                 DCPL3DWND.3
> CB     1          UA(MIX,MJX,MKX),VA(MIX,MJX,MKX),RPSD(MIX,MJX)                    DCPL3DWND.4
> CBC                                                                                DCPL3DWND.5
> CBC_FLIC_RUNPAD(2)                                                                 DCPL3DWND.6
> CBcmic$ do all autoscope                                                           DCPL3DWND.7
> CBc$doacross                                                                       DCPL3DWND.8
> CBc$& local(i,j,k)                                                                 DCPL3DWND.9
> CBc$omp parallel do default(shared)                                                DCPL3DWND.10
> CBc$omp&private(i,j,k)                                                             DCPL3DWND.11
> CB      DO J=1,JL                                                                  DCPL3DWND.12
> CB        DO K=1,KL                                                                DCPL3DWND.13
> CB          DO I=1,IL                                                              DCPL3DWND.14
> CB            U(I,J,K)=UA(I,J,K)*RPSD(I,J)                                         DCPL3DWND.15
> CB            V(I,J,K)=VA(I,J,K)*RPSD(I,J)                                         DCPL3DWND.16
> CB          ENDDO                                                                  DCPL3DWND.17
> CB        ENDDO                                                                    DCPL3DWND.18
> CB      ENDDO                                                                      DCPL3DWND.19
> CBC                                                                                DCPL3DWND.20
> CB      IF(IB.GT.2)THEN                                                            DCPL3DWND.21
> CBc$omp parallel                                                                   05DEC01.451
> CBc$omp&private(i,k)                                                               05DEC01.452
> CBc$        IF(OMP_GET_THREAD_NUM().EQ.0)THEN                                      05DEC01.453
> CB            DO K=1,KL                                                            DCPL3DWND.29
> CB              DO I=1,IL                                                          DCPL3DWND.30
> CB                IF(U(I,1,K).LT.0.)THEN                                           DCPL3DWND.31
> CB                  U(I,1,K)=U(I,2,K)                                              DCPL3DWND.32
> CB                  V(I,1,K)=V(I,2,K)                                              DCPL3DWND.33
> CB                ENDIF                                                            DCPL3DWND.34
> CB              ENDDO                                                              DCPL3DWND.35
> CB            ENDDO                                                                DCPL3DWND.36
> CBc$        ENDIF                                                                  05DEC01.454
> CBc$        IF(OMP_GET_THREAD_NUM().EQ.OMP_GET_NUM_THREADS()-1)THEN                05DEC01.455
> CB            DO K=1,KL                                                            DCPL3DWND.39
> CB              DO I=1,IL                                                          DCPL3DWND.40
> CB                IF(U(I,JL,K).GT.0.)THEN                                          DCPL3DWND.41
> CB                  U(I,JL,K)=U(I,JLX,K)                                           DCPL3DWND.42
> CB                  V(I,JL,K)=V(I,JLX,K)                                           DCPL3DWND.43
> CB                ENDIF                                                            DCPL3DWND.44
> CB              ENDDO                                                              DCPL3DWND.45
> CB            ENDDO                                                                DCPL3DWND.46
> CBc$        ENDIF                                                                  05DEC01.456
> CBc$omp end parallel                                                               05DEC01.457
> CBcmic$ do all autoscope                                                           05DEC01.458
> CBc$doacross                                                                       05DEC01.459
> CBc$& local(i,j,k)                                                                 05DEC01.460
> CBc$omp parallel do default(shared)                                                05DEC01.461
> CBc$omp&private(i,j,k)                                                             05DEC01.462
> CB        DO J=1,JL                                                                05DEC01.463
> CB          DO K=1,KL                                                              DCPL3DWND.48
> CB            IF(V(1,J,K).LT.0.)THEN                                               DCPL3DWND.49
> CB              V(1,J,K)=V(2,J,K)                                                  DCPL3DWND.50
> CB              U(1,J,K)=U(2,J,K)                                                  DCPL3DWND.51
> CB            ENDIF                                                                DCPL3DWND.52
> CBC                                                                                DCPL3DWND.53
> CB            IF(V(IL,J,K).GT.0.)THEN                                              DCPL3DWND.54
> CB              V(IL,J,K)=V(ILX,J,K)                                               DCPL3DWND.55
> CB              U(IL,J,K)=U(ILX,J,K)                                               DCPL3DWND.56
> CB            ENDIF                                                                DCPL3DWND.57
> CB          ENDDO                                                                  DCPL3DWND.58
> CB        ENDDO                                                                    DCPL3DWND.59
> CB      ENDIF                                                                      DCPL3DWND.60
> CB      RETURN                                                                     DCPL3DWND.61
> CB      END                                                                        DCPL3DWND.62
>                                                                                    DCPL3DWND.63
>                                                                                    23DEC04.4361
>                                                                                    23DEC04.4362
>       SUBROUTINE DCPL3DWND( IB, U3, V3, UC, VC, UA, VA, RPSD, MSFD,                23DEC04.4363
>      &                     IL, JL, KL, ILX, JLX )                                  23DEC04.4364
>       IMPLICIT NONE                                                                23DEC04.4365
> #       include <parame.incl>                                                      23DEC04.4366
>                                                                                    23DEC04.4367
> C........   Arguments                                                              23DEC04.4368
>                                                                                    23DEC04.4369
>       INTEGER  IB,IL,JL,KL,ILX,JLX                                                 23DEC04.4370
>       REAL     U3(MIX,MJX,MKX), V3(MIX,MJX,MKX)                                    23DEC04.4371
>       REAL     UC(MIX,MJX,MKX), VC(MIX,MJX,MKX)                                    23DEC04.4372
>       REAL     UA(MIX,MJX,MKX), VA(MIX,MJX,MKX)                                    23DEC04.4373
>       REAL     RPSD(MIX,MJX), MSFD(MIX,MJX)                                        23DEC04.4374
>                                                                                    23DEC04.4375
> C........   Local Variables                                                        23DEC04.4376
>                                                                                    23DEC04.4377
>       INTEGER  I, J,K                                                              23DEC04.4378
> C................................................................                  23DEC04.4379
> C_FLIC_RUNPAD(2)                                                                   23DEC04.4380
> cmic$ do all autoscope                                                             23DEC04.4381
> c$doacross                                                                         23DEC04.4382
> c$& local(i,j,k)                                                                   23DEC04.4383
> c$omp parallel do default(shared)                                                  23DEC04.4384
> c$omp&private(i,j,k)                                                               23DEC04.4385
>       DO J=1,JL                                                                    23DEC04.4386
>                                                                                    23DEC04.4387
>           DO K=1,KL                                                                23DEC04.4388
>           DO I=1,IL                                                                23DEC04.4389
>             UC(I,J,K)=UA(I,J,K)                                                    23DEC04.4390
>             VC(I,J,K)=VA(I,J,K)                                                    23DEC04.4391
>             UA(I,J,K)=UA(I,J,K)*MSFD(I,J)                                          23DEC04.4392
>             VA(I,J,K)=VA(I,J,K)*MSFD(I,J)                                          23DEC04.4393
>             U3(I,J,K)=UA(I,J,K)*RPSD(I,J)                                          23DEC04.4394
>             V3(I,J,K)=VA(I,J,K)*RPSD(I,J)                                          23DEC04.4395
>           ENDDO                                                                    23DEC04.4396
>           ENDDO                                                                    23DEC04.4397
>                                                                                    23DEC04.4398
>           IF ( IB.GT.2 ) THEN                                                      23DEC04.4399
>                                                                                    23DEC04.4400
>                   IF ( J .EQ. 1 ) THEN                                             23DEC04.4401
>                 DO K=1,KL                                                          23DEC04.4402
>                 DO I=1,IL                                                          23DEC04.4403
>                    IF(U3(I,1,K).LT.0.)THEN                                         23DEC04.4404
>                       U3(I,1,K)=UA(I,2,K)*RPSD(I,2)                                23DEC04.4405
>                       V3(I,1,K)=VA(I,2,K)*RPSD(I,2)                                23DEC04.4406
>                    END IF                                                          23DEC04.4407
>                 ENDDO                                                              23DEC04.4408
>                 ENDDO                                                              23DEC04.4409
>              ELSE IF ( J .EQ. JL ) THEN                                            23DEC04.4410
>                 DO K=1,KL                                                          23DEC04.4411
>                 DO I=1,IL                                                          23DEC04.4412
>                    IF(U3(I,JL,K).LT.0.)THEN                                        23DEC04.4413
>                       U3(I,JL,K)=UA(I,JLX,K)*RPSD(I,JLX)                           23DEC04.4414
>                       V3(I,JL,K)=VA(I,JLX,K)*RPSD(I,JLX)                           23DEC04.4415
>                    END IF                                                          23DEC04.4416
>                 ENDDO                                                              23DEC04.4417
>                 ENDDO                                                              23DEC04.4418
>              END IF                                                                23DEC04.4419
>                                                                                    23DEC04.4420
>              DO K=1,KL                                                             23DEC04.4421
>                 IF(VA(1,J,K).LT.0.)THEN                                            23DEC04.4422
>                    V3(1,J,K)=V3(2,J,K)                                             23DEC04.4423
>                    U3(1,J,K)=U3(2,J,K)                                             23DEC04.4424
>                 ENDIF                                                              23DEC04.4425
>                 IF(VA(IL,J,K).GT.0.)THEN                                           23DEC04.4426
>                    V3(IL,J,K)=V3(ILX,J,K)                                          23DEC04.4427
>                    U3(IL,J,K)=U3(ILX,J,K)                                          23DEC04.4428
>                 ENDIF                                                              23DEC04.4429
>              ENDDO                                                                 23DEC04.4430
>                                                                                    23DEC04.4431
>           END IF                                                                   23DEC04.4432
>                                                                                    23DEC04.4433
>       ENDDO     !  end parallel loop on J                                          23DEC04.4434
>                                                                                    23DEC04.4435
>       RETURN                                                                       23DEC04.4436
>       END                                                                          23DEC04.4437
===================================================================
dynamics/nonhydro/Makefile
diff -r3.3 -r3.4
55,56c55,56
< solve.o: ../../include/pbltke.incl 
< solve.o: ../../include/comicl.incl
---
> solve.o: ../../include/pbltke.incl  ../../include/zdiffu.incl
> solve.o: ../../include/comicl.incl  ../../include/zdiffu2.incl
===================================================================
dynamics/nonhydro/solve.F
diff -r3.51 -r3.62
30a31,32
> #include <zdiffu.incl>                                                           23DEC04.297
> #include <zdiffu2.incl>                                                          23DEC04.298
32a35,37
> C                                                                                23DEC04.299
>       real cbt1 , cbt2 , cbt3 , cbt4                                             23DEC04.300
>       real cbt5 , cbt6 , cbt7 , cbt8                                             23DEC04.301
86c91
< #undef CALL_EVERY_OTHER_TSTEP                                                    19DEC02.1232
---
> #undef CALL_EVERY_OTHER_TSTEP 
145a151,157
>       real deltaz(mix,mjx,mkx-2:mkx),rmz,rmzf,qdm                                23DEC04.303
>       real absv(MIX,MJX),fin(MIX,MJX),fjn(MIX,MJX),lam(MIX,MJX),                 23DEC04.304
>      &  thgb(MIX,MJX)                                                            23DEC04.305
>       integer kmvl,in,tadv,qadv,cwadv                                            23DEC04.306
>       real dz3d(mix,mjx,mkx)                                                     23DEC04.307
> C                                                                                23DEC04.308
>       common /zdiffpar/ deltaz,dz3d                                              23DEC04.309
157a170,208
>       rmz = 0.25                                                                 23DEC04.310
>       rmzf = 2.5e-3                                                              23DEC04.311
>                                                                                  23DEC04.312
>       if (inest.ne.oldnest .and. ITPDIF .eq. 2) then                             23DEC04.313
> C_FLIC_RUNPAD(2)                                                                 23DEC04.314
> C! As these fields are constant, they are computed only if domain has changed    23DEC04.315
> C  only calculated for z=diffusion                                               23DEC04.316
>                                                                                  23DEC04.317
> c  Approximate height differences between sigma levels for z-diffusion           23DEC04.318
> c$omp parallel do default(shared)                                                23DEC04.319
> c$omp&private(i,j,k)                                                             23DEC04.320
>       DO J=1,JLX                                                                 23DEC04.321
>       do k=1,kl-1                                                                23DEC04.322
>       DO I=1,ILX                                                                 23DEC04.323
>       dz3d(i,j,k)=alog(PR0(i,j,k+1)/PR0(i,j,k))*rovg*                            23DEC04.324
>      f  0.5*(T0(i,j,k)+T0(i,j,k+1))                                              23DEC04.325
>       enddo                                                                      23DEC04.326
>       enddo                                                                      23DEC04.327
>       enddo                                                                      23DEC04.328
> c                                                                                23DEC04.329
>                                                                                  23DEC04.330
> c$omp parallel do default(shared)                                                23DEC04.331
> c$omp&private(i,j)                                                               23DEC04.332
>       DO J=1,JLX                                                                 23DEC04.333
>         DO I=1,ILX                                                               23DEC04.334
>           dz3d(i,j,kl)=dz3d(i,j,kl-1)                                            23DEC04.335
>           deltaz(i,j,kl-2) = dz3d(i,j,kl-3)+dz3d(i,j,kl-2)                       23DEC04.336
>           deltaz(i,j,kl-1) = dz3d(i,j,kl-2)+dz3d(i,j,kl-1)                       23DEC04.337
>           if (tdkorr.eq.1) then                                                  23DEC04.338
>             deltaz(i,j,kl) = dz3d(i,j,kl-1)+(1-a(kl))*                           23DEC04.339
>      &        rovg*T0(i,j,kl)                                                    23DEC04.340
>           else if (tdkorr.eq.2) then                                             23DEC04.341
>             deltaz(i,j,kl) = dz3d(i,j,kl-1)                                      23DEC04.342
>           endif                                                                  23DEC04.343
>         enddo                                                                    23DEC04.344
>       enddo                                                                      23DEC04.345
>                                                                                  23DEC04.346
> C_FLIC_RUNPAD(0)                                                                 23DEC04.347
>        endif                                                                     23DEC04.348
185a237,249
> c  instability correction for advection                                          23DEC04.349
>       if (ITADVM(INEST).EQ.0) then                                               23DEC04.350
>          tadv = 1                                                                23DEC04.351
>       else      ! correction is used for temperature                             23DEC04.352
>          tadv = 5                                                                23DEC04.353
>       endif                                                                      23DEC04.354
>       if (IQADVM(INEST).EQ.0) then                                               23DEC04.355
>          qadv = 1                                                                23DEC04.356
>          cwadv = 1                                                               23DEC04.357
>       else      ! correction is used for QV and CLW                              23DEC04.358
>          qadv = 5                                                                23DEC04.359
>          cwadv = 5                                                               23DEC04.360
>       endif                                                                      23DEC04.361
210,218c274,285
<         DO K=1,KL                                                                SOLVE.175
<           DO I=1,IL                                                              SOLVE.176
<             UCD(I,J,K)=UA(I,J,K)                                                 SOLVE.177
<             VCD(I,J,K)=VA(I,J,K)                                                 SOLVE.178
<             UA(I,J,K)=UA(I,J,K)*MSFD(I,J)                                        SOLVE.179
<             VA(I,J,K)=VA(I,J,K)*MSFD(I,J)                                        SOLVE.180
<             W3DTEN(I,J,K)=0.                                                     SOLVE.181
<           ENDDO                                                                  SOLVE.182
<         ENDDO                                                                    SOLVE.183
---
> CB This section of the code was moved into the new routine DCPL3DWND             23DEC04.362
> CB This change was done purely for optimization                                  23DEC04.363
> CB        DO K=1,KL                                                              23DEC04.364
> CB          DO I=1,IL                                                            23DEC04.365
> CB            UCD(I,J,K)=UA(I,J,K)                                               23DEC04.366
> CB            VCD(I,J,K)=VA(I,J,K)                                               23DEC04.367
> CB            UA(I,J,K)=UA(I,J,K)*MSFD(I,J)                                      23DEC04.368
> CB            VA(I,J,K)=VA(I,J,K)*MSFD(I,J)                                      23DEC04.369
> CB            W3DTEN(I,J,K)=0.                                                   23DEC04.370
> CB          ENDDO                                                                23DEC04.371
> CB        ENDDO                                                                  23DEC04.372
> CB END                                                                           23DEC04.373
240,241c307,314
<       CALL DCPL3DWND(IBOUDY(INEST),U3D,V3D,UCD,VCD,RPDOTA,IL,JL,KL,ILX,          SOLVE.186
<      +     JLX)                                                                  SOLVE.187
---
> CB New optimized optimized routine DCLP3DWND is called                           23DEC04.374
> CB      CALL DCPL3DWND(IBOUDY(INEST),U3D,V3D,UCD,VCD,RPDOTA,IL,JL,KL,ILX,        23DEC04.375
> CB     +     JLX)                                                                23DEC04.376
> C --- Save coupled U and V in ucd AND VCD.                                       23DEC04.377
> C     UA and VA thereafter are coupled U and V with map scale factor.            23DEC04.378
>       CALL DCPL3DWND(IBOUDY(INEST),U3D,V3D,UCD,VCD,UA,VA,RPDOTA,MSFD,            23DEC04.379
>      &              IL,JL,KL,ILX,JLX)                                            23DEC04.380
> CB END                                                                           23DEC04.381
305,306d377
<             TBP(I,J,K)=TB(I,J,K)*RPSB(I,J)-T0(I,J,K)                             SOLVE.251
< C                                                                                SOLVE.252
319a391,392
> Ccsd$ parallel do private(i,j,k,rho0s,dummy,div)                                 23DEC04.382
> Ccsd$& schedule(static,1)                                                        23DEC04.383
361a435
> Ccsd$ end parallel do                                                            23DEC04.384
364,368c438,450
< C                                                                                SOLVE.310
<       CALL HADV(KZZ,U3DTEN,UA,VA,U3D,MSFD,DX16,3,INEST)                          SOLVE.311
<       CALL HADV(KZZ,V3DTEN,UA,VA,V3D,MSFD,DX16,3,INEST)                          SOLVE.312
<       CALL HADV(KZZ,PP3DTEN,UA,VA,PP3D,MSFX,DX4,1,INEST)                         SOLVE.313
<       CALL HADV(KZZ+1,W3DTEN,UA,VA,W3D,MSFX,DX4,4,INEST)                         SOLVE.314
---
> C                                                                                23DEC04.385
> CB Optimized code for calculation of U and V terms                               23DEC04.386
> CB replaces some calles to HSDV and VADV                                         23DEC04.387
> C       Flux-divergence terms, divergence terms, curvature terms,                23DEC04.388
> C       and Coriolis  terms for U, V:                                            23DEC04.389
> C                                                                                23DEC04.390
>       CALL ADVDUV( U3DTEN, V3DTEN, UA, VA, QDOT, DX16, REARTH,                   23DEC04.391
>      &             WA, DIVX, U3D, V3D, UCD, VCD, INEST )                         23DEC04.392
> C                                                                                23DEC04.393
> CB      CALL HADV(KZZ,U3DTEN,UA,VA,U3D,MSFD,DX16,3,INEST,'U')                    23DEC04.394
> CB      CALL HADV(KZZ,V3DTEN,UA,VA,V3D,MSFD,DX16,3,INEST,'V')                    23DEC04.395
>       CALL HADV(KZZ,PP3DTEN,UA,VA,PP3D,MSFX,DX4,1,INEST,'X')                     23DEC04.396
>       CALL HADV(KZZ+1,W3DTEN,UA,VA,W3D,MSFX,DX4,4,INEST,'W')                     23DEC04.397
372,373c454,456
<       CALL VADV(KZZ,U3DTEN,UCD,QDOT,PSA,4,INEST)                                 SOLVE.318
<       CALL VADV(KZZ,V3DTEN,VCD,QDOT,PSA,4,INEST)                                 SOLVE.319
---
> CB      CALL VADV(KZZ,U3DTEN,UCD,QDOT,PSA,4,INEST)                               23DEC04.398
> CB      CALL VADV(KZZ,V3DTEN,VCD,QDOT,PSA,4,INEST)                               23DEC04.399
> CB END                                                                           23DEC04.400
378a462,482
> C_FLIC_RUNPAD(0)                                                                 23DEC04.401
> CB Moved up here - no effect - only because CRSXK is now needed sooner           23DEC04.402
> C                                                                                23DEC04.403
> C     INITIALIZE DIFFUSION COEFFS                                                23DEC04.404
> C                                                                                23DEC04.405
> cmic$ do all autoscope                                                           23DEC04.406
> cmic$2 private(i,j,k)                                                            23DEC04.407
> c$doacross                                                                       23DEC04.408
> c$& local(i,j,k)                                                                 23DEC04.409
> c$omp parallel do default(shared)                                                23DEC04.410
> c$omp&private(i,j,k)                                                             23DEC04.411
>       DO J=1,MJX                                                                 23DEC04.412
>         DO K=1,MKX                                                               23DEC04.413
>           DO I=1,MIX                                                             23DEC04.414
>             CRSXK(I,J,K)=0.                                                      23DEC04.415
>             DOTXK(I,J,K)=0.                                                      23DEC04.416
>           ENDDO                                                                  23DEC04.417
>         ENDDO                                                                    23DEC04.418
>       ENDDO                                                                      23DEC04.419
> C                                                                                23DEC04.420
> CB END                                                                           23DEC04.421
397,398c501,506
<         CALL HADV(KZZ,THTEN,UA,VA,TH,MSFX,DX4,1,INEST)                           SOLVE.343
<         CALL VADV(KZZ,THTEN,THA,QDOT,PSA,6,INEST)                                05DEC01.470
---
>         CALL HADV(KZZ,THTEN,UA,VA,TH,MSFX,DX4,tadv,INEST,'T')                    23DEC04.422
>         if (ITADVM(INEST).GE.1) then                                             23DEC04.423
>           CALL VADV2(KZZ,THTEN,CRSXK,TH,THA,QDOT,PSA,6,INEST,'T')                23DEC04.424
>         else                                                                     23DEC04.425
>           CALL VADV(KZZ,THTEN,THA,QDOT,PSA,6,INEST)                              23DEC04.426
>        endif                                                                     23DEC04.427
400,401c508,513
<         CALL HADV(KZZ,T3DTEN,UA,VA,T3D,MSFX,DX4,1,INEST)                         SOLVE.346
<         CALL VADV(KZZ,T3DTEN,TA,QDOT,PSA,INDH,INEST)                             SOLVE.347
---
>         CALL HADV(KZZ,T3DTEN,UA,VA,T3D,MSFX,DX4,tadv,INEST,'T')                  23DEC04.428
>         if (ITADVM(INEST).GE.1) then                                             23DEC04.429
>           CALL VADV2(KZZ,T3DTEN,CRSXK,T3D,TA,QDOT,PSA,6,INEST,'T')               23DEC04.430
>         else                                                                     23DEC04.431
>           CALL VADV(KZZ,T3DTEN,TA,QDOT,PSA,INDH,INEST)                           23DEC04.432
>         endif                                                                    23DEC04.433
408c520
<         CALL HADV(KZZ,QV3DTEN,UA,VA,QV3D,MSFX,DX4,1,INEST)                       SOLVE.354
---
>         CALL HADV(KZZ,QV3DTEN,UA,VA,QV3D,MSFX,DX4,qadv,INEST,'Q')                23DEC04.434
413c525,530
<           CALL VADV(KZZ,QV3DTEN,QVA,QDOT,PSA,INDQ,INEST)                         SOLVE.359
---
>           if (IQADVM(INEST).GE.1) then                                           23DEC04.435
>             CALL VADV2(KZZ,QV3DTEN,CRSXK,QV3D,QVA,QDOT,PSA,INDQ,                 23DEC04.436
>      &                 INEST,'Q')                                                23DEC04.437
>           else                                                                   23DEC04.438
>             CALL VADV(KZZ,QV3DTEN,QVA,QDOT,PSA,INDQ,INEST)                       23DEC04.439
>           endif                                                                  23DEC04.440
419,422c536,544
<           CALL HADV(KZZ,QC3DTEN,UA,VA,QC3D,MSFX,DX4,1,INEST)                     SOLVE.365
<           CALL HADV(KZZ,QR3DTEN,UA,VA,QR3D,MSFX,DX4,1,INEST)                     SOLVE.366
<           CALL VADV(KZZ,QC3DTEN,QCA,QDOT,PSA,INDQ,INEST)                         SOLVE.367
<           CALL VADV(KZZ,QR3DTEN,QRA,QDOT,PSA,INDQ,INEST)                         SOLVE.368
---
>           CALL HADV(KZZ,QC3DTEN,UA,VA,QC3D,MSFX,DX4,cwadv,INEST,'C')             23DEC04.441
>           CALL HADV(KZZ,QR3DTEN,UA,VA,QR3D,MSFX,DX4,cwadv,INEST,'P')             23DEC04.442
>           if (IQADVM(INEST).GE.1) then                                           23DEC04.443
>             CALL VADV2(KZZ,QC3DTEN,CRSXK,QC3D,QCA,QDOT,PSA,6,INEST,'C')          23DEC04.444
>             CALL VADV2(KZZ,QR3DTEN,CRSXK,QR3D,QRA,QDOT,PSA,6,INEST,'P')          23DEC04.445
>           else                                                                   23DEC04.446
>             CALL VADV(KZZ,QC3DTEN,QCA,QDOT,PSA,INDQ,INEST)                       23DEC04.447
>             CALL VADV(KZZ,QR3DTEN,QRA,QDOT,PSA,INDQ,INEST)                       23DEC04.448
>           endif                                                                  23DEC04.449
424,427c546,556
<             CALL HADV(KZZ,QI3DTEN,UA,VA,QI3D,MSFX,DX4,1,INEST)                   SOLVE.370
<             CALL HADV(KZZ,QNI3DTEN,UA,VA,QNI3D,MSFX,DX4,1,INEST)                 SOLVE.371
<             CALL VADV(KZZ,QI3DTEN,QIA,QDOT,PSA,INDQ,INEST)                       SOLVE.372
<             CALL VADV(KZZ,QNI3DTEN,QNIA,QDOT,PSA,INDQ,INEST)                     SOLVE.373
---
>             CALL HADV(KZZ,QI3DTEN,UA,VA,QI3D,MSFX,DX4,cwadv,INEST,'I')           23DEC04.450
>             CALL HADV(KZZ,QNI3DTEN,UA,VA,QNI3D,MSFX,DX4,cwadv,INEST,'P')         23DEC04.451
>             if (IQADVM(INEST).GE.1) then                                         23DEC04.452
>               CALL VADV2(KZZ,QI3DTEN,CRSXK,QI3D,QIA,QDOT,PSA,6,INEST,            23DEC04.453
>      &                   'I')                                                    23DEC04.454
>               CALL VADV2(KZZ,QNI3DTEN,CRSXK,QNI3D,QNIA,QDOT,PSA,6,INEST,         23DEC04.455
>      &                   'P')                                                    23DEC04.456
>             else                                                                 23DEC04.457
>               CALL VADV(KZZ,QI3DTEN,QIA,QDOT,PSA,INDQ,INEST)                     23DEC04.458
>               CALL VADV(KZZ,QNI3DTEN,QNIA,QDOT,PSA,INDQ,INEST)                   23DEC04.459
>             endif                                                                23DEC04.460
429,432c558,569
<               CALL HADV(KZZ,QG3DTEN,UA,VA,QG3D,MSFX,DX4,1,INEST)                 SOLVE.375
<               CALL HADV(KZZ,QNC3DTEN,UA,VA,QNC3D,MSFX,DX4,1,INEST)               SOLVE.376
<               CALL VADV(KZZ,QG3DTEN,QGA,QDOT,PSA,INDQ,INEST)                     SOLVE.377
<               CALL VADV(KZZ,QNC3DTEN,QNCA,QDOT,PSA,INDQ,INEST)                   SOLVE.378
---
>               CALL HADV(KZZ,QG3DTEN,UA,VA,QG3D,MSFX,DX4,cwadv,INEST,'P')         23DEC04.461
>               CALL HADV(KZZ,QNC3DTEN,UA,VA,QNC3D,MSFX,DX4,cwadv,INEST,           23DEC04.462
>      &                  'N')                                                     23DEC04.463
>               if (IQADVM(INEST).GE.1) then                                       23DEC04.464
>                 CALL VADV2(KZZ,QG3DTEN,CRSXK,QG3D,QGA,QDOT,PSA,6,INEST,          23DEC04.465
>      &                     'P')                                                  23DEC04.466
>                 CALL VADV2(KZZ,QNC3DTEN,CRSXK,QNC3D,QNCA,QDOT,PSA,6,             23DEC04.467
>      &                     INEST,'N')                                            23DEC04.468
>               else                                                               23DEC04.469
>                 CALL VADV(KZZ,QG3DTEN,QGA,QDOT,PSA,INDQ,INEST)                   23DEC04.470
>                 CALL VADV(KZZ,QNC3DTEN,QNCA,QDOT,PSA,INDQ,INEST)                 23DEC04.471
>               endif                                                              23DEC04.472
453a591,592
> Ccsd$ parallel do private(i,j,k,scr1,tv,cpm,pr,uaq,vaq,rofac)                    23DEC04.473
> Ccsd$& schedule(static,1)                                                        23DEC04.474
474a614,615
>                                                                                  23DEC04.475
>           if (ITADVM(INEST).EQ.0) THEN                                           23DEC04.476
481a623,631
>           else                                                                   23DEC04.477
>           DO K=1,KL                                                              23DEC04.478
>             DO I=IBNES,IENES-1                                                   23DEC04.479
>               T3DTEN(I,J,K)=T3DTEN(I,J,K)+TA(I,J,K)*THTEN(I,J,K)/                23DEC04.480
>      +                      THA(I,J,K)                                           23DEC04.481
>             ENDDO                                                                23DEC04.482
>           ENDDO                                                                  23DEC04.483
>           endif                                                                  23DEC04.484
>                                                                                  23DEC04.485
563a714
>         if (IQADVM(INEST).EQ.0) then                                             23DEC04.486
597a749
>        endif                                                                     23DEC04.487
599,646c751,802
< C                                                                                SOLVE.545
< C *** COMPUTE CORIOLIS AND CURVATURE TERMS:                                      SOLVE.546
< C                                                                                SOLVE.547
< cmic$ do all autoscope                                                           SOLVE.548
< cmic$1 shared (IBNES,IENES,JBNES,JENES,KL,f,u3d,v3d,                             SOLVE.549
< cmic$1         PSA,WA,QDOT,EF,COSROT,SINROT)                                     SOLVE.550
< cmic$2 private (I,J,K,WADOT,DIVD,AMFAC)                                          SOLVE.551
< c$doacross                                                                       SOLVE.552
< c$& local(i,j,k,divd,wadot,amfac)                                                SOLVE.553
< c$omp parallel do default(shared)                                                SOLVE.554
< c$omp&private(i,j,k,divd,wadot,amfac)                                            SOLVE.555
<       DO J=JBNES,JENES                                                           SOLVE.556
<         DO K=1,KLP1                                                              SOLVE.557
<           DO I=IBNES,IENES                                                       SOLVE.558
<             WADOT(I,K)=WA(I-1,J-1,K)+WA(I,J-1,K)+WA(I-1,J,K)+WA(I,J,K)           SOLVE.559
<           ENDDO                                                                  SOLVE.560
<         ENDDO                                                                    SOLVE.561
< C                                                                                SOLVE.562
< C *** 3D CORIOLIS TERM: HORIZONTAL COMPONENT                                     SOLVE.563
< C                                                                                SOLVE.564
<         DO K=1,KL                                                                SOLVE.565
<           DO I=IBNES,IENES                                                       SOLVE.566
< C     DOT-POINT AVERAGED DIVERGENCE                                              SOLVE.567
<             DIVD=0.25*(DIVX(I,J,K)+DIVX(I-1,J,K)+DIVX(I,J-1,K)+                  SOLVE.568
<      +           DIVX(I-1,J-1,K))                                                SOLVE.569
<             U3DTEN(I,J,K)=U3DTEN(I,J,K)+U3D(I,J,K)*DIVD+F(I,J)*                  SOLVE.570
<      +                    VCD(I,J,K)-EF(I,J)*COSROT(I,J)*0.125*(                 SOLVE.571
<      +                    WADOT(I,K)+WADOT(I,K+1))                               SOLVE.572
<             V3DTEN(I,J,K)=V3DTEN(I,J,K)+V3D(I,J,K)*DIVD-F(I,J)*                  SOLVE.573
<      +                    UCD(I,J,K)+EF(I,J)*SINROT(I,J)*0.125*(                 SOLVE.574
<      +                    WADOT(I,K)+WADOT(I,K+1))                               SOLVE.575
< C                                                                                SOLVE.576
< C *** CURVATURE TERMS - THESE ALLOW FOR X AND Y AXES NOT BEING STRAIGHT          SOLVE.577
< C     LINES (GREAT CIRCLES) DUE TO MAP-SCALE FACTOR GRADIENT                     SOLVE.578
< C                                                                                SOLVE.579
<             U3DTEN(I,J,K)=U3DTEN(I,J,K)+V3D(I,J,K)*(UCD(I,J,K)*DMDY(I,J)         SOLVE.580
<      +                    -VCD(I,J,K)*DMDX(I,J))                                 SOLVE.581
<             V3DTEN(I,J,K)=V3DTEN(I,J,K)-U3D(I,J,K)*(UCD(I,J,K)*DMDY(I,J)         SOLVE.582
<      +                    -VCD(I,J,K)*DMDX(I,J))                                 SOLVE.583
< C                                                                                SOLVE.584
< C *** ANGULAR MOMENTUM CONSERVATION (OR VERTICAL CURVATURE) TERM                 SOLVE.585
< C                                                                                SOLVE.586
<             AMFAC=0.125*(WADOT(I,K)+WADOT(I,K+1))*RPDOTA(I,J)*REARTH             SOLVE.587
<             U3DTEN(I,J,K)=U3DTEN(I,J,K)-UCD(I,J,K)*AMFAC                         SOLVE.588
<             V3DTEN(I,J,K)=V3DTEN(I,J,K)-VCD(I,J,K)*AMFAC                         SOLVE.589
<           ENDDO                                                                  SOLVE.590
<         ENDDO                                                                    SOLVE.591
<       ENDDO                                                                      SOLVE.592
---
> Ccsd$ end parallel do                                                            23DEC04.488
> CB Computation of coriolis and curvature terms moved into routine ADVDVU         23DEC04.489
> CB This change was done purely for optimization                                  23DEC04.490
> CBC                                                                              23DEC04.491
> CBC *** COMPUTE CORIOLIS AND CURVATURE TERMS:                                    23DEC04.492
> CBC                                                                              23DEC04.493
> CBcmic$ do all autoscope                                                         23DEC04.494
> CBcmic$1 shared (IBNES,IENES,JBNES,JENES,KL,f,u3d,v3d,                           23DEC04.495
> CBcmic$1         PSA,WA,QDOT,EF,COSROT,SINROT)                                   23DEC04.496
> CBcmic$2 private (I,J,K,WADOT,DIVD,AMFAC)                                        23DEC04.497
> CBc$doacross                                                                     23DEC04.498
> CBc$& local(i,j,k,divd,wadot,amfac)                                              23DEC04.499
> CBc$omp parallel do default(shared)                                              23DEC04.500
> CBc$omp&private(i,j,k,divd,wadot,amfac)                                          23DEC04.501
> CB      DO J=JBNES,JENES                                                         23DEC04.502
> CB        DO K=1,KLP1                                                            23DEC04.503
> CB          DO I=IBNES,IENES                                                     23DEC04.504
> CB            WADOT(I,K)=WA(I-1,J-1,K)+WA(I,J-1,K)+WA(I-1,J,K)+WA(I,J,K)         23DEC04.505
> CB          ENDDO                                                                23DEC04.506
> CB        ENDDO                                                                  23DEC04.507
> CBC                                                                              23DEC04.508
> CBC *** 3D CORIOLIS TERM: HORIZONTAL COMPONENT                                   23DEC04.509
> CBC                                                                              23DEC04.510
> CB        DO K=1,KL                                                              23DEC04.511
> CB          DO I=IBNES,IENES                                                     23DEC04.512
> CBC     DOT-POINT AVERAGED DIVERGENCE                                            23DEC04.513
> CB            DIVD=0.25*(DIVX(I,J,K)+DIVX(I-1,J,K)+DIVX(I,J-1,K)+                23DEC04.514
> CB     +           DIVX(I-1,J-1,K))                                              23DEC04.515
> CB            U3DTEN(I,J,K)=U3DTEN(I,J,K)+U3D(I,J,K)*DIVD+F(I,J)*                23DEC04.516
> CB     +                    VCD(I,J,K)-EF(I,J)*COSROT(I,J)*0.125*(               23DEC04.517
> CB     +                    WADOT(I,K)+WADOT(I,K+1))                             23DEC04.518
> CB            V3DTEN(I,J,K)=V3DTEN(I,J,K)+V3D(I,J,K)*DIVD-F(I,J)*                23DEC04.519
> CB     +                    UCD(I,J,K)+EF(I,J)*SINROT(I,J)*0.125*(               23DEC04.520
> CB     +                    WADOT(I,K)+WADOT(I,K+1))                             23DEC04.521
> CBC                                                                              23DEC04.522
> CBC *** CURVATURE TERMS - THESE ALLOW FOR X AND Y AXES NOT BEING STRAIGHT        23DEC04.523
> CBC     LINES (GREAT CIRCLES) DUE TO MAP-SCALE FACTOR GRADIENT                   23DEC04.524
> CBC                                                                              23DEC04.525
> CB            U3DTEN(I,J,K)=U3DTEN(I,J,K)+V3D(I,J,K)*(UCD(I,J,K)*DMDY(I,J)       23DEC04.526
> CB     +                    -VCD(I,J,K)*DMDX(I,J))                               23DEC04.527
> CB            V3DTEN(I,J,K)=V3DTEN(I,J,K)-U3D(I,J,K)*(UCD(I,J,K)*DMDY(I,J)       23DEC04.528
> CB     +                    -VCD(I,J,K)*DMDX(I,J))                               23DEC04.529
> CBC                                                                              23DEC04.530
> CBC *** ANGULAR MOMENTUM CONSERVATION (OR VERTICAL CURVATURE) TERM               23DEC04.531
> CBC                                                                              23DEC04.532
> CB            AMFAC=0.125*(WADOT(I,K)+WADOT(I,K+1))*RPDOTA(I,J)*REARTH           23DEC04.533
> CB            U3DTEN(I,J,K)=U3DTEN(I,J,K)-UCD(I,J,K)*AMFAC                       23DEC04.534
> CB            V3DTEN(I,J,K)=V3DTEN(I,J,K)-VCD(I,J,K)*AMFAC                       23DEC04.535
> CB          ENDDO                                                                23DEC04.536
> CB        ENDDO                                                                  23DEC04.537
> CB      ENDDO                                                                    23DEC04.538
> CB END                                                                           23DEC04.539
670,689c826,1049
< C                                                                                24SEP99.358
< C     INITIALIZE DIFFUSION COEFFS                                                24SEP99.359
< C                                                                                24SEP99.360
< cmic$ do all autoscope                                                           25JAN00.277
< cmic$2 private(i,j,k)                                                            25JAN00.278
< c$doacross                                                                       25JAN00.279
< c$& local(i,j,k)                                                                 25JAN00.280
< c$omp parallel do default(shared)                                                25JAN00.281
< c$omp&private(i,j,k)                                                             25JAN00.282
<       DO J=1,MJX                                                                 25JAN00.283
<         DO K=1,MKX                                                               25JAN00.284
<           DO I=1,MIX                                                             24SEP99.363
<             CRSXK(I,J,K)=0.                                                      24SEP99.364
<             DOTXK(I,J,K)=0.                                                      24SEP99.365
<           ENDDO                                                                  24SEP99.366
<         ENDDO                                                                    24SEP99.367
<       ENDDO                                                                      24SEP99.368
< C                                                                                24SEP99.369
<       CALL COEF_DIFFU(CRSXK,DOTXK,U3D,V3D,XKHZ,XKHMAX,C200,ILX,JLX,KL)           24SEP99.370
< C                                                                                24SEP99.371
---
>       CALL COEF_DIFFU(CRSXK,DOTXK,U3D,V3D,XKHZ,XKHMAX,C200,ILX,JLX,KL,           23DEC04.540
>      &                INEST)                                                     23DEC04.541
> c                                                                                23DEC04.542
> c  compute T' / theta for temperature diffusion                                  23DEC04.543
> c                                                                                23DEC04.544
> C_FLIC_RUNPAD(2)                                                                 23DEC04.545
>        if (ITPDIF.eq.1) then                                                     23DEC04.546
> cmic$ do all autoscope                                                           23DEC04.547
> c$doacross                                                                       23DEC04.548
> c$& local(i,j,k)                                                                 23DEC04.549
> c$omp parallel do default(shared)                                                23DEC04.550
> c$omp&private(i,j,k)                                                             23DEC04.551
>       DO J=1,JLX                                                                 23DEC04.552
>         DO K=1,KL                                                                23DEC04.553
>           DO I=1,ILX                                                             23DEC04.554
>             TBP(I,J,K)=T3D(I,J,K)-T0(I,J,K)                                      23DEC04.555
>           ENDDO                                                                  23DEC04.556
>         ENDDO                                                                    23DEC04.557
>       ENDDO                                                                      23DEC04.558
>       else if (ITPDIF.ge.2) then                                                 23DEC04.559
> cmic$ do all autoscope                                                           23DEC04.560
> c$doacross                                                                       23DEC04.561
> c$& local(i,j,k)                                                                 23DEC04.562
> c$omp parallel do default(shared)                                                23DEC04.563
> c$omp&private(i,j,k)                                                             23DEC04.564
>       DO J=1,JLX                                                                 23DEC04.565
>         DO K=1,KL                                                                23DEC04.566
>           DO I=1,ILX                                                             23DEC04.567
>             TBP(I,J,K)=T3D(I,J,K)*(1.E5/PR1(I,J,K))**ROVCP                       23DEC04.568
>           ENDDO                                                                  23DEC04.569
>         ENDDO                                                                    23DEC04.570
>       ENDDO                                                                      23DEC04.571
>       if (tdkorr.eq.1) then                                                      23DEC04.572
> c$omp parallel do default(shared)                                                23DEC04.573
> c$omp&private(i,j)                                                               23DEC04.574
>       DO J=1,JLX                                                                 23DEC04.575
>       DO I=1,ILX                                                                 23DEC04.576
>       THGB(I,J) = TGB(I,J)*(1.E5/(PS0(i,j)+PT+PP3D(I,J,KL)))**ROVCP              23DEC04.577
>       enddo                                                                      23DEC04.578
>       enddo                                                                      23DEC04.579
>       else                                                                       23DEC04.580
> c$omp parallel do default(shared)                                                23DEC04.581
> c$omp&private(i,j)                                                               23DEC04.582
>       DO J=1,JLX                                                                 23DEC04.583
>       DO I=1,ILX                                                                 23DEC04.584
>       THGB(I,J) = TBP(I,J,KL)                                                    23DEC04.585
>       enddo                                                                      23DEC04.586
>       enddo                                                                      23DEC04.587
>       endif                                                                      23DEC04.588
>       endif                                                                      23DEC04.589
> C                                                                                23DEC04.590
> C_FLIC_RUNPAD(0)                                                                 23DEC04.591
>                                                                                  23DEC04.592
> c  Compute interpolation coefficients for z-diffusion                            23DEC04.593
>                                                                                  23DEC04.594
>        if (ITPDIF.ge.2) then                                                     23DEC04.595
> C_FLIC_RUNPAD(2)                                                                 23DEC04.596
>                                                                                  23DEC04.597
>       if (diffpar(inest)) then                                                   23DEC04.598
>         print*,'Interpolation coefficients for z-diffusion are computed'         23DEC04.599
> c                                                                                23DEC04.600
>        call diffintp(A,PSB,ptop,IBNES,IENES-1,JBNES,JENES-1,KL,inest,            23DEC04.601
>      f T0,dx,rkip1,rkip2,rkim1,rkim2,rkjp1,rkjp2,rkjm1,rkjm2,finv,fjnv,          23DEC04.602
>      f kmip,kmjp,kmim,kmjm,kmv,rmn,t0ij,t0ij1,t0i1j,t0i1j1,t0ijmn,               23DEC04.603
>      f zdiffst)                                                                  23DEC04.604
>         diffpar(inest) = .false.                                                 23DEC04.605
>                                                                                  23DEC04.606
>         print*,'INEST= ',inest,' kmv= ',kmv(inest),'                             23DEC04.607
>      f  zdiffst= ',zdiffst(inest),a(zdiffst(inest))                              23DEC04.608
>       endif                                                                      23DEC04.609
>                                                                                  23DEC04.610
>         kmvl = kmv(inest)                                                        23DEC04.611
>                                                                                  23DEC04.612
> c  Wind speed at lowermost model level. Weighting depends on height difference   23DEC04.613
>                                                                                  23DEC04.614
> c$omp parallel do default(shared)                                                23DEC04.615
> c$omp&private(i,j)                                                               23DEC04.616
>         do j=3,jlxm-1                                                            23DEC04.617
>         do i=3,ilxm-1                                                            23DEC04.618
>                                                                                  23DEC04.619
>       cbt1 =     u3d(i,j,kl)*t0ij(i,j,inest)                                     23DEC04.620
>       cbt2 =     u3d(i+1,j,kl)*t0i1j(i,j,inest)                                  23DEC04.621
>       cbt3 =     u3d(i,j+1,kl)*t0ij1(i,j,inest)                                  23DEC04.622
>       cbt4 =     u3d(i+1,j+1,kl)*t0i1j1(i,j,inest)                               23DEC04.623
>       cbt5 =     v3d(i,j,kl)*t0ij(i,j,inest)                                     23DEC04.624
>       cbt6 =     v3d(i+1,j,kl)*t0i1j(i,j,inest)                                  23DEC04.625
>       cbt7 =     v3d(i,j+1,kl)*t0ij1(i,j,inest)                                  23DEC04.626
>       cbt8 =     v3d(i+1,j+1,kl)*t0i1j1(i,j,inest)                               23DEC04.627
>        absv(i,j) =                                                               23DEC04.628
>      &     sqrt((t0ijmn(i,j,inest)*                                              23DEC04.629
>      &     (cbt1+cbt2+cbt3+cbt4))**2+                                            23DEC04.630
>      &     (t0ijmn(i,j,inest)*                                                   23DEC04.631
>      &     (cbt5+cbt6+cbt7+cbt8))**2)                                            23DEC04.632
>                                                                                  23DEC04.633
> c  Reduction of diffusion coefficients near the ground depends on wind speed; n  23DEC04.634
> c                                                                                23DEC04.635
> c  Under weak-wind conditions, the diffusion coefficients are strongly reduced   23DEC04.636
> c  for computing diffusion are st significantly different heights, which essent  23DEC04.637
> c  is restricted to the direction along a valley. In the presence of strong sur  23DEC04.638
> c  that quasi-horizontal mixing along the side slopes of a valley takes place.   23DEC04.639
> c  to take place between surface wind speeds of 4 and 12 m/s.                    23DEC04.640
> c                                                                                23DEC04.641
>       lam(i,j) = min(1.,max(0.,0.125*(absv(i,j)-4.0)))                           23DEC04.642
>                                                                                  23DEC04.643
> c Reduction factor for orography-adjusted sigma-diffusion                        23DEC04.644
>                                                                                  23DEC04.645
>       fin(i,j) = exp(log(finv(i,j,inest))*(1-lam(i,j)))                          23DEC04.646
>       fjn(i,j) = exp(log(fjnv(i,j,inest))*(1-lam(i,j)))                          23DEC04.647
>                                                                                  23DEC04.648
>       enddo                                                                      23DEC04.649
>       enddo                                                                      23DEC04.650
>                                                                                  23DEC04.651
> c  Further coefficients                                                          23DEC04.652
>                                                                                  23DEC04.653
>         if (inest.ne.oldnest) then                                               23DEC04.654
>                                                                                  23DEC04.655
>         oldnest = inest                                                          23DEC04.656
>         in = inest                                                               23DEC04.657
>                                                                                  23DEC04.658
> cmic$ do all autoscope                                                           23DEC04.659
> c$doacross                                                                       23DEC04.660
> c$& local(i,j)                                                                   23DEC04.661
> c$omp parallel do default(shared)                                                23DEC04.662
> c$omp&private(i,j)                                                               23DEC04.663
>           do  j=1,mjx                                                            23DEC04.664
>             do  i=1,mix                                                          23DEC04.665
>               kmi(i,j) = min(kmim(i,j,in),kmip(i,j,in))                          23DEC04.666
>               kmj(i,j) = min(kmjm(i,j,in),kmjp(i,j,in))                          23DEC04.667
>             enddo                                                                23DEC04.668
>           enddo                                                                  23DEC04.669
>                                                                                  23DEC04.670
> cmic$ do all autoscope                                                           23DEC04.671
> c$doacross                                                                       23DEC04.672
> c$& local(i,j)                                                                   23DEC04.673
> c$omp parallel do default(shared)                                                23DEC04.674
> c$omp&private(i,j)                                                               23DEC04.675
>         do j=3,jlxm-1                                                            23DEC04.676
>         do i=3,ilxm-1                                                            23DEC04.677
>                                                                                  23DEC04.678
> c  Derivatives for temperature gradient correction                               23DEC04.679
>                                                                                  23DEC04.680
>       fjt04(i,j) = t0(I,J+2,kl)+t0(I,J-2,kl)-4*(t0(I,J+1,kl)+                    23DEC04.681
>      f  t0(I,J-1,kl))+6*t0(I,J,kl)                                               23DEC04.682
>       fit04(i,j) = t0(I+2,J,kl)+t0(I-2,J,kl)-4*(t0(I+1,J,kl)+                    23DEC04.683
>      f  t0(I-1,J,kl))+6*t0(I,J,kl)                                               23DEC04.684
>                                                                                  23DEC04.685
> c  Coefficients for subsidiary second-order diffusion                            23DEC04.686
>                                                                                  23DEC04.687
>       fit0o(i,j) = t0(I,J,kl) - t0(I+1,J,kl)                                     23DEC04.688
>       fit0u(i,j) = t0(I,J,kl) - t0(I-1,J,kl)                                     23DEC04.689
>       fjt0o(i,j) = t0(I,J,kl) - t0(I,J+1,kl)                                     23DEC04.690
>       fjt0u(i,j) = t0(I,J,kl) - t0(I,J-1,kl)                                     23DEC04.691
>                                                                                  23DEC04.692
>       fion(i,j) = rmz/(rmz+fit0o(i,j)**6)                                        23DEC04.693
>       fiun(i,j) = rmz/(rmz+fit0u(i,j)**6)                                        23DEC04.694
>       fjon(i,j) = rmz/(rmz+fjt0o(i,j)**6)                                        23DEC04.695
>       fjun(i,j) = rmz/(rmz+fjt0u(i,j)**6)                                        23DEC04.696
>                                                                                  23DEC04.697
>       fionf(i,j) = rmzf/(rmzf+fit0o(i,j)**6)                                     23DEC04.698
>       fiunf(i,j) = rmzf/(rmzf+fit0u(i,j)**6)                                     23DEC04.699
>       fjonf(i,j) = rmzf/(rmzf+fjt0o(i,j)**6)                                     23DEC04.700
>       fjunf(i,j) = rmzf/(rmzf+fjt0u(i,j)**6)                                     23DEC04.701
>                                                                                  23DEC04.702
>       enddo                                                                      23DEC04.703
>       enddo                                                                      23DEC04.704
>                                                                                  23DEC04.705
> cmic$ do all autoscope                                                           23DEC04.706
> c$doacross                                                                       23DEC04.707
> c$& local(i,j,k)                                                                 23DEC04.708
> c$omp parallel do default(shared)                                                23DEC04.709
> c$omp&private(i,j,k)                                                             23DEC04.710
>         do k=kmvl+1,kl                                                           23DEC04.711
>         do j=3,jlxm-1                                                            23DEC04.712
>         do i=3,ilxm-1                                                            23DEC04.713
>                                                                                  23DEC04.714
>         gezipwh(i,j,k) = (1-min(0.5,(k-kmvl)/(2.*(kmi(i,j)-kmvl+1))))*           23DEC04.715
>      f  min(1,max(0,kmip(i,j,in)+1-k))                                           23DEC04.716
>         gezimwh(i,j,k) = (1-min(0.5,(k-kmvl)/(2.*(kmi(i,j)-kmvl+1))))*           23DEC04.717
>      f  min(1,max(0,kmim(i,j,in)+1-k))                                           23DEC04.718
>         gezjpwh(i,j,k) = (1-min(0.5,(k-kmvl)/(2.*(kmj(i,j)-kmvl+1))))*           23DEC04.719
>      f  min(1,max(0,kmjp(i,j,in)+1-k))                                           23DEC04.720
>         gezjmwh(i,j,k) = (1-min(0.5,(k-kmvl)/(2.*(kmj(i,j)-kmvl+1))))*           23DEC04.721
>      f  min(1,max(0,kmjm(i,j,in)+1-k))                                           23DEC04.722
>                                                                                  23DEC04.723
>         enddo                                                                    23DEC04.724
>         enddo                                                                    23DEC04.725
>         enddo                                                                    23DEC04.726
>                                                                                  23DEC04.727
> cmic$ do all autoscope                                                           23DEC04.728
> c$doacross                                                                       23DEC04.729
> c$& local(i,j,k)                                                                 23DEC04.730
> c$omp parallel do default(shared)                                                23DEC04.731
> c$omp&private(i,j,k)                                                             23DEC04.732
>         do k=zdiffst(inest),kl                                                   23DEC04.733
>         do j=3,jlxm-1                                                            23DEC04.734
>         do i=3,ilxm-1                                                            23DEC04.735
>                                                                                  23DEC04.736
>         mrkjp2(i,j,k) = mod(rkjp2(i,j,k,in),1.)                                  23DEC04.737
>         irkjp2(i,j,k) = int(rkjp2(i,j,k,in))                                     23DEC04.738
>         mrkjm2(i,j,k) = mod(rkjm2(i,j,k,in),1.)                                  23DEC04.739
>         irkjm2(i,j,k) = int(rkjm2(i,j,k,in))                                     23DEC04.740
>         mrkjp1(i,j,k) = mod(rkjp1(i,j,k,in),1.)                                  23DEC04.741
>         irkjp1(i,j,k) = int(rkjp1(i,j,k,in))                                     23DEC04.742
>         mrkjm1(i,j,k) = mod(rkjm1(i,j,k,in),1.)                                  23DEC04.743
>         irkjm1(i,j,k) = int(rkjm1(i,j,k,in))                                     23DEC04.744
>         mrkip2(i,j,k) = mod(rkip2(i,j,k,in),1.)                                  23DEC04.745
>         irkip2(i,j,k) = int(rkip2(i,j,k,in))                                     23DEC04.746
>         mrkim2(i,j,k) = mod(rkim2(i,j,k,in),1.)                                  23DEC04.747
>         irkim2(i,j,k) = int(rkim2(i,j,k,in))                                     23DEC04.748
>         mrkip1(i,j,k) = mod(rkip1(i,j,k,in),1.)                                  23DEC04.749
>         irkip1(i,j,k) = int(rkip1(i,j,k,in))                                     23DEC04.750
>         mrkim1(i,j,k) = mod(rkim1(i,j,k,in),1.)                                  23DEC04.751
>         irkim1(i,j,k) = int(rkim1(i,j,k,in))                                     23DEC04.752
>                                                                                  23DEC04.753
>         enddo                                                                    23DEC04.754
>         enddo                                                                    23DEC04.755
>         enddo                                                                    23DEC04.756
>                                                                                  23DEC04.757
>         endif  ! Calculation of coefficients                                     23DEC04.758
>                                                                                  23DEC04.759
> C_FLIC_RUNPAD(0)                                                                 23DEC04.760
>       endif  ! z-diffusion                                                       23DEC04.761
>                                                                                  23DEC04.762
>                                                                                  23DEC04.763
707,909c1067,1070
< C                                                                                SOLVE.632
< C *** COMPUTE CUMULUS CONVECTIVE TENDENCIES:                                     SOLVE.633
< C                                                                                SOLVE.634
< #ifdef ICUPA2                                                                    SOLVE.635
< C                                                                                SOLVE.636
< C --- ICUPA=2: ANTHES KUO                                                        SOLVE.637
< C                                                                                SOLVE.638
<       IF(ICUPA(INEST).EQ.2)THEN                                                  SOLVE.639
< cmic$ do all autoscope                                                           SOLVE.640
< cmic$1 shared(IBNES,IENES,JBNES,JENES,INEST,                                     SOLVE.641
< cmic$1        T3DTEN,QV3DTEN,T3D,QV3D,PP3D,QDOT,RAINC,PSB)                       SOLVE.642
< cmic$2 private(J)                                                                SOLVE.643
< c$doacross                                                                       SOLVE.644
< c$& local(j)                                                                     SOLVE.645
< c$omp parallel do default(shared)                                                SOLVE.646
< c$omp&private(j)                                                                 SOLVE.647
<         DO J=JBNES,JENES-1                                                       SOLVE.648
< #ifdef MPP1                                                                      SOLVE.649
<           DUMJ(J)=J                                                              SOLVE.650
< #endif                                                                           SOLVE.651
<           CALL CUPARA2(J,INEST,IBNES,IENES-1,QV3DTEN,T3DTEN,T3D,QV3D,            SOLVE.652
<      +         PP3D,QDOT,RAINC,PSB)                                              SOLVE.653
<         ENDDO                                                                    SOLVE.654
<       ENDIF                                                                      SOLVE.655
< #endif                                                                           SOLVE.656
< #ifdef ICUPA3                                                                    07NOV00.1002
< C                                                                                SOLVE.658
< C --- ICUPA=3: GRELL                                                             SOLVE.659
< C                                                                                SOLVE.660
<       IF(ICUPA(INEST).EQ.3)THEN                                                  SOLVE.661
< #ifndef VECTOR                                                                   07NOV00.1003
< cmic$ do all autoscope                                                           SOLVE.678
< cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,u3d,v3d,t3d,qv3d,pp3d,               SOLVE.679
< cmic$1        t3dten,qv3dten,psb,rainc,ht)                                       SOLVE.680
< cmic$2 private(j,i,k,cldfra)                                                     24SEP99.372
< c$doacross                                                                       SOLVE.682
< c$& local(j,i,k,cldfra)                                                          24SEP99.373
< c$omp parallel do default(shared)                                                SOLVE.684
< c$omp&private(j,i,k,cldfra)                                                      24SEP99.374
<         DO J=JBNES,JENES-1                                                       SOLVE.686
< #ifdef MPP1                                                                      SOLVE.687
<           DUMJ(J)=J                                                              SOLVE.688
< #endif                                                                           SOLVE.689
<           DO K=1,KL                                                              24SEP99.375
<             DO I=IBNES,IENES-1                                                   24SEP99.376
<                CLDFRA(I,K) = 0.0                                                 24SEP99.377
<             END DO                                                               24SEP99.378
<           END DO                                                                 24SEP99.379
<           CALL CUPARA3(T3D,QV3D,PSB,T3DTEN,QV3DTEN,RAINC,CLDFRA,HT,              07NOV00.1004
<      +         U3D,V3D,PP3D,                                                     07NOV00.1005
<      +         RPSB,DT,DX,R,CP,G,TO,XLV,RV,A,PTOP,                               07NOV00.1006
<      +         INEST,J,IBNES,IENES-1)                                            07NOV00.1007
<           DO K=1,KL                                                              SOLVE.692
<             DO I=IBNES,IENES-1                                                   SOLVE.693
<               CLDFRA3D(I,J,K)=CLDFRA(I,K)                                        SOLVE.694
<             ENDDO                                                                SOLVE.695
<           ENDDO                                                                  SOLVE.696
<         ENDDO                                                                    SOLVE.697
< #else                                                                            07NOV00.1008
< #  include <call_vector_cupara3.incl>                                            07NOV00.1009
< #endif                                                                           07NOV00.1010
<       ENDIF                                                                      SOLVE.698
< #endif                                                                           SOLVE.699
< #ifdef ICUPA4                                                                    SOLVE.700
< C                                                                                SOLVE.701
< C --- ICUPA=4: ARAKAWA-SCHUBERT                                                  SOLVE.702
< C                                                                                SOLVE.703
<       IF(ICUPA(INEST).EQ.4)THEN                                                  SOLVE.704
< cmic$ do all autoscope                                                           SOLVE.705
< cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,                                     SOLVE.706
< cmic$1        t3dten,qv3dten,t3d,qv3d,psb,rainc,ht,u3d,v3d,pp3d)                 SOLVE.707
< cmic$2 private(j)                                                                SOLVE.708
< c$doacross                                                                       SOLVE.709
< c$& local(j)                                                                     SOLVE.710
< c$omp parallel do default(shared)                                                SOLVE.711
< c$omp&private(j)                                                                 SOLVE.712
<         DO J=JBNES,JENES-1                                                       SOLVE.713
< #ifdef MPP1                                                                      SOLVE.714
<           DUMJ(J)=J                                                              SOLVE.715
< #endif                                                                           SOLVE.716
<           CALL CUPARA4(T3D,QV3D,PSB,T3DTEN,QV3DTEN,RAINC,HT,U3D,V3D,             24SEP99.380
<      +         PP3D,INEST,J,IBNES,IENES-1)                                       24SEP99.381
<         ENDDO                                                                    SOLVE.719
<       ENDIF                                                                      SOLVE.720
< #endif                                                                           SOLVE.721
< #ifdef ICUPA5                                                                    SOLVE.722
< C                                                                                SOLVE.723
< C --- ICUPA=5: FRITSCH-CHAPPELL                                                  SOLVE.724
< C                                                                                SOLVE.725
<       IF(ICUPA(INEST).EQ.5)THEN                                                  SOLVE.726
< cmic$ do all autoscopE                                                           SOLVE.727
< cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,                                 SOLVE.728
< cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    SOLVE.729
< cmic$2 private(j,scr1)                                                           SOLVE.730
< c$doacross                                                                       SOLVE.731
< c$& local(j,scr1)                                                                SOLVE.732
< c$omp parallel do default(shared)                                                SOLVE.733
< c$omp&private(j,scr1)                                                            SOLVE.734
<         DO J=JBNES,JENES-1                                                       SOLVE.735
<           DO K=1,KL                                                              SOLVE.736
<             DO I=1,ILX                                                           SOLVE.737
<               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          SOLVE.738
<             ENDDO                                                                SOLVE.739
<           ENDDO                                                                  SOLVE.740
< C                                                                                SOLVE.741
<           IF(IMPHYS(INEST).GE.6)THEN                                             SOLVE.742
<             CALL CUPARA5(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             SOLVE.743
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               SOLVE.744
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    SOLVE.745
<           ELSE                                                                   SOLVE.746
<             CALL CUPARA5(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            SOLVE.747
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               SOLVE.748
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    SOLVE.749
<           ENDIF                                                                  SOLVE.750
<         ENDDO                                                                    SOLVE.751
<       ENDIF                                                                      SOLVE.752
< #endif                                                                           SOLVE.753
< #ifdef ICUPA6                                                                    SOLVE.754
< C                                                                                SOLVE.755
< C --- ICUPA=6: KAIN-FRITSCH                                                      SOLVE.756
< C                                                                                SOLVE.757
<       IF(ICUPA(INEST).EQ.6)THEN                                                  SOLVE.758
< cmic$ do all autoscope                                                           SOLVE.759
< cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,rho0,w3d,                        SOLVE.760
< cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    SOLVE.761
< cmic$2 private(j,scr1)                                                           SOLVE.762
< c$doacross                                                                       SOLVE.763
< c$& local(j,scr1)                                                                SOLVE.764
< c$omp parallel do default(shared)                                                SOLVE.765
< c$omp&private(j,scr1)                                                            SOLVE.766
<         DO J=JBNES,JENES-1                                                       SOLVE.767
<           DO K=1,KL                                                              SOLVE.768
<             DO I=1,ILX                                                           SOLVE.769
<               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          SOLVE.770
<             ENDDO                                                                SOLVE.771
<           ENDDO                                                                  SOLVE.772
< C                                                                                SOLVE.773
<           IF(IMPHYS(INEST).GE.6)THEN                                             SOLVE.774
<             CALL CUPARA6(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             SOLVE.775
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               SOLVE.776
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    SOLVE.777
<           ELSE                                                                   SOLVE.778
<             CALL CUPARA6(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            SOLVE.779
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               SOLVE.780
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    SOLVE.781
<           ENDIF                                                                  SOLVE.782
<         ENDDO                                                                    SOLVE.783
<       ENDIF                                                                      SOLVE.784
< #endif                                                                           SOLVE.785
< #ifdef ICUPA7                                                                    SOLVE.786
< C                                                                                SOLVE.787
< C --- ICUPA=7: BETTS-MILLER                                                      SOLVE.788
< C                                                                                SOLVE.789
<       IF(ICUPA(INEST).EQ.7)THEN                                                  SOLVE.790
< cmic$ do all autoscope                                                           SOLVE.791
< cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,                                     SOLVE.792
< cmic$&       t3dten,qv3dten,t3d,qv3d,pp3d,psb,rainc,xland,shc,t0)                SOLVE.793
< cmic$2 private(j)                                                                SOLVE.794
< c$doacross                                                                       SOLVE.795
< c$& local(j)                                                                     SOLVE.796
< c$omp parallel do default(shared)                                                SOLVE.797
< c$omp&private(j)                                                                 SOLVE.798
<         DO J=JBNES,JENES-1                                                       SOLVE.799
< #ifdef MPP1                                                                      SOLVE.800
<           DUMJ(J)=J                                                              SOLVE.801
< #endif                                                                           SOLVE.802
<           CALL CUPARA7(T3D,QV3D,PSB,PP3D,T3DTEN,QV3DTEN,RAINC,SHC,XLAND,         SOLVE.803
<      +         J,INEST,IBNES,IENES-1,T0)                                         SOLVE.804
<         ENDDO                                                                    SOLVE.805
<       ENDIF                                                                      SOLVE.806
< #endif                                                                           SOLVE.807
< #ifdef ICUPA8                                                                    05DEC01.472
< C                                                                                05DEC01.473
< C --- ICUPA=8: KAIN-FRITSCH 2 WITH SHALLOW CONVECTION                            05DEC01.474
< C                                                                                05DEC01.475
<       IF(ICUPA(INEST).EQ.8)THEN                                                  05DEC01.476
< cmic$ do all autoscope                                                           05DEC01.477
< cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,rho0,w3d,                        05DEC01.478
< cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    05DEC01.479
< cmic$2 private(j,scr1)                                                           05DEC01.480
< c$doacross                                                                       05DEC01.481
< c$& local(j,scr1)                                                                05DEC01.482
< c$omp parallel do default(shared)                                                05DEC01.483
< c$omp&private(j,scr1)                                                            05DEC01.484
<         DO J=JBNES,JENES-1                                                       05DEC01.485
<           DO K=1,KL                                                              05DEC01.486
<             DO I=1,ILX                                                           05DEC01.487
<               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          05DEC01.488
<             ENDDO                                                                05DEC01.489
<           ENDDO                                                                  05DEC01.490
< C                                                                                05DEC01.491
<           IF(IMPHYS(INEST).GE.6)THEN                                             05DEC01.492
<             CALL CUPARA8(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             05DEC01.493
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               05DEC01.494
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    05DEC01.495
<           ELSE                                                                   05DEC01.496
<             CALL CUPARA8(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            05DEC01.497
<      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               05DEC01.498
<      +           IMPHYS(INEST),IBNES,IENES-1)                                    05DEC01.499
<           ENDIF                                                                  05DEC01.500
<         ENDDO                                                                    05DEC01.501
<       ENDIF                                                                      05DEC01.502
< #endif                                                                           05DEC01.503
---
> C=======================================================================         23DEC04.764
> C CUMULUS SCHEMES MOVED AWAY FROM HERE.                                          23DEC04.765
> C They are now located BELOW the PBL schemes                                     23DEC04.766
> C=======================================================================         23DEC04.767
972a1134
> Ccsd$ parallel do private(j) schedule(static,1)                                  23DEC04.768
980c1142
<      +           QV3D,QC3D,QR3D,QI3D,QNI3D,QG3D,PP3D,INEST)                      07NOV00.1014
---
>      +           QV3D,QC3D,QR3D,QI3D,QNI3D,QG3D,PP3D,INEST,HT)                   23DEC04.769
981a1144
> Ccsd$ end parallel do                                                            23DEC04.770
1052c1215
< cmic$2 private(j,cldfra)                                                         07NOV00.1017
---
> cmic$2 private(i,j,k,cldfra)                                                     23DEC04.771
1054c1217
< c$& local(j,cldfra)                                                              07NOV00.1018
---
> c$& local(i,j,k,cldfra)                                                          23DEC04.772
1056c1219
< c$omp&private(j,cldfra)                                                          07NOV00.1019
---
> c$omp&private(i,j,k,cldfra)                                                      23DEC04.773
1069c1232
<      +           ,QR3D,QI3D,QNI3D,QG3D,PP3D,INEST)                               07NOV00.1023
---
>      +           ,QR3D,QI3D,QNI3D,QG3D,PP3D,INEST,HT)                            23DEC04.774
1217a1381
> Ccsd$ parallel do private(j) schedule(static,1)                                  23DEC04.775
1226a1391
>      +         HFXSI,QFXSI,TGSI,SEAICE,                                          23DEC04.776
1230c1395
<      +         XMOIST,                                                           07NOV00.1048
---
>      +         XMOIST,ISICE,                                                     23DEC04.777
1233a1399
> Ccsd$ end parallel do                                                            23DEC04.778
1298a1465
>                 TKEA(I,J,K) = TKEB(I,J,K)                                        23DEC04.779
1318c1485
<           CALL HADV(KZZ+1,TKETENDADV,UA,VA,TKEA,MSFX,DX4,4,INEST)                SOLVE.1106
---
>           CALL HADV(KZZ+1,TKETENDADV,UA,VA,TKEA,MSFX,DX4,4,INEST,'E')            23DEC04.780
1413a1581,1790
> C=======================================================================         23DEC04.781
> C cumulus schemes moved HERE                                                     23DEC04.782
> C                                                                                23DEC04.783
> C *** COMPUTE CUMULUS CONVECTIVE TENDENCIES:                                     23DEC04.784
> C                                                                                23DEC04.785
> #ifdef ICUPA2                                                                    23DEC04.786
> C                                                                                23DEC04.787
> C --- ICUPA=2: ANTHES KUO                                                        23DEC04.788
> C                                                                                23DEC04.789
>       IF(ICUPA(INEST).EQ.2)THEN                                                  23DEC04.790
> cmic$ do all autoscope                                                           23DEC04.791
> cmic$1 shared(IBNES,IENES,JBNES,JENES,INEST,                                     23DEC04.792
> cmic$1        T3DTEN,QV3DTEN,T3D,QV3D,PP3D,QDOT,RAINC,PSB)                       23DEC04.793
> cmic$2 private(J)                                                                23DEC04.794
> c$doacross                                                                       23DEC04.795
> c$& local(j)                                                                     23DEC04.796
> c$omp parallel do default(shared)                                                23DEC04.797
> c$omp&private(j)                                                                 23DEC04.798
>         DO J=JBNES,JENES-1                                                       23DEC04.799
> #ifdef MPP1                                                                      23DEC04.800
>           DUMJ(J)=J                                                              23DEC04.801
> #endif                                                                           23DEC04.802
>           CALL CUPARA2(J,INEST,IBNES,IENES-1,QV3DTEN,T3DTEN,T3D,QV3D,            23DEC04.803
>      +         PP3D,QDOT,RAINC,PSB)                                              23DEC04.804
>         ENDDO                                                                    23DEC04.805
>       ENDIF                                                                      23DEC04.806
> #endif                                                                           23DEC04.807
> #ifdef ICUPA3                                                                    23DEC04.808
> C                                                                                23DEC04.809
> C --- ICUPA=3: GRELL                                                             23DEC04.810
> C                                                                                23DEC04.811
>       IF(ICUPA(INEST).EQ.3)THEN                                                  23DEC04.812
> #ifndef VECTOR                                                                   23DEC04.813
> cmic$ do all autoscope                                                           23DEC04.814
> cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,u3d,v3d,t3d,qv3d,pp3d,               23DEC04.815
> cmic$1        t3dten,qv3dten,psb,rainc,ht)                                       23DEC04.816
> cmic$2 private(j,i,k,cldfra)                                                     23DEC04.817
> c$doacross                                                                       23DEC04.818
> c$& local(j,i,k,cldfra)                                                          23DEC04.819
> c$omp parallel do default(shared)                                                23DEC04.820
> c$omp&private(j,i,k,cldfra)                                                      23DEC04.821
> Ccsd$ parallel do private(j,i,k,cldfra) schedule(static,1)                       23DEC04.822
>         DO J=JBNES,JENES-1                                                       23DEC04.823
> #ifdef MPP1                                                                      23DEC04.824
>           DUMJ(J)=J                                                              23DEC04.825
> #endif                                                                           23DEC04.826
>           DO K=1,KL                                                              23DEC04.827
>             DO I=IBNES,IENES-1                                                   23DEC04.828
>                CLDFRA(I,K) = 0.0                                                 23DEC04.829
>             END DO                                                               23DEC04.830
>           END DO                                                                 23DEC04.831
>           CALL CUPARA3(T3D,QV3D,PSB,T3DTEN,QV3DTEN,RAINC,CLDFRA,HT,              23DEC04.832
>      +         U3D,V3D,PP3D,                                                     23DEC04.833
>      +         RPSB,DT,DX,R,CP,G,TO,XLV,RV,A,PTOP,                               23DEC04.834
>      +         INEST,J,IBNES,IENES-1)                                            23DEC04.835
>           DO K=1,KL                                                              23DEC04.836
>             DO I=IBNES,IENES-1                                                   23DEC04.837
>               CLDFRA3D(I,J,K)=CLDFRA(I,K)                                        23DEC04.838
>             ENDDO                                                                23DEC04.839
>           ENDDO                                                                  23DEC04.840
>         ENDDO                                                                    23DEC04.841
> Ccsd$ end parallel do                                                            23DEC04.842
> #else                                                                            23DEC04.843
> #  include <call_vector_cupara3.incl>                                            23DEC04.844
> #endif                                                                           23DEC04.845
>       ENDIF                                                                      23DEC04.846
> #endif                                                                           23DEC04.847
> #ifdef ICUPA4                                                                    23DEC04.848
> C                                                                                23DEC04.849
> C --- ICUPA=4: ARAKAWA-SCHUBERT                                                  23DEC04.850
> C                                                                                23DEC04.851
>       IF(ICUPA(INEST).EQ.4)THEN                                                  23DEC04.852
> cmic$ do all autoscope                                                           23DEC04.853
> cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,                                     23DEC04.854
> cmic$1        t3dten,qv3dten,t3d,qv3d,psb,rainc,ht,u3d,v3d,pp3d)                 23DEC04.855
> cmic$2 private(j)                                                                23DEC04.856
> c$doacross                                                                       23DEC04.857
> c$& local(j)                                                                     23DEC04.858
> c$omp parallel do default(shared)                                                23DEC04.859
> c$omp&private(j)                                                                 23DEC04.860
>         DO J=JBNES,JENES-1                                                       23DEC04.861
> #ifdef MPP1                                                                      23DEC04.862
>           DUMJ(J)=J                                                              23DEC04.863
> #endif                                                                           23DEC04.864
>           CALL CUPARA4(T3D,QV3D,PSB,T3DTEN,QV3DTEN,RAINC,HT,U3D,V3D,             23DEC04.865
>      +         PP3D,INEST,J,IBNES,IENES-1)                                       23DEC04.866
>         ENDDO                                                                    23DEC04.867
>       ENDIF                                                                      23DEC04.868
> #endif                                                                           23DEC04.869
> #ifdef ICUPA5                                                                    23DEC04.870
> C                                                                                23DEC04.871
> C --- ICUPA=5: FRITSCH-CHAPPELL                                                  23DEC04.872
> C                                                                                23DEC04.873
>       IF(ICUPA(INEST).EQ.5)THEN                                                  23DEC04.874
> cmic$ do all autoscopE                                                           23DEC04.875
> cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,                                 23DEC04.876
> cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    23DEC04.877
> cmic$2 private(j,scr1)                                                           23DEC04.878
> c$doacross                                                                       23DEC04.879
> c$& local(j,scr1)                                                                23DEC04.880
> c$omp parallel do default(shared)                                                23DEC04.881
> c$omp&private(j,scr1)                                                            23DEC04.882
>         DO J=JBNES,JENES-1                                                       23DEC04.883
>           DO K=1,KL                                                              23DEC04.884
>             DO I=1,ILX                                                           23DEC04.885
>               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          23DEC04.886
>             ENDDO                                                                23DEC04.887
>           ENDDO                                                                  23DEC04.888
> C                                                                                23DEC04.889
>           IF(IMPHYS(INEST).GE.6)THEN                                             23DEC04.890
>             CALL CUPARA5(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             23DEC04.891
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.892
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.893
>           ELSE                                                                   23DEC04.894
>             CALL CUPARA5(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            23DEC04.895
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.896
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.897
>           ENDIF                                                                  23DEC04.898
>         ENDDO                                                                    23DEC04.899
>       ENDIF                                                                      23DEC04.900
> #endif                                                                           23DEC04.901
> #ifdef ICUPA6                                                                    23DEC04.902
> C                                                                                23DEC04.903
> C --- ICUPA=6: KAIN-FRITSCH                                                      23DEC04.904
> C                                                                                23DEC04.905
>       IF(ICUPA(INEST).EQ.6)THEN                                                  23DEC04.906
> cmic$ do all autoscope                                                           23DEC04.907
> cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,rho0,w3d,                        23DEC04.908
> cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    23DEC04.909
> cmic$2 private(j,scr1)                                                           23DEC04.910
> c$doacross                                                                       23DEC04.911
> c$& local(j,scr1)                                                                23DEC04.912
> c$omp parallel do default(shared)                                                23DEC04.913
> c$omp&private(j,scr1)                                                            23DEC04.914
>         DO J=JBNES,JENES-1                                                       23DEC04.915
>           DO K=1,KL                                                              23DEC04.916
>             DO I=1,ILX                                                           23DEC04.917
>               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          23DEC04.918
>             ENDDO                                                                23DEC04.919
>           ENDDO                                                                  23DEC04.920
> C                                                                                23DEC04.921
>           IF(IMPHYS(INEST).GE.6)THEN                                             23DEC04.922
>             CALL CUPARA6(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             23DEC04.923
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.924
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.925
>           ELSE                                                                   23DEC04.926
>             CALL CUPARA6(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            23DEC04.927
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.928
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.929
>           ENDIF                                                                  23DEC04.930
>         ENDDO                                                                    23DEC04.931
>       ENDIF                                                                      23DEC04.932
> #endif                                                                           23DEC04.933
> #ifdef ICUPA7                                                                    23DEC04.934
> C                                                                                23DEC04.935
> C --- ICUPA=7: BETTS-MILLER                                                      23DEC04.936
> C                                                                                23DEC04.937
>       IF(ICUPA(INEST).EQ.7)THEN                                                  23DEC04.938
> cmic$ do all autoscope                                                           23DEC04.939
> cmic$1 shared(ibnes,ienes,jbnes,jenes,inest,                                     23DEC04.940
> cmic$&       t3dten,qv3dten,t3d,qv3d,pp3d,psb,rainc,xland,shc,t0)                23DEC04.941
> cmic$2 private(j)                                                                23DEC04.942
> c$doacross                                                                       23DEC04.943
> c$& local(j)                                                                     23DEC04.944
> c$omp parallel do default(shared)                                                23DEC04.945
> c$omp&private(j)                                                                 23DEC04.946
>         DO J=JBNES,JENES-1                                                       23DEC04.947
> #ifdef MPP1                                                                      23DEC04.948
>           DUMJ(J)=J                                                              23DEC04.949
> #endif                                                                           23DEC04.950
>           CALL CUPARA7(T3D,QV3D,PSB,PP3D,T3DTEN,QV3DTEN,RAINC,SHC,XLAND,         23DEC04.951
>      +         J,INEST,IBNES,IENES-1,T0)                                         23DEC04.952
>         ENDDO                                                                    23DEC04.953
>       ENDIF                                                                      23DEC04.954
> #endif                                                                           23DEC04.955
> #ifdef ICUPA8                                                                    23DEC04.956
> C                                                                                23DEC04.957
> C --- ICUPA=8: KAIN-FRITSCH 2 WITH SHALLOW CONVECTION                            23DEC04.958
> C                                                                                23DEC04.959
>       IF(ICUPA(INEST).EQ.8)THEN                                                  23DEC04.960
> cmic$ do all autoscope                                                           23DEC04.961
> cmic$1 shared(ilx,ibnes,ienes,jbnes,jenes,inest,rho0,w3d,                        23DEC04.962
> cmic$1        t3dten,qv3dten,u3d,v3d,t3d,qv3d,pp3d,psb,rainc)                    23DEC04.963
> cmic$2 private(j,scr1)                                                           23DEC04.964
> c$doacross                                                                       23DEC04.965
> c$& local(j,scr1)                                                                23DEC04.966
> c$omp parallel do default(shared)                                                23DEC04.967
> c$omp&private(j,scr1)                                                            23DEC04.968
> Ccsd$ parallel do private(j,i,k,scr1) schedule(static,1)                         23DEC04.969
>         DO J=JBNES,JENES-1                                                       23DEC04.970
>           DO K=1,KL                                                              23DEC04.971
>             DO I=1,ILX                                                           23DEC04.972
>               SCR1(I,K)=-5.0E-4*G*RHO0(I,J,K)*(W3D(I,J,K)+W3D(I,J,K+1))          23DEC04.973
>             ENDDO                                                                23DEC04.974
>           ENDDO                                                                  23DEC04.975
> C                                                                                23DEC04.976
>           IF(IMPHYS(INEST).GE.6)THEN                                             23DEC04.977
>             CALL CUPARA8(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QG3DTEN,             23DEC04.978
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.979
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.980
>           ELSE                                                                   23DEC04.981
>             CALL CUPARA8(PSB,T3DTEN,QV3DTEN,QR3DTEN,QC3DTEN,QNI3DTEN,            23DEC04.982
>      +           QI3DTEN,RAINC,SCR1,U3D,V3D,T3D,QV3D,PP3D,J,INEST,               23DEC04.983
>      +           IMPHYS(INEST),IBNES,IENES-1)                                    23DEC04.984
>           ENDIF                                                                  23DEC04.985
>         ENDDO                                                                    23DEC04.986
> Ccsd$ end parallel do                                                            23DEC04.987
>       ENDIF                                                                      23DEC04.988
> #endif                                                                           23DEC04.989
> C=======================================================================         23DEC04.990
1457a1835
>       if (ITPDIF.le.1) then                                                      23DEC04.991
1459a1838,1839
> c  this term is not needed for z-diffusion because                               23DEC04.992
> c  z-diffusion is computed with theta                                            23DEC04.993
1489a1870
>       endif                                                                      23DEC04.994
1494c1875
<       ELSE                                                                       SOLVE.1270
---
>       ELSE IF (ITPDIF.EQ.0) THEN                                                 23DEC04.995
1496a1878,1895
>       ELSE IF (ITPDIF.GE.2) THEN                                                 23DEC04.996
>       if (IMPHYS(INEST).GE.3)THEN                                                23DEC04.997
>       CALL DIFFTH(KZZ,T3DTEN,TBP,T3D,T0,PSB,CRSXK,C203,IBNES,IENES-1,            23DEC04.998
>      + JBNES,JENES-1,KL,INEST,QC3D,THGB,fin,fjn,deltaz,lam,kmvl,rmn,             23DEC04.999
>      & kmi,kmj,kmip,kmim,kmjp,kmjm,                                              23DEC04.1000
>      & mrkip1,mrkip2,mrkim1,mrkim2,mrkjp1,mrkjp2,mrkjm1,mrkjm2,                  23DEC04.1001
>      & irkip1,irkip2,irkim1,irkim2,irkjp1,irkjp2,irkjm1,irkjm2,                  23DEC04.1002
>      & fjt04,fit04,fit0o,fit0u,fjt0o,fjt0u,fion,fiun,fjon,fjun,dz3d,             23DEC04.1003
>      + zdiffst)                                                                  23DEC04.1004
>         else                                                                     23DEC04.1005
>        CALL DIFFTHD(KZZ,T3DTEN,TBP,T3D,T0,PSB,CRSXK,C203,IBNES,IENES-1,          23DEC04.1006
>      + JBNES,JENES-1,KL,INEST,THGB,fin,fjn,deltaz,lam,kmvl,rmn,                  23DEC04.1007
>      & kmi,kmj,kmip,kmim,kmjp,kmjm,                                              23DEC04.1008
>      & mrkip1,mrkip2,mrkim1,mrkim2,mrkjp1,mrkjp2,mrkjm1,mrkjm2,                  23DEC04.1009
>      & irkip1,irkip2,irkim1,irkim2,irkjp1,irkjp2,irkjm1,irkjm2,                  23DEC04.1010
>      & fjt04,fit04,fit0o,fit0u,fjt0o,fjt0u,fion,fiun,fjon,fjun,dz3d,             23DEC04.1011
>      + zdiffst)                                                                  23DEC04.1012
>       endif                                                                      23DEC04.1013
1502a1902,1909
>       if (ITPDIF.ge.2) then                                                      23DEC04.1014
>         CALL DIFFMOI(KZZ,QV3DTEN,QV3D,PSB,CRSXK,C203,                            23DEC04.1015
>      &           IBNES,IENES-1,JBNES,JENES-1,KL,INEST,                           23DEC04.1016
>      &  fin,fjn,2,kmvl,kmi,kmj,gezipwh,gezimwh,gezjpwh,gezjmwh,                  23DEC04.1017
>      & mrkip1,mrkip2,mrkim1,mrkim2,mrkjp1,mrkjp2,mrkjm1,mrkjm2,                  23DEC04.1018
>      & irkip1,irkip2,irkim1,irkim2,irkjp1,irkjp2,irkjm1,irkjm2,                  23DEC04.1019
>      & fionf,fiunf,fjonf,fjunf,dz3d,dx,zdiffst)                                  23DEC04.1020
>       else                                                                       23DEC04.1021
1504a1912
>       endif                                                                      23DEC04.1022
1505a1914,1921
>       if (ITPDIF.ge.2) then                                                      23DEC04.1023
>           CALL DIFFMOI(KZZ,QC3DTEN,QC3D,PSB,CRSXK,C203,                          23DEC04.1024
>      &               IBNES,IENES-1,JBNES,JENES-1,KL,INEST,                       23DEC04.1025
>      &  fin,fjn,1,kmvl,kmi,kmj,gezipwh,gezimwh,gezjpwh,gezjmwh,                  23DEC04.1026
>      & mrkip1,mrkip2,mrkim1,mrkim2,mrkjp1,mrkjp2,mrkjm1,mrkjm2,                  23DEC04.1027
>      & irkip1,irkip2,irkim1,irkim2,irkjp1,irkjp2,irkjm1,irkjm2,                  23DEC04.1028
>      & fionf,fiunf,fjonf,fjunf,dz3d,dx,zdiffst)                                  23DEC04.1029
>       else                                                                       23DEC04.1030
1507a1924
>       endif                                                                      23DEC04.1031
1744a2162
> Ccsd$ parallel do private(i,j,k,scr1) schedule(static,1)                         23DEC04.1032
1761a2180
> Ccsd$ end parallel do                                                            23DEC04.1033
1779a2199
> Ccsd$ parallel do private(j) schedule(static,1)                                  23DEC04.1034
1783a2204,2210
> #  ifdef MPHYSTBL2                                                               23DEC04.1035
> CB New optimized exmoisr routine is called if MPHYSTBL set to 2                  23DEC04.1036
>            CALL ZEXMOISR(QC3DTEN,QR3DTEN,QI3DTEN,QNI3DTEN,QV3DTEN,T3DTEN         23DEC04.1037
>      +          ,T3D,QV3D,QC3D,QR3D,QI3D,QNI3D,PP3D,PSB,RPSB,RAINNC              23DEC04.1038
>      +          ,SNOWNCT,INEST,J                                                 23DEC04.1039
>      +          ,IBNES,IENES-1)                                                  23DEC04.1040
> #  endif                                                                         23DEC04.1041
1788c2215,2216
< #  else                                                                          07NOV00.1080
---
> #  endif                                                                         23DEC04.1042
> #  ifdef MPHYSTBL0                                                               23DEC04.1043
1795a2224
> Ccsd$ end parallel do                                                            23DEC04.1044
1890,1895c2319,2324
< cmic$ do all autoscope                                                           SOLVE.1651
< cmic$2 private(j,i,scr1)                                                         24SEP99.385
< c$doacross                                                                       SOLVE.1653
< c$& local(j,i)                                                                   24SEP99.386
< c$omp parallel do default(shared)                                                SOLVE.1655
< c$omp&private(j,i)                                                               24SEP99.387
---
> cmic$ do all autoscope                                                           23DEC04.1045
> cmic$2 private(j,i,K,TPOSDZ,SNOWFRAC,IS)                                         23DEC04.1046
> c$doacross                                                                       23DEC04.1047
> c$& local(j,i,K,TPOSDZ,SNOWFRAC,IS)                                              23DEC04.1048
> c$omp parallel do default(shared)                                                23DEC04.1049
> c$omp&private(j,i,K,TPOSDZ,SNOWFRAC,IS)                                          23DEC04.1050
1940c2369
<                   MAVAIL(I,J)=SLMO(IS,ISN)                                       19DEC02.1297
---
>                   IF(IMOIAV(INEST).EQ.0)MAVAIL(I,J)=SLMO(IS,ISN)                 23DEC04.1051
2023a2453
> Ccsd$ parallel do private(j) schedule(static,1)                                  23DEC04.1052
2029a2460
> Ccsd$ end parallel do                                                            23DEC04.1053
2041a2473
> Ccsd$ parallel do private(j) schedule(static,1)                                  23DEC04.1054
2047a2480
> Ccsd$ end parallel do                                                            23DEC04.1055
2244c2677
<       IF(ILDDIM.EQ.1)THEN                                                        05DEC01.581
---
>       IF((ILDDIM.EQ.1).AND.(ISOIL.EQ.2))THEN                                     23DEC04.1056
===================================================================
dynamics/nonhydro/sound.F
diff -r3.6 -r3.12
0a1,2
> #ifndef IBMopt                                                                   23DEC04.1057
>                                                                                  23DEC04.1058
196a199
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1059
238a242
> Ccsd$ end parallel do                                                            23DEC04.1060
246a251
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1061
255a261
> Ccsd$ end parallel do                                                            23DEC04.1062
263a270
> Ccsd$ parallel do private(i,j,k,kp1,km1) schedule(static,1)                      23DEC04.1063
275a283
> Ccsd$ end parallel do                                                            23DEC04.1064
288a297,298
> Ccsd$ parallel do private(i,j,k,rho,chh,dppdp0)                                  23DEC04.1065
> Ccsd$& schedule(static,1)                                                        23DEC04.1066
313a324
> Ccsd$ end parallel do                                                            23DEC04.1067
320a332
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1068
330a343
> Ccsd$ end parallel do                                                            23DEC04.1069
337a351
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1070
346a361
> Ccsd$ end parallel do                                                            23DEC04.1071
363a379,381
> Ccsd$ parallel do private(tk,ca,g1,g2,c,b,aa,rhs,denom,pxup,                     23DEC04.1072
> Ccsd$& i,j,k,kp1,km1,wo,cc,cdd,cj,pyvp,ptend,rofac)                              23DEC04.1073
> Ccsd$& schedule(static,1)                                                        23DEC04.1074
491a510,511
> C Cdir$ no unroll                                                                23DEC04.1075
> Cdir$ interchange(i,K)                                                           23DEC04.1076
507a528
> Ccsd$ end parallel do                                                            23DEC04.1077
579a601,603
> Ccsd$ parallel do private(i,j,k,wpval,cfl,rho0s,ucrs,vcrs,                       23DEC04.1078
> Ccsd$& check,sigdot,nsj,nsi,in,jn)                                               23DEC04.1079
> Ccsd$& schedule(static,1)                                                        23DEC04.1080
674a699
> Ccsd$ end parallel do                                                            23DEC04.1081
686a712,713
> Ccsd$ parallel do private(k,i,j)                                                 23DEC04.1082
> Ccsd$& schedule(static,1)                                                        23DEC04.1083
720a748
> Ccsd$ end parallel do                                                            23DEC04.1084
730a759,760
> Ccsd$ parallel do private(j,k,i,ppold,cddtmp,cjtmp,cpm,dpterm)                   23DEC04.1085
> Ccsd$& schedule(static,1)                                                        23DEC04.1086
752a783
> Ccsd$ end parallel do                                                            23DEC04.1087
777a809
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1088
798a831
> Ccsd$ end parallel do                                                            23DEC04.1089
804a838
> Ccsd$ parallel do private(i,j,k) schedule(static,1)                              23DEC04.1090
825a860
> Ccsd$ end parallel do                                                            23DEC04.1091
837a873,874
> Ccsd$ parallel do private(i,j,k)                                                 23DEC04.1092
> Ccsd$& schedule(static,1)                                                        23DEC04.1093
863a901
> Ccsd$ end parallel do                                                            23DEC04.1094
866a905,2400
>                                                                                  23DEC04.1095
>                                                                                  23DEC04.1096
> #else                                                                            23DEC04.1097
> C IBM optimized SOUND routine                                                    23DEC04.1098
>                                                                                  23DEC04.1099
>       SUBROUTINE SOUND(IYY,JXX,UB,VB,TB,PR1,RHO1,                                23DEC04.1100
>      &                 UA,VA,TA,QVB,PSA,HT,MSFD,MSFX,                            23DEC04.1101
>      &                 UTENS,VTENS,PPTENS,WTENS,                                 23DEC04.1102
>      &                 DX,DTL,INEST,KTAU)                                        23DEC04.1103
>       IMPLICIT NONE                                                              23DEC04.1104
> CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC         23DEC04.1105
> C                                                                      C         23DEC04.1106
> C     CHANGES:                                                         C         23DEC04.1107
> C          REORDERING LOOPS FOR PARALLEL EFFICIENCY                    C         23DEC04.1108
> C          ADDITION OF HP PARALLEL DIRECTIVES                          C         23DEC04.1109
> C          REMOVAL OF SGI SHARE PARALLEL DIRECTIVES (UNNECESSARY)      C         23DEC04.1110
> C          REPLACE UA -> U3D ETC                                       C         23DEC04.1111
> C          IMPROVE UPPER RAD CONDITION EFFICIENCY                      C         23DEC04.1112
> C     NOTE:                                                            C         23DEC04.1113
> C          THE LINE NUMBERS IN SOUND.F HAVE BEEN REDONE FOR            C         23DEC04.1114
> C          RELEASE-2-7 (DECEMBER 21, 1997)                             C         23DEC04.1115
> C     CHANGES:                                                         C         23DEC04.1116
> C          USE COMMON BLOCKS TO STORE PSTAR-DERIVED VARIABLES (2.9)    C         23DEC04.1117
> C          USE COMMON BLOCKS TO STORE REF STATE AND UP. RAD. VARIABLES C         23DEC04.1118
> C           (2.9)                                                      C         23DEC04.1119
> C          CHANGE NEST B.C. ON P` TO JUST INTERPOLATE 2ND PT FROM      C         23DEC04.1120
> C           COARSE MESH LIKE ALL OTHER VARIABLES                       C         23DEC04.1121
> C                                                                      C         23DEC04.1122
> CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC         23DEC04.1123
> #     include <parame.incl>                                                      23DEC04.1124
> #     include <param2.incl>                                                      23DEC04.1125
> #     include <param3.incl>                                                      23DEC04.1126
> #     include <pmoist.incl>                                                      23DEC04.1127
> #     include <nonhyd.incl>                                                      23DEC04.1128
> #     include <nonhydb.incl>                                                     23DEC04.1129
> #     include <nhcnst.incl>                                                      23DEC04.1130
> C                                                                                23DEC04.1131
> #     include <uprad.incl>                                                       23DEC04.1132
> #     include <rpstar.incl>                                                      23DEC04.1133
> C                                                                                23DEC04.1134
>       INTEGER   IYY,JXX,INEST,KTAU                                               23DEC04.1135
>       REAL      DX,DTL                                                           23DEC04.1136
> C                                                                                23DEC04.1137
>       REAL XMUT,XNUT,XMUU,XNUU                                                   23DEC04.1138
>       REAL E,F                                                                   23DEC04.1139
>       COMMON /ASSEL/ XMUT(MIX,MJX,MAXNES),XNUT(MIX,MJX,MAXNES),                  23DEC04.1140
>      1               XMUU(MIX,MJX,MAXNES),XNUU(MIX,MJX,MAXNES)                   23DEC04.1141
>       COMMON /SOUNDL/E(MIX,MJX,KXP1),F(MIX,MJX,KXP1)                             23DEC04.1142
>       REAL      UA(MIX,MJX,MKX), UB(MIX,MJX,MKX),                                23DEC04.1143
>      &          VA(MIX,MJX,MKX), VB(MIX,MJX,MKX),                                23DEC04.1144
>      &          TA(MIX,MJX,MKX), TB(MIX,MJX,MKX),                                23DEC04.1145
>      &          HT(MIX,MJX),    QVB(MIX,MJX,MKX),                                23DEC04.1146
>      &         PSA(MIX,MJX)                                                      23DEC04.1147
>       REAL      MSFD(MIX,MJX),   MSFX(MIX,MJX)                                   23DEC04.1148
>       REAL      PR1(MIX,MJX,MKX),RHO1(MIX,MJX,MKX)                               23DEC04.1149
>       REAL      WTENS(MIXNH,MJXNH,KXP1NH),PPTENS(MIXNH,MJXNH,MKXNH),             23DEC04.1150
>      1     UTENS(MIXNH,MJXNH,MKXNH),VTENS(MIXNH,MJXNH,MKXNH)                     23DEC04.1151
> C                                                                                23DEC04.1152
>       REAL      RHS(MIX,KXP1),WO(MIX,KXP1),PPO(MIX,MKX)                          23DEC04.1153
>       REAL      AA(MIX,KXP1),B(MIX,KXP1),C(MIX,KXP1)                             23DEC04.1154
>       REAL      CA(MIX,MKX),CC(MIX,MKX),CDD(MIX,MKX),CJ(MIX,MKX)                 23DEC04.1155
> #ifndef MPP1                                                                     23DEC04.1156
>       REAL      ESTORE(MIX,MJX),ASTORE(MIX,MJX),WPVAL(MIX)                       23DEC04.1157
> #else                                                                            23DEC04.1158
>       REAL      ESTORE(-3:MIX+4,-3:MJX+4),ASTORE(MIX,MJX),WPVAL(MIX)             23DEC04.1159
> #endif                                                                           23DEC04.1160
>       REAL      PYVP(MIX,MKX),PXUP(MIX,MKX),PTEND(MIX,MKX)                       23DEC04.1161
>       REAL      G1(MIX,MKX),G2(MIX,MKX)                                          23DEC04.1162
> C                                                                                23DEC04.1163
>       REAL      FK(0:6),FL(0:6),FI(-6:6),FJ(-6:6)                                23DEC04.1164
>       REAL      TK(MIX,MKX)                                                      23DEC04.1165
> C                                                                                23DEC04.1166
>       REAL      PI(MIX,MJX,MKX)                                                  23DEC04.1167
>       REAL      SIGDOT(MIX,KXP1), UCRS(MIX,MKX),VCRS(MIX,MKX)                    23DEC04.1168
> C                                                                                23DEC04.1169
> #ifndef MPP1                                                                     23DEC04.1170
>       REAL      U3D(MIX,  MJX,  MKX),    V3D(MIX,  MJX,  MKX),                   23DEC04.1171
>      1          T3D(MIX,  MJX,  MKX),    W3D(MIX,  MJX,  MKX+1),                 23DEC04.1172
>      2         PP3D(MIX,  MJX,  MKX),   QV3D(MIX,  MJX,  MKX)                    23DEC04.1173
> #else                                                                            23DEC04.1174
> #define FULL_DECLARE                                                             23DEC04.1175
> #  include <mpp_dusolve3.incl>                                                   23DEC04.1176
> #endif                                                                           23DEC04.1177
> C                                                                                23DEC04.1178
>       REAL      BET,BP,BM,BPXBP,BPXBM,XKD,GAMMA,DX8,CS,DTSMAX                    23DEC04.1179
>       REAL      DTS                                                              23DEC04.1180
>       REAL      RHO,DPPDP0,CHH,ROFAC,DENOM,ATOT,RHONTOT,XMSFTOT                  23DEC04.1181
>       REAL      ENSQ,ABAR,RHON,XMSFBAR,CPI,cpi12,DXMSFB                          23DEC04.1182
>       REAL      XKEFF,XLEFF,XKLEFF                                               23DEC04.1183
>       REAL      CFL                                                              23DEC04.1184
>       REAL      RHO0S,CHECK,PPOLD,CDDTMP,CJTMP,CPM,DPTERM                        23DEC04.1185
> C                                                                                23DEC04.1186
>       INTEGER   I,J,K,L,LL,M,N                                                   23DEC04.1187
>       INTEGER   IT,ITL                                                           23DEC04.1188
>       INTEGER   LP1,MP1,NP1,KP1,KM1                                              23DEC04.1189
>       INTEGER   NSJ,JN,NSI,IN                                                    23DEC04.1190
>       INTEGER   ICUT,ISTART,IEND,JSTART,JEND                                     23DEC04.1191
>       INTEGER   ISTEP                                                            23DEC04.1192
>       INTEGER   NPTS,NOCHECK                                                     23DEC04.1193
>                                                                                  23DEC04.1194
>       real rmsfd(MIX,MJX),rmsfx(MIX,MJX),rps0(MIXNH,MJXNH)                       23DEC04.1195
>       real dsigmai(MKX),dsigmas(MKX),dxi,gi,rnpts,rrhon,ttime                    23DEC04.1196
>       real rp1(MIXNH,MJXNH,MKXNH),rp2(MIXNH,MJXNH,MKXNH),rrr,rr1                 23DEC04.1197
>       data ttime/1.0/,kkk/1/,iinest/0/                                           23DEC04.1198
>       save ttime,dsigmai,dsigmas,rmsfd,rmsfx,rps0,rp1,rp2,kkk,iinest             23DEC04.1199
>       integer is,is1,ie,ie1,is2,ie2,kkk,nn,nn3,is3,iinest                        23DEC04.1200
>       integer js,je,is4,nn4,is5,nn5,is6,nn6                                      23DEC04.1201
>       real dtsx1,dtsx2,dtsx3,dtsx4,dtsx5,dtsx6,dtsx7,dtsx8                       23DEC04.1202
>       real tmp(mix,6)                                                            23DEC04.1203
>       real aux0,aux2,aux4,aux6,aux8,ua1,va1,ub1,vb1,xnu,wa1,wb1                  23DEC04.1204
>                                                                                  23DEC04.1205
> C                                                                                23DEC04.1206
> #ifdef MPP1                                                                      23DEC04.1207
> #  include "cflcom.incl"                                                         23DEC04.1208
> #  include <mpp_sound_00.incl>                                                   23DEC04.1209
> #endif                                                                           23DEC04.1210
>                                                                                  23DEC04.1211
> #ifdef MPP1                                                                      23DEC04.1212
> #define nf(A) noflic(A) 
> #else                                                                            23DEC04.1214
> #define nf(A) A        
> #endif                                                                           23DEC04.1216
> C     BET IS IKAWA BETA PARAMETER (0.=CENTERED, 1.=BACKWARD)                     23DEC04.1217
>       BET=0.4                                                                    23DEC04.1218
>       BP=(1.+BET)*0.5                                                            23DEC04.1219
>       BM=(1.-BET)*0.5                                                            23DEC04.1220
>       BPXBP=BP*BP                                                                23DEC04.1221
>       BPXBM=BP*BM                                                                23DEC04.1222
>       XKD=0.1                                                                    23DEC04.1223
> C                                                                                23DEC04.1224
> C     IF(KTAU.LE.1)THEN                                                          23DEC04.1225
>       GAMMA=1./(1.-ROVCP)                                                        23DEC04.1226
>       DX8=DX*8.                                                                  23DEC04.1227
>       dxi=1./dx                                                                  23DEC04.1228
>       gi=1./g                                                                    23DEC04.1229
> C     CALCULATE SHORT TIME-STEP                                                  23DEC04.1230
> cto enable MPI_IO_NODE to work correctly                                         23DEC04.1231
> C      CS=SQRT(GAMMA*R*T0(1,1,KX))                                               23DEC04.1232
> C#ifdef MPP1                                                                     23DEC04.1233
> C#  include <mpp_sound_10.incl>                                                  23DEC04.1234
> C#endif                                                                          23DEC04.1235
>       CS=SQRT(GAMMA*R*TS0)                                                       23DEC04.1236
>       DTSMAX=DX/CS/(1.+XKD)                                                      23DEC04.1237
> C     DTL LONG TIME-STEP (XXB-XXC)                                               23DEC04.1238
>       ISTEP=IFIX(DTL/DTSMAX)+1                                                   23DEC04.1239
>       IF(KTAU.GE.1)ISTEP=MAX0(4,ISTEP)                                           23DEC04.1240
>       DTS=DTL/ISTEP                                                              23DEC04.1241
>       dtsx1 = 0.5*dts*dxi                                                        23DEC04.1242
>       dtsx2 = 0.125 * dxi * gi                                                   23DEC04.1243
>       dtsx3 = GAMMA * DTS * DXi                                                  23DEC04.1244
>       dtsx4 = GAMMA * DTS * g                                                    23DEC04.1245
>       dtsx5 = 0.5 * DTS * g                                                      23DEC04.1246
>                                                                                  23DEC04.1247
>       L=IYY-1                                                                    23DEC04.1248
>       LP1=IYY                                                                    23DEC04.1249
>       M=JXX-1                                                                    23DEC04.1250
>       MP1=JXX                                                                    23DEC04.1251
>       N=KX                                                                       23DEC04.1252
>       NP1=KXP1                                                                   23DEC04.1253
> C                                                                                23DEC04.1254
> C  CALCULATE THE LOOP BOUNDARIES                                                 23DEC04.1255
> C                                                                                23DEC04.1256
>       ICUT=0                                                                     23DEC04.1257
>       IF(INEST.GT.1)ICUT=1                                                       23DEC04.1258
>       ISTART=2+ICUT                                                              23DEC04.1259
>       IEND=L-1-ICUT                                                              23DEC04.1260
>       JSTART=2+ICUT                                                              23DEC04.1261
>       JEND=M-1-ICUT                                                              23DEC04.1262
>                                                                                  23DEC04.1263
> #ifdef MPP1                                                                      23DEC04.1264
>       nn = ie_x8(iend) - is_x8(istart) + 1                                       23DEC04.1265
>       nn3 = ie_x8(L-ICUT) - is_x8(2+ICUT) + 1                                    23DEC04.1266
>       is2 = is_x8(istart)                                                        23DEC04.1267
>       is3 = is_x8(2+ICUT)                                                        23DEC04.1268
> #else                                                                            23DEC04.1269
>       nn = iend - istart + 1                                                     23DEC04.1270
>       is2 = istart                                                               23DEC04.1271
>       nn3 = L-ICUT - 1 + ICUT                                                    23DEC04.1272
>       is3 = 2+ICUT                                                               23DEC04.1273
> #endif                                                                           23DEC04.1274
>                                                                                  23DEC04.1275
>       if(ttime.gt.0.) then                                                       23DEC04.1276
>          dsigmai(1) = 1./dsigma(1)                                               23DEC04.1277
>          do k=2,mkx                                                              23DEC04.1278
>             dsigmai(k) = 1./dsigma(k)                                            23DEC04.1279
>             dsigmas(k) = 1./(dsigma(k)+dsigma(k-1))                              23DEC04.1280
>          end do                                                                  23DEC04.1281
>          ttime=-1.                                                               23DEC04.1282
>       end if                                                                     23DEC04.1283
>                                                                                  23DEC04.1284
>       if(iinest.ne.inest) then                                                   23DEC04.1285
>                                                                                  23DEC04.1286
>          is  = min0(ISTART,1+ICUT)                                               23DEC04.1287
>          ie  = max0(IEND,L-ICUT)                                                 23DEC04.1288
>          is1 = min0(2+icut,istart)                                               23DEC04.1289
>          ie1 = max0(L,L-ICUT)                                                    23DEC04.1290
>          js = min0(JSTART,1+ICUT)                                                23DEC04.1291
>          je = max0(JEND,M-ICUT)                                                  23DEC04.1292
>                                                                                  23DEC04.1293
> #ifdef MPP1                                                                      23DEC04.1294
>          is4 = is_x8(is)                                                         23DEC04.1295
>          is5 = is_x8(is1)                                                        23DEC04.1296
>          is6 = is_x8(1)                                                          23DEC04.1297
>          nn4 = ie_x8(ie)  - is_x8(is) + 1                                        23DEC04.1298
>          nn5 = ie_x8(ie1) - is_x8(is1) + 1                                       23DEC04.1299
>          nn6 = ie_x8(lp1) - is_x8(1) + 1                                         23DEC04.1300
> #else                                                                            23DEC04.1301
>          is4 = is                                                                23DEC04.1302
>          is5 = is1                                                               23DEC04.1303
>          is6 = 1                                                                 23DEC04.1304
>          nn4 = ie - is + 1                                                       23DEC04.1305
>          nn5 = ie1 - is1 + 1                                                     23DEC04.1306
>          nn6 = lp1                                                               23DEC04.1307
> #endif                                                                           23DEC04.1308
>                                                                                  23DEC04.1309
> c$omp parallel do default(shared)                                                23DEC04.1310
> c$omp&private(i,j,k,kp1,km1,tmp)                                                 23DEC04.1311
>          do j=1,jxx                                                              23DEC04.1312
>             if(j.ge.jstart.and.j.le.jend) then                                   23DEC04.1313
>                do i=is1,ie1                                                      23DEC04.1314
>                   tmp(i,1) =  ps0(i,j)                                           23DEC04.1315
>                end do                                                            23DEC04.1316
>                call vsrec(rps0(nf(is5),j),tmp(nf(is5),1),nn5)                    23DEC04.1317
>             end if                                                               23DEC04.1318
>                                                                                  23DEC04.1319
>             do i=1,lp1                                                           23DEC04.1320
>                tmp(i,1) = msfd(i,j)                                              23DEC04.1321
>                tmp(i,2) = msfx(i,j)                                              23DEC04.1322
>             end do                                                               23DEC04.1323
>             call vsrec(rmsfd(nf(is6),j),tmp(nf(is6),1),nn6)                      23DEC04.1324
>             call vsrec(rmsfx(nf(is6),j),tmp(nf(is6),2),nn6)                      23DEC04.1325
>                                                                                  23DEC04.1326
>             if(j.ge.js.and.j.le.je) then                                         23DEC04.1327
>                do k=1,n-1                                                        23DEC04.1328
>                   km1 = k                                                        23DEC04.1329
>                   kp1 = k+1                                                      23DEC04.1330
>                   do i=is,ie                                                     23DEC04.1331
>                      tmp(i,1) = pr0(i,j,km1) - pr0(i,j,kp1)                      23DEC04.1332
>                   end do                                                         23DEC04.1333
>                  call vsrec(rp1(nf(is4),j,k),tmp(nf(is4),1),nn4)                 23DEC04.1334
>                end do                                                            23DEC04.1335
>                                                                                  23DEC04.1336
>                do k=2,n-1                                                        23DEC04.1337
>                   km1 = k-1                                                      23DEC04.1338
>                   kp1 = k+1                                                      23DEC04.1339
>                   do i=is,ie                                                     23DEC04.1340
>                      tmp(i,1) = pr0(i,j,km1) - pr0(i,j,kp1)                      23DEC04.1341
>                   end do                                                         23DEC04.1342
>                  call vsrec(rp2(nf(is4),j,k),tmp(nf(is4),1),nn4)                 23DEC04.1343
>                end do                                                            23DEC04.1344
>                                                                                  23DEC04.1345
>                k=1                                                               23DEC04.1346
>                km1=k                                                             23DEC04.1347
>                kp1=k+1                                                           23DEC04.1348
>                do i=is,ie                                                        23DEC04.1349
>                   tmp(i,1) = pr0(i,j,km1) - pr0(i,j,kp1)                         23DEC04.1350
>                end do                                                            23DEC04.1351
>                call vsrec(rp2(nf(is4),j,k),tmp(nf(is4),1),nn4)                   23DEC04.1352
>                k=n                                                               23DEC04.1353
>                km1=k-1                                                           23DEC04.1354
>                kp1=k                                                             23DEC04.1355
>                do i=is,ie                                                        23DEC04.1356
>                   tmp(i,1) = pr0(i,j,km1) - pr0(i,j,kp1)                         23DEC04.1357
>                end do                                                            23DEC04.1358
>                call vsrec(rp2(nf(is4),j,k),tmp(nf(is4),1),nn4)                   23DEC04.1359
>             end if                                                               23DEC04.1360
>          end do                                                                  23DEC04.1361
>          iinest = inest                                                          23DEC04.1362
>       end if                                                                     23DEC04.1363
>                                                                                  23DEC04.1364
>       IF(KTAU.EQ.0)THEN                                                          23DEC04.1365
>       PRINT *,'SHORT TIME STEP ',DTS,ISTEP,' BETA = ',BET,                       23DEC04.1366
>      -     ' XKD = ',XKD                                                         23DEC04.1367
> cmic$ do all autoscope                                                           23DEC04.1368
> c$doacross                                                                       23DEC04.1369
> c$& local(i,j)                                                                   23DEC04.1370
> c$omp parallel do default(shared)                                                23DEC04.1371
> c$omp&private(i,j)                                                               23DEC04.1372
>         DO 3 J=-6,6                                                              23DEC04.1373
>           DO 3 I=-6,6                                                            23DEC04.1374
>             TMASK(I,J)=0.                                                        23DEC04.1375
>     3     CONTINUE                                                               23DEC04.1376
>                                                                                  23DEC04.1377
>         IF(IFUPR.EQ.1)THEN                                                       23DEC04.1378
> C                                                                                23DEC04.1379
> C  DEFINE VALUES OF FK, FL, FI & FJ FOR UPPER RADIATIVE BC                       23DEC04.1380
> C                                                                                23DEC04.1381
>           DO I=1,5                                                               23DEC04.1382
>             FK(I)=2.0                                                            23DEC04.1383
>             FL(I)=2.0                                                            23DEC04.1384
>           ENDDO                                                                  23DEC04.1385
>           FK(0)=1.0                                                              23DEC04.1386
>           FL(0)=1.0                                                              23DEC04.1387
>           FK(6)=1.0                                                              23DEC04.1388
>           FL(6)=1.0                                                              23DEC04.1389
>           DO I=-5,5                                                              23DEC04.1390
>             FI(I)=1.0                                                            23DEC04.1391
>             FJ(I)=1.0                                                            23DEC04.1392
>           ENDDO                                                                  23DEC04.1393
>           FI(-6)=0.5                                                             23DEC04.1394
>           FJ(-6)=0.5                                                             23DEC04.1395
>           FI(6)=0.5                                                              23DEC04.1396
>           FJ(6)=0.5                                                              23DEC04.1397
>         ENDIF                                                                    23DEC04.1398
>       ENDIF                                                                      23DEC04.1399
> C                                                                                23DEC04.1400
> cmic$ do all autoscope                                                           23DEC04.1401
> c$doacross local(i,j,k)                                                          23DEC04.1402
> c$omp parallel do default(shared)                                                23DEC04.1403
> c$omp&private(i,j,k,aux2,aux4,aux6)                                              23DEC04.1404
>       DO J=1,JXX                                                                 23DEC04.1405
> C                                                                                23DEC04.1406
> C  PREMULTIPLY THE TENDENCY ARRAYS BY DTS                                        23DEC04.1407
> C                                                                                23DEC04.1408
> C  CALCULATE INITIAL ARRAYS FOR SHORT TIMESTEP                                   23DEC04.1409
> C  XXB STORES FILTERED OLD XXA WITHOUT XXC TERM                                  23DEC04.1410
> C  NO ASSELIN FILTER ON BOUNDARY                                                 23DEC04.1411
> C                                                                                23DEC04.1412
>         IF(J.LE.MP1)THEN                                                         23DEC04.1413
>           DO K=1,N                                                               23DEC04.1414
>             DO 200 I=1,LP1                                                       23DEC04.1415
>               UTENS(I,J,K)=UTENS(I,J,K)*DTS                                      23DEC04.1416
>               VTENS(I,J,K)=VTENS(I,J,K)*DTS                                      23DEC04.1417
>               aux2 = UB(I,J,K)                                                   23DEC04.1418
>               aux4 = VB(I,J,K)                                                   23DEC04.1419
>               aux6 = XMUU(I,J,INEST) * rMSFD(I,J)                                23DEC04.1420
>               U3D(I,J,K)=aux2 * RPDOTB(I,J)                                      23DEC04.1421
>               V3D(I,J,K)=aux4 * RPDOTB(I,J)                                      23DEC04.1422
>               aux2 = aux6 * UA(I,J,K) + XNUU(I,J,INEST)*aux2                     23DEC04.1423
>               aux4 = aux6 * VA(I,J,K) + XNUU(I,J,INEST)*aux4                     23DEC04.1424
>               UB(I,J,K) = aux2                                                   23DEC04.1425
>               VB(I,J,K) = aux4                                                   23DEC04.1426
>   200       CONTINUE                                                             23DEC04.1427
>           ENDDO                                                                  23DEC04.1428
>         ENDIF                                                                    23DEC04.1429
>         IF(J.LE.M)THEN                                                           23DEC04.1430
>           DO K=1,N                                                               23DEC04.1431
>             DO 202 I=1,L                                                         23DEC04.1432
>               aux2 = XMUT(I,J,INEST)                                             23DEC04.1433
>               aux4 = PPB(I,J,K)                                                  23DEC04.1434
>               aux6 = aux4 * XNUT(I,J,INEST)                                      23DEC04.1435
>                                                                                  23DEC04.1436
>               PPTENS(I,J,K)=PPTENS(I,J,K)*DTS                                    23DEC04.1437
>               QV3D(I,J,K)=QVB(I,J,K)*RPSA(I,J)                                   23DEC04.1438
>               PP3D(I,J,K)=aux4 * RPSA(I,J)                                       23DEC04.1439
>               aux4 = XMUT(I,J,INEST)*PPA(I,J,K) + aux6                           23DEC04.1440
>               PPB(I,J,K) = aux4                                                  23DEC04.1441
>   202       CONTINUE                                                             23DEC04.1442
>           ENDDO                                                                  23DEC04.1443
>           DO K=1,NP1                                                             23DEC04.1444
>             DO 204 I=1,L                                                         23DEC04.1445
>               aux4 = WB(I,J,K)                                                   23DEC04.1446
>               aux6 = XNUT(I,J,INEST)*aux4                                        23DEC04.1447
>               WTENS(I,J,K)=WTENS(I,J,K)*DTS                                      23DEC04.1448
>               W3D(I,J,K)= aux4*RPSA(I,J)                                         23DEC04.1449
>               aux4=XMUT(I,J,INEST)*WA(I,J,K) +  aux6                             23DEC04.1450
>               WB(I,J,K) = aux4                                                   23DEC04.1451
>                                                                                  23DEC04.1452
>   204       CONTINUE                                                             23DEC04.1453
>           ENDDO                                                                  23DEC04.1454
>         ENDIF                                                                    23DEC04.1455
>       ENDDO                                                                      23DEC04.1456
> c                                                                                23DEC04.1457
> c     miter step                                                                 23DEC04.1458
> c                                                                                23DEC04.1459
>       DO 700 IT=1,ISTEP                                                          23DEC04.1460
>                                                                                  23DEC04.1461
>         ITL=MAX0(KTAU-1,0)                                                       23DEC04.1462
>         IF(IT.EQ.1)GOTO 311                                                      23DEC04.1463
> cmic$ do all autoscope                                                           23DEC04.1464
> c$doacross                                                                       23DEC04.1465
> c$& local(k,j,i)                                                                 23DEC04.1466
> c$omp parallel do default(shared)                                                23DEC04.1467
> c$omp&private(k,j,i,aux2,aux4)                                                   23DEC04.1468
>         DO J=1,JXX                                                               23DEC04.1469
>           IF(J.GE.JSTART.AND.J.LE.JEND)THEN                                      23DEC04.1470
>             DO K=1,N                                                             23DEC04.1471
>               DO 310 I=ISTART,IEND                                               23DEC04.1472
>                 PP3D(I,J,K) = PP3D(I,J,K) + XKD*PI(I,J,K)                        23DEC04.1473
>   310         CONTINUE                                                           23DEC04.1474
>             ENDDO                                                                23DEC04.1475
>           ENDIF                                                                  23DEC04.1476
>         ENDDO                                                                    23DEC04.1477
>   311   CONTINUE                                                                 23DEC04.1478
>                                                                                  23DEC04.1479
>                                                                                  23DEC04.1480
> cmic$ do all autoscope                                                           23DEC04.1481
> cmic$1 shared  (l,m,n,icut,pp3d,pr0,t3d)                                         23DEC04.1482
> cmic$2 private (i,j,k,kp1,km1)                                                   23DEC04.1483
> c$doacross                                                                       23DEC04.1484
> c$& local(i,j,k,kp1,km1)                                                         23DEC04.1485
> c$omp parallel do default(shared)                                                23DEC04.1486
> c$omp&private(i,j,k,kp1,km1)                                                     23DEC04.1487
>         DO J=1,JXX                                                               23DEC04.1488
>           IF(J.GE.1+ICUT.AND.J.LE.M-ICUT)THEN                                    23DEC04.1489
>             DO K=2,N-1                                                           23DEC04.1490
>               KP1=K+1                                                            23DEC04.1491
>               KM1=K-1                                                            23DEC04.1492
>                                                                                  23DEC04.1493
>               DO I=1+ICUT,L-ICUT                                                 23DEC04.1494
>                 T3D(I,J,K)=(PP3D(I,J,KM1)-PP3D(I,J,KP1))*rP2(I,J,K)              23DEC04.1495
>               ENDDO                                                              23DEC04.1496
>             ENDDO                                                                23DEC04.1497
>                                                                                  23DEC04.1498
>               DO I=1+ICUT,L-ICUT                                                 23DEC04.1499
>                 T3D(I,J,1)=(PP3D(I,J,1)-PP3D(I,J,2))*rP2(I,J,1)                  23DEC04.1500
>                 T3D(I,J,n)=(PP3D(I,J,n-1)-PP3D(I,J,n))*rP2(I,J,n)                23DEC04.1501
>               end do                                                             23DEC04.1502
>                                                                                  23DEC04.1503
>           ENDIF                                                                  23DEC04.1504
>         ENDDO                                                                    23DEC04.1505
> #ifdef MPP1                                                                      23DEC04.1506
> #  include <mpp_sound_20.incl>                                                   23DEC04.1507
> #endif                                                                           23DEC04.1508
> C                                                                                23DEC04.1509
> C  ADVANCE U AND V                                                               23DEC04.1510
> C                                                                                23DEC04.1511
> cmic$ do all autoscope                                                           23DEC04.1512
> cmic$1 shared  (pp3d,pr0,rho1,msfd,u3d,v3d,dx,dts,t3d)                           23DEC04.1513
> cmic$2 private (kp1,km1,rho,chh,dppdp0)                                          23DEC04.1514
> c$doacross                                                                       23DEC04.1515
> c$& local(i,j,k,rho,chh,dppdp0)                                                  23DEC04.1516
> c$omp parallel do default(shared)                                                23DEC04.1517
> c$omp&private(i,j,k,rho,chh,dppdp0,tmp,aux2,aux4,                                23DEC04.1518
> c$omp&        aux6,aux8,aux0)                                                    23DEC04.1519
>         DO J=1,JXX                                                               23DEC04.1520
>           IF(J.GE.2+ICUT.AND.J.LE.M-ICUT)THEN                                    23DEC04.1521
>             DO K=1,N                                                             23DEC04.1522
>               DO I=2+ICUT,L-ICUT                                                 23DEC04.1523
>                 tmp(i,1)=0.25*(RHO1(I,J,K)+RHO1(I,J-1,K)+RHO1(I-1,J,K)+          23DEC04.1524
>      +              RHO1(I-1,J-1,K))                                             23DEC04.1525
>               end do                                                             23DEC04.1526
>                                                                                  23DEC04.1527
>               DO I=2+ICUT,L-ICUT                                                 23DEC04.1528
>                 tmp(i,2) =   T3D(I,J-1,K)  + T3D(I-1,J-1,K)                      23DEC04.1529
>                 tmp(i,3) = - PP3D(I,J-1,K) - PP3D(I-1,J-1,K)                     23DEC04.1530
>                 tmp(i,4) = - PR0(I,J-1,K)  - PR0(I-1,J-1,K)                      23DEC04.1531
>                 tmp(i,5) =   PR0(I,J-1,K)  - PR0(I-1,J-1,K)                      23DEC04.1532
>                 tmp(i,6) =   PP3D(I,J-1,K) - PP3D(I-1,J-1,K)                     23DEC04.1533
>               end do                                                             23DEC04.1534
>                                                                                  23DEC04.1535
>             call vsrec(tmp(nf(is3),1),tmp(nf(is3),1),nn3)                        23DEC04.1536
>                                                                                  23DEC04.1537
>               DO  I=2+ICUT,L-ICUT                                                23DEC04.1538
>                   aux2 = T3D(I,J,K)  + T3D(I-1,J,K)                              23DEC04.1539
>                   aux4 = PP3D(I,J,K) + PP3D(I-1,J,K)                             23DEC04.1540
>                   aux6 = PR0(I,J,K)  + PR0(I-1,J,K)                              23DEC04.1541
>                   aux8 = PP3D(I,J,K) - PP3D(I-1,J,K)                             23DEC04.1542
>                   aux0 = PR0(I,J,K)  - PR0(I-1,J,K)                              23DEC04.1543
>                                                                                  23DEC04.1544
>                 CHH= dtsx1 *rMSFD(I,J) * tmp(i,1)                                23DEC04.1545
>                                                                                  23DEC04.1546
>                 DPPDP0=0.25*(tmp(i,2)+aux2)                                      23DEC04.1547
>                                                                                  23DEC04.1548
>                 U3D(I,J,K) = U3D(I,J,K)                                          23DEC04.1549
>      +                      -CHH*(aux4 + tmp(i,3)                                23DEC04.1550
>      +                      -(aux6 + tmp(i,4))*DPPDP0)                           23DEC04.1551
>                                                                                  23DEC04.1552
>                 V3D(I,J,K) = V3D(I,J,K)                                          23DEC04.1553
>      +                      -CHH*(aux8 + tmp(i,6)                                23DEC04.1554
>      +                      -(aux0 + tmp(i,5)) *DPPDP0)                          23DEC04.1555
>               end do                                                             23DEC04.1556
>             ENDDO                                                                23DEC04.1557
>           ENDIF                                                                  23DEC04.1558
>         ENDDO                                                                    23DEC04.1559
>                                                                                  23DEC04.1560
> cmic$ do all autoscope                                                           23DEC04.1561
> cmic$1 shared  (lp1,mp1,n,u3d,v3d,utens,vtens)                                   23DEC04.1562
> cmic$2 private (i,j,k,aux2,aux4)                                                 23DEC04.1563
> c$doacross                                                                       23DEC04.1564
> c$& local(i,j,k)                                                                 23DEC04.1565
> c$omp parallel do default(shared)                                                23DEC04.1566
> c$omp&private(i,j,k)                                                             23DEC04.1567
>         DO J=1,JXX                                                               23DEC04.1568
>           IF(J.LE.MP1)THEN                                                       23DEC04.1569
>             DO K=1,N                                                             23DEC04.1570
>               DO 360 I=1,LP1                                                     23DEC04.1571
>                  U3D(I,J,K) = U3D(I,J,K) + UTENS(I,J,K)                          23DEC04.1572
>                  V3D(I,J,K) = V3D(I,J,K) + VTENS(I,J,K)                          23DEC04.1573
>   360         CONTINUE                                                           23DEC04.1574
>             ENDDO                                                                23DEC04.1575
>           ENDIF                                                                  23DEC04.1576
>         ENDDO                                                                    23DEC04.1577
> C                                                                                23DEC04.1578
>         IF(IT.EQ.1)GOTO 321                                                      23DEC04.1579
> cmic$ do all autoscope                                                           23DEC04.1580
> c$doacross                                                                       23DEC04.1581
> c$& local(k,j,i)                                                                 23DEC04.1582
> c$omp parallel do default(shared)                                                23DEC04.1583
> c$omp&private(k,j,i,aux2,aux4)                                                   23DEC04.1584
>         DO J=1,JXX                                                               23DEC04.1585
>           IF(J.GE.JSTART.AND.J.LE.JEND)THEN                                      23DEC04.1586
>             DO K=1,N                                                             23DEC04.1587
>               DO 320 I=ISTART,IEND                                               23DEC04.1588
>                  PP3D(I,J,K) = PP3D(I,J,K) - XKD * PI(I,J,K)                     23DEC04.1589
>   320         CONTINUE                                                           23DEC04.1590
>             ENDDO                                                                23DEC04.1591
>           ENDIF                                                                  23DEC04.1592
>         ENDDO                                                                    23DEC04.1593
>   321   CONTINUE                                                                 23DEC04.1594
>                                                                                  23DEC04.1595
> #ifdef MPP1                                                                      23DEC04.1596
> #  include <mpp_sound_30.incl>                                                   23DEC04.1597
> #endif                                                                           23DEC04.1598
> C                                                                                23DEC04.1599
> C  SEMI-IMPLICIT SOLUTION FOR W AND P                                            23DEC04.1600
> C                                                                                23DEC04.1601
> cmic$ do all autoscope                                                           23DEC04.1602
> cmic$1 shared  (psa,pp3d,xmut,xnut,tb)                                           23DEC04.1603
> cmic$2 private (kp1,km1,tk)                                                      23DEC04.1604
> cmic$2 private(rhs,wo,aa,b,c,ca,cc,cdd,cj,pyvp,pxup,ptend,g1,g2)                 23DEC04.1605
> c$doacross                                                                       23DEC04.1606
> c$& local(i,j,k,kp1,km1,wo,cc,cdd,cj,pyvp,ptend,rofac,                           23DEC04.1607
> c$& tk,ca,g1,g2,c,b,aa,rhs,denom,pxup)                                           23DEC04.1608
> c$omp parallel do default(shared)                                                23DEC04.1609
> c$omp&private(i,j,k,kp1,km1,wo,cc,cdd,cj,pyvp,ptend,rofac,rrr,rr1,               23DEC04.1610
> c$omp&tk,ca,g1,g2,c,b,aa,rhs,denom,pxup,tmp,aux2,aux4,                           23DEC04.1611
> c$omp&     aux6,aux8,aux0)                                                       23DEC04.1612
>         DO J=1,JXX                                                               23DEC04.1613
>           IF(J.GE.JSTART.AND.J.LE.JEND)THEN                                      23DEC04.1614
>             DO K=1,NP1                                                           23DEC04.1615
>               DO I=2,L-1                                                         23DEC04.1616
>                 WO(I,K)=W3D(I,J,K)                                               23DEC04.1617
>               ENDDO                                                              23DEC04.1618
>             ENDDO                                                                23DEC04.1619
>                                                                                  23DEC04.1620
>           do k=1,n                                                               23DEC04.1621
>              do i=istart,iend                                                    23DEC04.1622
>                 CC(I,K)= dtsx3 * PR1(I,J,K) * rMSFX(I,J)                         23DEC04.1623
>                 CDD(I,K)= PR1(I,J,K)*RHO0(I,J,K) *rPS0(I,J)*                     23DEC04.1624
>      +                   (dtsx4 * DSIGMAi(K))                                    23DEC04.1625
>                 CJ(I,K)=RHO0(I,J,K)* dtsx5                                       23DEC04.1626
>                 tmp(i,1) = (2.*GAMMA)*PR0(I,J,K)* TB(I,J,K) * RPSA(I,J)          23DEC04.1627
>              end do                                                              23DEC04.1628
>                                                                                  23DEC04.1629
>              call vsrec(tmp(nf(is2),1),tmp(nf(is2),1),nn)                        23DEC04.1630
>                                                                                  23DEC04.1631
>               DO  I=ISTART,IEND                                                  23DEC04.1632
>                 TK(I,K)=PS0(I,J)*T0(I,J,K) * tmp(i,1)                            23DEC04.1633
>               end do                                                             23DEC04.1634
>                                                                                  23DEC04.1635
>           end do                                                                 23DEC04.1636
>                                                                                  23DEC04.1637
>           do k=2,n                                                               23DEC04.1638
>              DO I=ISTART,IEND                                                    23DEC04.1639
>                 tmp(i,1) =                                                       23DEC04.1640
>      *            DSIGMA(K-1)*RHO1(I,J,K)+DSIGMA(K)*RHO1(I,J,K-1)                23DEC04.1641
>              end do                                                              23DEC04.1642
>                                                                                  23DEC04.1643
>              call vsrec(tmp(nf(is2),1),tmp(nf(is2),1),nn)                        23DEC04.1644
>                                                                                  23DEC04.1645
>              DO I=ISTART,IEND                                                    23DEC04.1646
>                 G1(I,K)=1.-DSIGMA(K-1)*TK(I,K)                                   23DEC04.1647
>                 G2(I,K)=1.+DSIGMA(K)*TK(I,K-1)                                   23DEC04.1648
>                 rr1 = - rp1(i,j,k-1)                                             23DEC04.1649
>                 ROFAC=(DSIGMA(K-1)*RHO0(I,J,K)+DSIGMA(K)*RHO0(I,J,K-1))          23DEC04.1650
>      *                * tmp(i,1)                                                 23DEC04.1651
>                                                                                  23DEC04.1652
>                 aux0 = rr1 * (G*DTS) * ROFAC                                     23DEC04.1653
>                 aux2 = CDD(I,K-1) - CJ(I,K-1)                                    23DEC04.1654
>                 aux4 = CDD(I,K)   - CJ(I,K)                                      23DEC04.1655
>                 aux6 = CDD(I,K)   + CJ(I,K)                                      23DEC04.1656
>                 aux8 = CDD(I,K-1) + CJ(I,K-1)                                    23DEC04.1657
> C                                                                                23DEC04.1658
> C      IMPLICIT W EQUATION COEFFICIENT ARRAYS AND RHS (IKAWA METHOD)             23DEC04.1659
> C                                                                                23DEC04.1660
>                 C(I,K) = - (aux0*BPXBP)*aux2 * G2(I,K)                           23DEC04.1661
>                 B(I,K) = 1.+ (aux0*BPXBP)*(G1(I,K)*aux4+G2(I,K)*aux8)            23DEC04.1662
>                 AA(I,K)= - (aux0*BPXBP) * aux6 * G1(I,K)                         23DEC04.1663
>                 ca(i,k) = aux0                                                   23DEC04.1664
>               end do                                                             23DEC04.1665
>             end do                                                               23DEC04.1666
> C                                                                                23DEC04.1667
> C     VERTICAL BOUNDARY CONDITIONS, W=V.DH/DY AT BOTTOM, LID AT TOP              23DEC04.1668
> C                                                                                23DEC04.1669
>             DO I=ISTART,IEND                                                     23DEC04.1670
>                tmp(i,2) = V3D(I+1,J+1,N) + V3D(I,J+1,N)                          23DEC04.1671
>                tmp(i,3) = U3D(I+1,J+1,N) + U3D(I,J+1,N)                          23DEC04.1672
>                tmp(i,4) = HT(I,J+1)      - HT(I,J-1)                             23DEC04.1673
>             end do                                                               23DEC04.1674
>                                                                                  23DEC04.1675
>             DO I=ISTART,IEND                                                     23DEC04.1676
>                aux2 = V3D(I+1,J,N) + V3D(I,J,N)                                  23DEC04.1677
>                aux4 = HT(I+1,J)    - HT(I-1,J)                                   23DEC04.1678
>                aux6 = U3D(I+1,J,N) + U3D(I,J,N)                                  23DEC04.1679
>                                                                                  23DEC04.1680
>                W3D(I,J,NP1)=rMSFX(I,J)* dtsx2*                                   23DEC04.1681
>      +                       ((aux2 + tmp(i,2)) * aux4                           23DEC04.1682
>      +                     + (aux6 +  tmp(i,3)) * tmp(i,4))                      23DEC04.1683
>                                                                                  23DEC04.1684
>               E(I,J,N)=0.                                                        23DEC04.1685
>               F(I,J,N)=W3D(I,J,NP1)                                              23DEC04.1686
>             end do                                                               23DEC04.1687
> C                                                                                23DEC04.1688
>             DO I=ISTART,IEND                                                     23DEC04.1689
>                tmp(i,1) = V3D(I,J,1) + V3D(I+1,J,1)                              23DEC04.1690
>      +                   -V3D(I,J,2) - V3D(I+1,J,2)                              23DEC04.1691
>                tmp(i,2) = U3D(I,J,1) + U3D(I+1,J,1)                              23DEC04.1692
>      +                   -U3D(I,J,2) - U3D(I+1,J,2)                              23DEC04.1693
>             end do                                                               23DEC04.1694
>                                                                                  23DEC04.1695
>             DO I=ISTART,IEND                                                     23DEC04.1696
>                tmp(i,3) = V3D(I,J+1,1)+V3D(I+1,J+1,1)                            23DEC04.1697
>      +                   -V3D(I,J+1,2)-V3D(I+1,J+1,2)                            23DEC04.1698
>                tmp(i,4) = U3D(I,J+1,1)+U3D(I+1,J+1,1)                            23DEC04.1699
>      +                   -U3D(I,J+1,2)-U3D(I+1,J+1,2)                            23DEC04.1700
>             end do                                                               23DEC04.1701
>                                                                                  23DEC04.1702
>             DO I=ISTART,IEND                                                     23DEC04.1703
>                 rrr =  rp1(I,J,1)                                                23DEC04.1704
>                 aux2 = (0.0625*rrr) * (PR0(I+1,J,1)-PR0(I-1,J,1))                23DEC04.1705
>                 aux4 = (0.0625*rrr) * (PR0(I,J+1,1)-PR0(I,J-1,1))                23DEC04.1706
> c                                                                                23DEC04.1707
>                 PYVP(I,1) = aux2 * ( tmp(i,1) + tmp(i,3))                        23DEC04.1708
>                 PXUP(I,1) = aux4 * ( tmp(i,2) + tmp(i,4))                        23DEC04.1709
> c                                                                                23DEC04.1710
>             end do                                                               23DEC04.1711
>                                                                                  23DEC04.1712
>               DO I=ISTART,IEND                                                   23DEC04.1713
>                  tmp(i,1) = -(V3D(I,J+1,1)-U3D(I,J+1,1))    *MSFD(I,J+1)         23DEC04.1714
>                  tmp(i,2) =(V3D(I+1,J+1,1)+U3D(I+1,J+1,1))*MSFD(I+1,J+1)         23DEC04.1715
>               end do                                                             23DEC04.1716
> c                                                                                23DEC04.1717
>               DO I=ISTART,IEND                                                   23DEC04.1718
>                 aux2 = (V3D(I+1,J,1)-U3D(I+1,J,1))    *MSFD(I+1,J)               23DEC04.1719
>                 aux4 = (V3D(I,J,1)  +U3D(I,J,1))      *MSFD(I,J)                 23DEC04.1720
> c                                                                                23DEC04.1721
>                 PTEND(I,1)=PPTENS(I,J,1)-0.5*CC(I,1)*(                           23DEC04.1722
>      +                   (aux2 - aux4 + tmp(i,1) + tmp(i,2)                      23DEC04.1723
>      +                    )*rMSFX(I,J)  -2.*(PYVP(I,1)+PXUP(I,1)))               23DEC04.1724
>                                                                                  23DEC04.1725
>               ENDDO                                                              23DEC04.1726
>                                                                                  23DEC04.1727
>             DO K=2,N-1                                                           23DEC04.1728
>               KP1=K+1                                                            23DEC04.1729
>               KM1=K-1                                                            23DEC04.1730
>               DO I=ISTART,IEND                                                   23DEC04.1731
>                  tmp(i,1) = V3D(I,J,KM1)+V3D(I+1,J,KM1)                          23DEC04.1732
>      +                     -V3D(I,J,KP1)-V3D(I+1,J,KP1)                          23DEC04.1733
>                  tmp(i,2) = U3D(I,J,KM1)+U3D(I+1,J,KM1)                          23DEC04.1734
>      +                     -U3D(I,J,KP1)-U3D(I+1,J,KP1)                          23DEC04.1735
>               end do                                                             23DEC04.1736
>               DO I=ISTART,IEND                                                   23DEC04.1737
>                  tmp(i,3) = V3D(I,J+1,KM1)+V3D(I+1,J+1,KM1)                      23DEC04.1738
>      +                     -V3D(I,J+1,KP1)-V3D(I+1,J+1,KP1)                      23DEC04.1739
>                  tmp(i,4) = U3D(I,J+1,KM1)+U3D(I+1,J+1,KM1)                      23DEC04.1740
>      +                     -U3D(I,J+1,KP1)-U3D(I+1,J+1,KP1)                      23DEC04.1741
>               end do                                                             23DEC04.1742
>                                                                                  23DEC04.1743
>               DO I=ISTART,IEND                                                   23DEC04.1744
>                 rrr =  rp2(I,J,k)                                                23DEC04.1745
>                 aux2 = (0.125*rrr) * (PR0(I+1,J,K)-PR0(I-1,J,K))                 23DEC04.1746
>                 aux4 = (0.125*rrr) * (PR0(I,J+1,K)-PR0(I,J-1,K))                 23DEC04.1747
> c                                                                                23DEC04.1748
>                 PYVP(I,K) = aux2 * ( tmp(i,1) + tmp(i,3))                        23DEC04.1749
>                 PXUP(I,K) = aux4 * ( tmp(i,2) + tmp(i,4))                        23DEC04.1750
> c                                                                                23DEC04.1751
>               end do                                                             23DEC04.1752
>             end do                                                               23DEC04.1753
>                                                                                  23DEC04.1754
>                                                                                  23DEC04.1755
>             k=n                                                                  23DEC04.1756
>             KP1=k                                                                23DEC04.1757
>             KM1=K-1                                                              23DEC04.1758
>                                                                                  23DEC04.1759
>             DO I=ISTART,IEND                                                     23DEC04.1760
>                tmp(i,1) = V3D(I,J,KM1)+V3D(I+1,J,KM1)                            23DEC04.1761
>      +                   -V3D(I,J,KP1)-V3D(I+1,J,KP1)                            23DEC04.1762
>                tmp(i,2) = U3D(I,J,KM1)+U3D(I+1,J,KM1)                            23DEC04.1763
>      +                   -U3D(I,J,KP1)-U3D(I+1,J,KP1)                            23DEC04.1764
>             end do                                                               23DEC04.1765
>             DO I=ISTART,IEND                                                     23DEC04.1766
>                tmp(i,3) = V3D(I,J+1,KM1)+V3D(I+1,J+1,KM1)                        23DEC04.1767
>      +                   -V3D(I,J+1,KP1)-V3D(I+1,J+1,KP1)                        23DEC04.1768
>                tmp(i,4) = U3D(I,J+1,KM1)+U3D(I+1,J+1,KM1)                        23DEC04.1769
>      +                   -U3D(I,J+1,KP1)-U3D(I+1,J+1,KP1)                        23DEC04.1770
>             end do                                                               23DEC04.1771
>                                                                                  23DEC04.1772
>             DO I=ISTART,IEND                                                     23DEC04.1773
>                 rrr = rp2(i,j,k)                                                 23DEC04.1774
>                 aux2 = (0.0625*rrr) * (PR0(I+1,J,K)-PR0(I-1,J,K))                23DEC04.1775
>                 aux4 = (0.0625*rrr) * (PR0(I,J+1,K)-PR0(I,J-1,K))                23DEC04.1776
> c                                                                                23DEC04.1777
>                 PYVP(I,K) = aux2 * ( tmp(i,1) + tmp(i,3))                        23DEC04.1778
>                 PXUP(I,K) = aux4 * ( tmp(i,2) + tmp(i,4))                        23DEC04.1779
>             end do                                                               23DEC04.1780
>                                                                                  23DEC04.1781
> C                                                                                23DEC04.1782
> C      ZERO GRADIENT (FREE SLIP) B.C.S ON V AT TOP AND BOTTOM                    23DEC04.1783
> C                                                                                23DEC04.1784
>             DO K=2,N                                                             23DEC04.1785
>               DO I=ISTART,IEND                                                   23DEC04.1786
>                  tmp(i,1) = -(V3D(I,J+1,K)-U3D(I,J+1,K))    *MSFD(I,J+1)         23DEC04.1787
>                  tmp(i,2) =(V3D(I+1,J+1,K)+U3D(I+1,J+1,K))*MSFD(I+1,J+1)         23DEC04.1788
>               end do                                                             23DEC04.1789
>                                                                                  23DEC04.1790
>               DO I=ISTART,IEND                                                   23DEC04.1791
>                 aux2 = (V3D(I+1,J,K)-U3D(I+1,J,K))    *MSFD(I+1,J)               23DEC04.1792
>                 aux4 = (V3D(I,J,K)  +U3D(I,J,K))      *MSFD(I,J)                 23DEC04.1793
>                                                                                  23DEC04.1794
>                 PTEND(I,K)=PPTENS(I,J,K)-0.5*CC(I,K)*(                           23DEC04.1795
>      +                   (aux2 - aux4 + tmp(i,1) + tmp(i,2)                      23DEC04.1796
>      +                    )*rMSFX(I,J)  -2.*(PYVP(I,K)+PXUP(I,K)))               23DEC04.1797
>                                                                                  23DEC04.1798
>               end do                                                             23DEC04.1799
>                                                                                  23DEC04.1800
>               DO I=ISTART,IEND                                                   23DEC04.1801
>                  tmp(i,1) = (CDD(I,K-1) - CJ(I,K-1))*WO(I,K-1)                   23DEC04.1802
>                  tmp(i,2) =  CDD(I,K-1) + CJ(I,K-1)                              23DEC04.1803
>               end do                                                             23DEC04.1804
>                                                                                  23DEC04.1805
>               DO I=ISTART,IEND                                                   23DEC04.1806
>                  aux2 = G1(I,K)                                                  23DEC04.1807
>                  aux4 = G2(I,K)                                                  23DEC04.1808
>                  aux6 = CDD(I,K)-CJ(I,K)                                         23DEC04.1809
>                  aux8 = (CDD(I,K)+CJ(I,K)) * WO(I,K+1)                           23DEC04.1810
>                  RHS(I,K)=W3D(I,J,K)+WTENS(I,J,K)                                23DEC04.1811
>      +                     +CA(I,K)*(BPXBM*(                                     23DEC04.1812
>      +                       tmp(i,1)*aux4                                       23DEC04.1813
>      +                     -(tmp(i,2)*aux4                                       23DEC04.1814
>      +                      + aux6*aux2)*WO(I,K)                                 23DEC04.1815
>      +                      +aux8 * aux2)                                        23DEC04.1816
>      +                   +(PP3D(I,J,K)*aux2-PP3D(I,J,K-1)*aux4)                  23DEC04.1817
>      +                   +(aux2*PTEND(I,K)-aux4*PTEND(I,K-1))*BP)                23DEC04.1818
>               end do                                                             23DEC04.1819
>             end do                                                               23DEC04.1820
> C                                                                                23DEC04.1821
>             DO 110 K=1,N                                                         23DEC04.1822
>               DO 110 I=ISTART,IEND                                               23DEC04.1823
>                 PI(I,J,K)=PP3D(I,J,K)                                            23DEC04.1824
>                 PP3D(I,J,K)=PP3D(I,J,K)+PTEND(I,K)+(CJ(I,K)*(WO(I,K+1)+          23DEC04.1825
>      +                      WO(I,K))+CDD(I,K)*(WO(I,K+1)-WO(I,K)))*BM            23DEC04.1826
>   110         CONTINUE                                                           23DEC04.1827
>                                                                                  23DEC04.1828
> C                                                                                23DEC04.1829
> C     UPWARD CALCULATION OF COEFFICIENTS                                         23DEC04.1830
> C                                                                                23DEC04.1831
>             DO 5 K=N,2,-1                                                        23DEC04.1832
>               DO I=ISTART,IEND                                                   23DEC04.1833
>                 tmp(i,1) = AA(I,K)*E(I,J,K)+B(I,K)                               23DEC04.1834
>               end do                                                             23DEC04.1835
>                                                                                  23DEC04.1836
>               call vsrec(tmp(nf(is2),1),tmp(nf(is2),1),nn)                       23DEC04.1837
>                                                                                  23DEC04.1838
>               DO I=ISTART,IEND                                                   23DEC04.1839
>                 E(I,J,K-1)=-C(I,K)*tmp(i,1)                                      23DEC04.1840
>                 F(I,J,K-1)=(RHS(I,K)-F(I,J,K)*AA(I,K))*tmp(i,1)                  23DEC04.1841
>               end do                                                             23DEC04.1842
>     5         CONTINUE                                                           23DEC04.1843
>                                                                                  23DEC04.1844
> C                                                                                23DEC04.1845
>             DO 400 I=ISTART,IEND                                                 23DEC04.1846
>               DENOM=(CDD(I,1)+CJ(I,1))*BP                                        23DEC04.1847
>               ESTORE(I,J)=PP3D(I,J,1)+F(I,J,1)*DENOM                             23DEC04.1848
>               ASTORE(I,J)=DENOM*E(I,J,1)+(CJ(I,1)-CDD(I,1))*BP                   23DEC04.1849
>   400       CONTINUE                                                             23DEC04.1850
>           ENDIF                                                                  23DEC04.1851
>         ENDDO                                                                    23DEC04.1852
> C                                                                                23DEC04.1853
> C IF FIRST TIME THROUGH AND UPPER RADIATION B.C`S ARE USED                       23DEC04.1854
> C NEED TO CALC SOME COEFFICIENTS                                                 23DEC04.1855
> C                                                                                23DEC04.1856
>         IF(IFUPR.EQ.1.AND.KTAU.EQ.0.AND.IT.EQ.1)THEN                             23DEC04.1857
> C         PRINT *,' CALCULATING MEANS FOR UP. RAD. B.C.'                         23DEC04.1858
>           ATOT=0.                                                                23DEC04.1859
>           RHONTOT=0.                                                             23DEC04.1860
>           XMSFTOT=0.                                                             23DEC04.1861
>           NPTS=0                                                                 23DEC04.1862
> #ifndef MPP1                                                                     23DEC04.1863
>           DO 401 J=JSTART,JEND                                                   23DEC04.1864
>             DO 401 I=ISTART,IEND                                                 23DEC04.1865
>               ATOT=ATOT+ASTORE(I,J)                                              23DEC04.1866
>               ENSQ=G*G/(CP*(TB(I,J,1)*RPSA(I,J)))                                23DEC04.1867
> c                                                                                23DEC04.1868
>               RHONTOT=RHONTOT+RHO1(I,J,1)*SQRT(ENSQ)                             23DEC04.1869
>               XMSFTOT=XMSFTOT+MSFX(I,J)                                          23DEC04.1870
>   401       CONTINUE                                                             23DEC04.1871
>                                                                                  23DEC04.1872
>           NPTS=(IEND-ISTART+1)*(JEND-JSTART+1)                                   23DEC04.1873
>           rnpts =1./NPTS                                                         23DEC04.1874
>           ABAR=ATOT*rNPTS                                                        23DEC04.1875
>           RHON=RHONTOT*rNPTS                                                     23DEC04.1876
>           XMSFBAR=XMSFTOT*rNPTS                                                  23DEC04.1877
> #else                                                                            23DEC04.1878
> #  include <mpp_sound_40.incl>                                                   23DEC04.1879
> #endif                                                                           23DEC04.1880
>           CPI=4.*ATAN(1.)                                                        23DEC04.1881
>           cpi12=cpi/12.                                                          23DEC04.1882
>                                                                                  23DEC04.1883
>           DXMSFB=2./(DX*XMSFBAR)                                                 23DEC04.1884
> C                                                                                23DEC04.1885
>           DO 4 LL=0,6                                                            23DEC04.1886
>             DO 4 K=0,6                                                           23DEC04.1887
>               xkeff = sin(cpi12*k)  * cos(cpi12*ll)                              23DEC04.1888
>               xleff = sin(cpi12*ll) * cos(cpi12*k)                               23DEC04.1889
>               xkleff=dxmsfb*sqrt(xkeff*xkeff+xleff*xleff)                        23DEC04.1890
>               rrr = FK(K)*FL(LL)/144.                                            23DEC04.1891
>               aux2 = 2*k * cpi12                                                 23DEC04.1892
>               aux4 = 2*ll* cpi12                                                 23DEC04.1893
> c              XKEFF=DXMSFB*SIN(CPI*K/12.)*COS(CPI*LL/12.)                       23DEC04.1894
> c              XLEFF=DXMSFB*SIN(CPI*LL/12.)*COS(CPI*K/12.)                       23DEC04.1895
> c              XKLEFF=SQRT(XKEFF*XKEFF+XLEFF*XLEFF)                              23DEC04.1896
>               XKLEFF = XKLEFF/(RHON-ABAR*XKLEFF)                                 23DEC04.1897
> cmic$ do all autoscope                                                           23DEC04.1898
> c$doacross                                                                       23DEC04.1899
> c$& local(i,j)                                                                   23DEC04.1900
> c$omp parallel do default(shared)                                                23DEC04.1901
> c$omp&private(i,j,rr1)                                                           23DEC04.1902
>               DO 8 J=-6,6                                                        23DEC04.1903
>                  rr1 = rrr * FJ(J)                                               23DEC04.1904
>                  DO 8 I=-6,6                                                     23DEC04.1905
> c                  TMASK(I,J)=TMASK(I,J)+FI(I)*FJ(J)*FK(K)*FL(LL)/144.*          23DEC04.1906
> c     +                       COS(2.*CPI*K*I/12.)*COS(2.*CPI*LL*J/12.)*          23DEC04.1907
> c     +                       XKLEFF                                             23DEC04.1908
>                     TMASK(I,J)=TMASK(I,J) + rr1 * FI(I) * XKLEFF *               23DEC04.1909
>      +                         COS(aux2*I)*COS(aux4*J)                           23DEC04.1910
>                                                                                  23DEC04.1911
>     8           CONTINUE                                                         23DEC04.1912
>     4       CONTINUE                                                             23DEC04.1913
>                                                                                  23DEC04.1914
> C         PRINT2002,ABAR,RHON                                                    23DEC04.1915
> C         DO 9 J=0,6                                                             23DEC04.1916
> C           PRINT2001,(DX*XMSFBAR*TMASK(I,J),I=0,6)                              23DEC04.1917
>  2001       FORMAT (1X,7F10.5)                                                   23DEC04.1918
>  2002 FORMAT(1X,'ABAR = ',F10.5,' RHON = ',E12.5,//,1X,' TMASK ')                23DEC04.1919
> C   9     CONTINUE                                                               23DEC04.1920
>         ENDIF                                                                    23DEC04.1921
>                                                                                  23DEC04.1922
> #ifdef MPP1                                                                      23DEC04.1923
> #  include <mpp_sound_50.incl>                                                   23DEC04.1924
> #endif                                                                           23DEC04.1925
> C                                                                                23DEC04.1926
> C  FINISHED INITIAL COEFFICIENT COMPUTE                                          23DEC04.1927
> C  NOW DO DOWNWARD SWEEP FOR W                                                   23DEC04.1928
> C                                                                                23DEC04.1929
> cmic$ do all autoscope                                                           23DEC04.1930
> cmic$1 shared  (rho1,rho0,insi,jnsj,wtij)                                        23DEC04.1931
> cmic$2 private(wpval)                                                            23DEC04.1932
> c$doacross                                                                       23DEC04.1933
> c$& local(i,j,k,cdd,cj,wpval,cfl,rho0s,ucrs,vcrs,                                23DEC04.1934
> c$&       check,sigdot,nsj,nsi,in,jn)                                            23DEC04.1935
> c$omp parallel do default(shared)                                                23DEC04.1936
> c$omp&private(i,j,k,cdd,cj,wpval,cfl,rho0s,ucrs,vcrs,check,sigdot,               23DEC04.1937
> c$omp&nsj,nsi,in,jn,tmp,aux2,aux4)                                               23DEC04.1938
>         DO 120 J=1,JXX                                                           23DEC04.1939
>           IF(J.GE.JSTART.AND.J.LE.JEND)THEN                                      23DEC04.1940
> C                                                                                23DEC04.1941
> C  FIRST, SET UPPER BOUNDARY CONDITION, EITHER W=0 OR RADIATION                  23DEC04.1942
> C                                                                                23DEC04.1943
>             DO I=ISTART,IEND                                                     23DEC04.1944
>               WPVAL(I)=0.                                                        23DEC04.1945
>             ENDDO                                                                23DEC04.1946
> C                                                                                23DEC04.1947
>             IF(IFUPR.NE.1)GOTO 2125                                              23DEC04.1948
> C                                                                                23DEC04.1949
> C  APPLY UPPER RAD COND. NO W3D(TOP) IN LATERAL SPONGE                           23DEC04.1950
> C                                                                                23DEC04.1951
>             IF(J.LT.5.OR.J.GT.M-4)GOTO 2125                                      23DEC04.1952
>             DO 2150 NSJ=-6,6                                                     23DEC04.1953
>               JN=JNSJ(J,NSJ,INEST)                                               23DEC04.1954
>               DO 2150 NSI=-6,6                                                   23DEC04.1955
>                 DO 2150 I=5,L-4                                                  23DEC04.1956
>                   IN=INSI(I,NSI,INEST)                                           23DEC04.1957
> #ifndef MPP1                                                                     23DEC04.1958
>                   WPVAL(I)=WPVAL(I)+ESTORE(IN,JN)*TMASK(NSI,NSJ)*                23DEC04.1959
>      +                     WTIJ(I,J,INEST)                                       23DEC04.1960
> #else                                                                            23DEC04.1961
> C  SEE IMPORTANT COMMENT IN THIS INCLUDED FILE RELATING TO MEMORY                23DEC04.1962
> C  STORAGE AND INDEXING OF THE ARRAY ESTORE IN THE MPP CODE IN                   23DEC04.1963
> C  THIS INCLUDED FILE                                                            23DEC04.1964
> #  include <mpp_sound_55.incl>                                                   23DEC04.1965
> #endif                                                                           23DEC04.1966
>  2150           CONTINUE                                                         23DEC04.1967
>                                                                                  23DEC04.1968
>                                                                                  23DEC04.1969
>  2125       CONTINUE                                                             23DEC04.1970
> C                                                                                23DEC04.1971
> C  FINISHED CALC OF RADIATION W                                                  23DEC04.1972
> C                                                                                23DEC04.1973
>             DO I=ISTART,IEND                                                     23DEC04.1974
>               W3D(I,J,1)=WPVAL(I)                                                23DEC04.1975
>             ENDDO                                                                23DEC04.1976
> C                                                                                23DEC04.1977
> C     DOWNWARD CALCULATION OF W                                                  23DEC04.1978
> C                                                                                23DEC04.1979
>             DO 10 K=1,N                                                          23DEC04.1980
>               DO  I=ISTART,IEND                                                  23DEC04.1981
>                   tmp(i,1) = U3D(I,J+1,K)+U3D(I+1,J+1,K)                         23DEC04.1982
>                   tmp(i,2) = V3D(I,J+1,K)+V3D(I+1,J+1,K)                         23DEC04.1983
>               end do                                                             23DEC04.1984
>                                                                                  23DEC04.1985
>               DO 10 I=ISTART,IEND                                                23DEC04.1986
>                 W3D(I,J,K+1)=E(I,J,K)*W3D(I,J,K)+F(I,J,K)                        23DEC04.1987
>                 aux2 = U3D(I,J,K)+U3D(I+1,J,K)                                   23DEC04.1988
>                 aux4 = V3D(I,J,K)+V3D(I+1,J,K)                                   23DEC04.1989
> C                                                                                23DEC04.1990
> C --- CALCULATE WIND AT CROSS POINT                                              23DEC04.1991
> C                                                                                23DEC04.1992
>                 UCRS(I,K)= tmp(i,1) + aux2                                       23DEC04.1993
>                 VCRS(I,K)= tmp(i,2) + aux4                                       23DEC04.1994
>    10         CONTINUE                                                           23DEC04.1995
>                                                                                  23DEC04.1996
> #ifdef MPP1                                                                      23DEC04.1997
> #  include <mpp_sound_60.incl>                                                   23DEC04.1998
> #endif                                                                           23DEC04.1999
> C                                                                                23DEC04.2000
>                                                                                  23DEC04.2001
>             CFL=0.0                                                              23DEC04.2002
>             DO K=N,2,-1                                                          23DEC04.2003
>               DO I=ISTART,IEND                                                   23DEC04.2004
>                  aux2 = TWT(K,2)*RHO0(I,J,K-1)                                   23DEC04.2005
>                  aux4 = TWT(K,2)*UCRS(I,K-1)+TWT(K,1)*UCRS(I,K)                  23DEC04.2006
>                  aux6 = TWT(K,2)*VCRS(I,K-1)+TWT(K,1)*VCRS(I,K)                  23DEC04.2007
>                                                                                  23DEC04.2008
>                 RHO0S=TWT(K,1)*RHO0(I,J,K)+aux2                                  23DEC04.2009
>                 SIGDOT(I,K)=-RHO0S*(G*0.001)*W3D(I,J,K)*RPSA(I,J)                23DEC04.2010
>      &                   -SIGMA(K)*(DPSDXM(I,J)*aux4                             23DEC04.2011
>      &                             +DPSDYM(I,J)*aux6)                            23DEC04.2012
>                                                                                  23DEC04.2013
>                 CHECK = SIGDOT(I,K) * DTL*DSIGMAs(K)                             23DEC04.2014
> c                CHECK=ABS(SIGDOT(I,K))*(DTL*DSIGMAs(K))                         23DEC04.2015
>                 CFL=AMAX1(CHECK*check,CFL)                                       23DEC04.2016
>               ENDDO                                                              23DEC04.2017
>             ENDDO                                                                23DEC04.2018
> #ifdef MPP1                                                                      23DEC04.2019
> C CFLJ IS DEFINED IN CFLCOM.INCL AND USED IN mpp_sound_70.incl                   23DEC04.2020
>             CFLJ(J)=CFL                                                          23DEC04.2021
> #endif                                                                           23DEC04.2022
> C                                                                                23DEC04.2023
>             IF(CFL.GT.1.0)THEN                                                   23DEC04.2024
>               DO K=N,2,-1                                                        23DEC04.2025
>                 DO I=ISTART,IEND                                                 23DEC04.2026
> c                  CFL=ABS(SIGDOT(I,K))*DTL/(DSIGMA(K)+DSIGMA(K-1))              23DEC04.2027
>                   CFL=ABS(SIGDOT(I,K))*(DTL*DSIGMAs(K))                          23DEC04.2028
>                   IF(CFL.GT.1.)THEN                                              23DEC04.2029
> #ifndef MPP1                                                                     23DEC04.2030
>                     PRINT650,CFL,W3D(I,J,K),I,J,K,INEST                          23DEC04.2031
> #else                                                                            23DEC04.2032
>                     PRINT650,CFL,W3D(I,J,K),FLIC_L2G_M(I),FLIC_L2G_N(J),         23DEC04.2033
>      +                       K,INEST                                             23DEC04.2034
> #endif                                                                           23DEC04.2035
>                   ENDIF                                                          23DEC04.2036
>                 ENDDO                                                            23DEC04.2037
>               ENDDO                                                              23DEC04.2038
>             ENDIF                                                                23DEC04.2039
>           ENDIF                                                                  23DEC04.2040
> C                                                                                23DEC04.2041
>   650     FORMAT('CFL>1: CFL = ',F7.4,' W = ',F8.4,'  I = ',I5,                  23DEC04.2042
>      +    '  J = ',I5,'  K = ',I5,'  INEST = ',I3)                               23DEC04.2043
>   120   CONTINUE                                                                 23DEC04.2044
>                                                                                  23DEC04.2045
> #ifdef MPP1                                                                      23DEC04.2046
> #  include <mpp_sound_70.incl>                                                   23DEC04.2047
> #endif                                                                           23DEC04.2048
> C                                                                                23DEC04.2049
> C SET LATERAL W IF THIS IS A NESTED GRID                                         23DEC04.2050
> C                                                                                23DEC04.2051
>         IF(INEST.NE.1)THEN                                                       23DEC04.2052
> cmic$ do all autoscope                                                           23DEC04.2053
> c$doacross                                                                       23DEC04.2054
> c$& local(k,i,j)                                                                 23DEC04.2055
> c$omp parallel do default(shared)                                                23DEC04.2056
> c$omp&private(k,i,j)                                                             23DEC04.2057
>           DO J=1,JXX                                                             23DEC04.2058
>             IF(J.EQ.2)THEN                                                       23DEC04.2059
>               DO K=1,NP1                                                         23DEC04.2060
>                 DO I=2,L-1                                                       23DEC04.2061
>                   W3D(I,2,K)=W3D(I,2,K)+WTENS(I,2,K)                             23DEC04.2062
>                 ENDDO                                                            23DEC04.2063
>               ENDDO                                                              23DEC04.2064
>               DO K=1,N                                                           23DEC04.2065
>                 DO I=2,L-1                                                       23DEC04.2066
>                   PP3D(I,2,K)=PP3D(I,2,K)+PPTENS(I,2,K)                          23DEC04.2067
>                 ENDDO                                                            23DEC04.2068
>               ENDDO                                                              23DEC04.2069
>             ELSEIF(J.EQ.M-1)THEN                                                 23DEC04.2070
>               DO K=1,NP1                                                         23DEC04.2071
>                 DO I=2,L-1                                                       23DEC04.2072
>                   W3D(I,M-1,K)=W3D(I,M-1,K)+WTENS(I,M-1,K)                       23DEC04.2073
>                 ENDDO                                                            23DEC04.2074
>               ENDDO                                                              23DEC04.2075
>               DO K=1,N                                                           23DEC04.2076
>                 DO I=2,L-1                                                       23DEC04.2077
>                   PP3D(I,M-1,K)=PP3D(I,M-1,K)+PPTENS(I,M-1,K)                    23DEC04.2078
>                 ENDDO                                                            23DEC04.2079
>               ENDDO                                                              23DEC04.2080
>             ELSEIF(J.GE.3.AND.J.LE.M-2)THEN                                      23DEC04.2081
>               DO K=1,NP1                                                         23DEC04.2082
>                 W3D(2,J,K)=W3D(2,J,K)+WTENS(2,J,K)                               23DEC04.2083
>                 W3D(L-1,J,K)=W3D(L-1,J,K)+WTENS(L-1,J,K)                         23DEC04.2084
>               ENDDO                                                              23DEC04.2085
>               DO K=1,N                                                           23DEC04.2086
>                 PP3D(2,J,K)=PP3D(2,J,K)+PPTENS(2,J,K)                            23DEC04.2087
>                 PP3D(L-1,J,K)=PP3D(L-1,J,K)+PPTENS(L-1,J,K)                      23DEC04.2088
>               ENDDO                                                              23DEC04.2089
>             ENDIF                                                                23DEC04.2090
>           ENDDO                                                                  23DEC04.2091
>         ENDIF                                                                    23DEC04.2092
> C                                                                                23DEC04.2093
> C  NOW COMPUTE THE NEW PRESSURE                                                  23DEC04.2094
> C                                                                                23DEC04.2095
> cmic$ do all autoscope                                                           23DEC04.2096
> cmic$2 private(cdd,cj)                                                           23DEC04.2097
> c$doacross                                                                       23DEC04.2098
> c$& local(j,k,i,ppold,cddtmp,cjtmp,cpm,dpterm)                                   23DEC04.2099
> c$omp parallel do default(shared)                                                23DEC04.2100
> c$omp&private(j,k,i,ppold,cddtmp,cjtmp,cpm,dpterm,tmp,                           23DEC04.2101
> c$omp&        ua1,xnu,aux2)                                                      23DEC04.2102
>         DO J=1,JXX                                                               23DEC04.2103
>           IF(J.GE.JSTART.AND.J.LE.JEND)THEN                                      23DEC04.2104
>             DO K=1,N                                                             23DEC04.2105
>               DO I=ISTART,IEND                                                   23DEC04.2106
>                 tmp(i,1) = CP*(1.+0.8*QV3D(I,J,K)*XMOIST(INEST)) *               23DEC04.2107
>      *                     RHO1(I,J,K)                                           23DEC04.2108
>                 tmp(i,2) =  W3D(I,J,K+1)+W3D(I,J,K)                              23DEC04.2109
>                 tmp(i,3) =  W3D(I,J,K+1)-W3D(I,J,K)                              23DEC04.2110
>               end do                                                             23DEC04.2111
>                                                                                  23DEC04.2112
>               call vsrec(tmp(nf(is2),1),tmp(nf(is2),1),nn)                       23DEC04.2113
>                                                                                  23DEC04.2114
>               DO 15 I=ISTART,IEND                                                23DEC04.2115
>                                                                                  23DEC04.2116
>                 PPOLD=PI(I,J,K)                                                  23DEC04.2117
>                 aux2 = PP3D(I,J,K)                                               23DEC04.2118
>                 xnu = XNUT(I,J,INEST)                                            23DEC04.2119
>                                                                                  23DEC04.2120
>                 CDDTMP= PR1(I,J,K)*RHO0(I,J,K) * rPS0(I,J)*                      23DEC04.2121
>      +                 (dtsx4*DSIGMAi(K))                                        23DEC04.2122
>                 CJTMP=RHO0(I,J,K)* dtsx5                                         23DEC04.2123
>                 aux2=aux2 + (CJTMP*tmp(i,2) + CDDTMP*tmp(i,3))*BP                23DEC04.2124
>                 PI(I,J,K)= aux2 - PPOLD-PPTENS(I,J,K)                            23DEC04.2125
> C                                                                                23DEC04.2126
> C COMPUTE PRESSURE DP`/DT CORRECTION TO THE TEMPERATURE                          23DEC04.2127
> C                                                                                23DEC04.2128
>                 DPTERM=PSA(I,J)*(aux2 - PPOLD) * tmp(i,1)                        23DEC04.2129
>                 PP3D(I,J,K) = aux2                                               23DEC04.2130
>                 TB(I,J,K)=TB(I,J,K)+XNU * DPTERM                                 23DEC04.2131
>                 TA(I,J,K)=TA(I,J,K)+DPTERM                                       23DEC04.2132
>                                                                                  23DEC04.2133
>    15         CONTINUE                                                           23DEC04.2134
>             ENDDO                                                                23DEC04.2135
>           ENDIF                                                                  23DEC04.2136
>         ENDDO                                                                    23DEC04.2137
>                                                                                  23DEC04.2138
>         NOCHECK=1                                                                23DEC04.2139
>         IF(INEST.EQ.1)THEN                                                       23DEC04.2140
>                                                                                  23DEC04.2141
> cmic$ do all autoscope                                                           23DEC04.2142
> c$doacross                                                                       23DEC04.2143
> c$& local(k,j,i)                                                                 23DEC04.2144
> c$omp parallel do default(shared)                                                23DEC04.2145
> c$omp&private(k,j,i)                                                             23DEC04.2146
>           DO 500 K=1,NP1                                                         23DEC04.2147
> C     ZERO GRADIENT CONDITIONS ON W,  SPECIFIED ON PP                            23DEC04.2148
>             DO 510 J=2,M-1                                                       23DEC04.2149
>               W3D(1,J,K)=W3D(2,J,K)                                              23DEC04.2150
>               W3D(L,J,K)=W3D(L-1,J,K)                                            23DEC04.2151
>   510       CONTINUE                                                             23DEC04.2152
>             DO 520 I=1,L                                                         23DEC04.2153
>               W3D(I,1,K)=W3D(I,2,K)                                              23DEC04.2154
>               W3D(I,M,K)=W3D(I,M-1,K)                                            23DEC04.2155
>   520       CONTINUE                                                             23DEC04.2156
>             IF(K.NE.NP1)THEN                                                     23DEC04.2157
>               DO 517 J=2,M-1                                                     23DEC04.2158
>                 PP3D(1,J,K)=PP3D(1,J,K)+PPTENS(1,J,K)                            23DEC04.2159
>                 PP3D(L,J,K)=PP3D(L,J,K)+PPTENS(L,J,K)                            23DEC04.2160
>   517         CONTINUE                                                           23DEC04.2161
>               DO 518 I=1,L                                                       23DEC04.2162
>                 PP3D(I,1,K)=PP3D(I,1,K)+PPTENS(I,1,K)                            23DEC04.2163
>                 PP3D(I,M,K)=PP3D(I,M,K)+PPTENS(I,M,K)                            23DEC04.2164
>   518         CONTINUE                                                           23DEC04.2165
>             ENDIF                                                                23DEC04.2166
>   500     CONTINUE                                                               23DEC04.2167
>         ELSEIF(INEST.GT.1)THEN                                                   23DEC04.2168
> cmic$ do all autoscope                                                           23DEC04.2169
> c$doacross                                                                       23DEC04.2170
> c$& local(k,j,i)                                                                 23DEC04.2171
> c$omp parallel do default(shared)                                                23DEC04.2172
> c$omp&private(k,j,i)                                                             23DEC04.2173
>           DO 540 K=1,NP1                                                         23DEC04.2174
> C     SPECIFIED ON W AND PP                                                      23DEC04.2175
>             DO 530 J=2,M-1                                                       23DEC04.2176
>               W3D(1,J,K)=W3D(1,J,K)+WTENS(1,J,K)                                 23DEC04.2177
>               W3D(L,J,K)=W3D(L,J,K)+WTENS(L,J,K)                                 23DEC04.2178
>   530       CONTINUE                                                             23DEC04.2179
>             DO 535 I=1,L                                                         23DEC04.2180
>               W3D(I,M,K)=W3D(I,M,K)+WTENS(I,M,K)                                 23DEC04.2181
>               W3D(I,1,K)=W3D(I,1,K)+WTENS(I,1,K)                                 23DEC04.2182
>   535       CONTINUE                                                             23DEC04.2183
>             IF(K.NE.NP1)THEN                                                     23DEC04.2184
>               DO 536 J=2,M-1                                                     23DEC04.2185
>                 PP3D(1,J,K)=PP3D(1,J,K)+PPTENS(1,J,K)                            23DEC04.2186
>                 PP3D(L,J,K)=PP3D(L,J,K)+PPTENS(L,J,K)                            23DEC04.2187
>   536         CONTINUE                                                           23DEC04.2188
>               DO 537 I=1,L                                                       23DEC04.2189
>                 PP3D(I,1,K)=PP3D(I,1,K)+PPTENS(I,1,K)                            23DEC04.2190
>                 PP3D(I,M,K)=PP3D(I,M,K)+PPTENS(I,M,K)                            23DEC04.2191
>   537         CONTINUE                                                           23DEC04.2192
>             ENDIF                                                                23DEC04.2193
>   540     CONTINUE                                                               23DEC04.2194
>         ENDIF                                                                    23DEC04.2195
> C      END OF TIME LOOP 700                                                      23DEC04.2196
> #ifdef MPP1                                                                      23DEC04.2197
> #  include <mpp_sound_80.incl>                                                   23DEC04.2198
> #endif                                                                           23DEC04.2199
>                                                                                  23DEC04.2200
>   700 CONTINUE                                                                   23DEC04.2201
>                                                                                  23DEC04.2202
> C     TRANSFER XXA TO XXB, NEW VALUES TO XXA AND APPLY TIME FILTER               23DEC04.2203
> cmic$ do all autoscope                                                           23DEC04.2204
> c$doacross                                                                       23DEC04.2205
> c$& local(i,j,k)                                                                 23DEC04.2206
> c$omp parallel do default(shared)                                                23DEC04.2207
> c$omp&private(i,j,k,aux2,aux4,aux6,aux8,xnu)                                     23DEC04.2208
>       DO J=1,JXX                                                                 23DEC04.2209
>         IF(J.LE.MP1)THEN                                                         23DEC04.2210
>           DO K=1,N                                                               23DEC04.2211
>             DO I=1,LP1                                                           23DEC04.2212
>               aux2 = PDOTB(I,J)*U3D(I,J,K)                                       23DEC04.2213
>               aux4 = PDOTB(I,J)*V3D(I,J,K)                                       23DEC04.2214
>               aux6 = UB(I,J,K)                                                   23DEC04.2215
>               aux8 = VB(I,J,K)                                                   23DEC04.2216
>               xnu = XNUU(I,J,INEST)                                              23DEC04.2217
>                                                                                  23DEC04.2218
>               aux6 = aux6 + aux2 * xnu                                           23DEC04.2219
>               aux8 = aux8 + aux4 * xnu                                           23DEC04.2220
>               UA(I,J,K) = aux2                                                   23DEC04.2221
>               VA(I,J,K) = aux4                                                   23DEC04.2222
>               UB(I,J,K) = aux6                                                   23DEC04.2223
>               VB(I,J,K) = aux8                                                   23DEC04.2224
>                                                                                  23DEC04.2225
>             ENDDO                                                                23DEC04.2226
>           ENDDO                                                                  23DEC04.2227
>         ENDIF                                                                    23DEC04.2228
>         IF(J.LE.M)THEN                                                           23DEC04.2229
>           DO K=1,N                                                               23DEC04.2230
>             DO I=1,L                                                             23DEC04.2231
>               aux2 = PSA(I,J) * PP3D(I,J,K)                                      23DEC04.2232
>               aux4 = PPB(I,J,K)                                                  23DEC04.2233
>               xnu = XNUT(I,J,INEST)                                              23DEC04.2234
>                                                                                  23DEC04.2235
>               aux4 = aux4 + aux2 * xnu                                           23DEC04.2236
>               PPA(I,J,K) = aux2                                                  23DEC04.2237
>               PPB(I,J,K) = aux4                                                  23DEC04.2238
>             ENDDO                                                                23DEC04.2239
>           ENDDO                                                                  23DEC04.2240
>           DO K=1,NP1                                                             23DEC04.2241
>             DO I=1,L                                                             23DEC04.2242
>               aux2 = PSA(I,J) * W3D(I,J,K)                                       23DEC04.2243
>               aux4 = WB(I,J,K)                                                   23DEC04.2244
>               xnu = XNUT(I,J,INEST)                                              23DEC04.2245
>               aux4 = aux4 + aux2 * xnu                                           23DEC04.2246
>                                                                                  23DEC04.2247
>               WA(I,J,K) = aux2                                                   23DEC04.2248
>               WB(I,J,K) = aux4                                                   23DEC04.2249
>             ENDDO                                                                23DEC04.2250
>           ENDDO                                                                  23DEC04.2251
>         ENDIF                                                                    23DEC04.2252
>       ENDDO                                                                      23DEC04.2253
>                                                                                  23DEC04.2254
>       RETURN                                                                     23DEC04.2255
>       END                                                                        23DEC04.2256
>                                                                                  23DEC04.2257
>                                                                                  23DEC04.2258
> #endif                                                                           23DEC04.2259
>                                                                                  23DEC04.2260
>                                                                                  23DEC04.2261
> #ifdef vsLIB                                                                     23DEC04.2262
> C_FLIC_BEGIN_NOFLIC                                                              23DEC04.2263
>       subroutine vdiv(z,x,y,n)                                                   23DEC04.2264
>       real*8 x(*),y(*),z(*)                                                      23DEC04.2265
>       do 10 j=1,n                                                                23DEC04.2266
>       z(j)=x(j)/y(j)                                                             23DEC04.2267
>    10 continue                                                                   23DEC04.2268
>       return                                                                     23DEC04.2269
>       end                                                                        23DEC04.2270
>                                                                                  23DEC04.2271
>       subroutine vsdiv(z,x,y,n)                                                  23DEC04.2272
>       real*4 x(*),y(*),z(*)                                                      23DEC04.2273
>       do 10 j=1,n                                                                23DEC04.2274
>       z(j)=x(j)/y(j)                                                             23DEC04.2275
>    10 continue                                                                   23DEC04.2276
>       return                                                                     23DEC04.2277
>       end                                                                        23DEC04.2278
>                                                                                  23DEC04.2279
>       subroutine vexp(y,x,n)                                                     23DEC04.2280
>       real*8 x(*),y(*)                                                           23DEC04.2281
>       do 10 j=1,n                                                                23DEC04.2282
>       y(j)=exp(x(j))                                                             23DEC04.2283
>    10 continue                                                                   23DEC04.2284
>       return                                                                     23DEC04.2285
>       end                                                                        23DEC04.2286
>                                                                                  23DEC04.2287
>       subroutine vsexp(y,x,n)                                                    23DEC04.2288
>       real*4 x(*),y(*)                                                           23DEC04.2289
>       do 10 j=1,n                                                                23DEC04.2290
>       y(j)=exp(x(j))                                                             23DEC04.2291
>    10 continue                                                                   23DEC04.2292
>       return                                                                     23DEC04.2293
>       end                                                                        23DEC04.2294
>                                                                                  23DEC04.2295
>       subroutine vlog(y,x,n)                                                     23DEC04.2296
>       real*8 x(*),y(*)                                                           23DEC04.2297
>       do 10 j=1,n                                                                23DEC04.2298
>       y(j)=log(x(j))                                                             23DEC04.2299
>    10 continue                                                                   23DEC04.2300
>       return                                                                     23DEC04.2301
>       end                                                                        23DEC04.2302
>                                                                                  23DEC04.2303
>       subroutine vslog(y,x,n)                                                    23DEC04.2304
>       real*4 x(*),y(*)                                                           23DEC04.2305
>       do 10 j=1,n                                                                23DEC04.2306
>       y(j)=log(x(j))                                                             23DEC04.2307
>    10 continue                                                                   23DEC04.2308
>       return                                                                     23DEC04.2309
>       end                                                                        23DEC04.2310
>                                                                                  23DEC04.2311
>       subroutine vrec(y,x,n)                                                     23DEC04.2312
>       real*8 x(*),y(*)                                                           23DEC04.2313
>       do 10 j=1,n                                                                23DEC04.2314
>       y(j)=1.d0/x(j)                                                             23DEC04.2315
>    10 continue                                                                   23DEC04.2316
>       return                                                                     23DEC04.2317
>       end                                                                        23DEC04.2318
>                                                                                  23DEC04.2319
>       subroutine vsrec(y,x,n)                                                    23DEC04.2320
>       real*4 x(*),y(*)                                                           23DEC04.2321
>       do 10 j=1,n                                                                23DEC04.2322
>       y(j)=1.d0/x(j)                                                             23DEC04.2323
>    10 continue                                                                   23DEC04.2324
>       return                                                                     23DEC04.2325
>       end                                                                        23DEC04.2326
>                                                                                  23DEC04.2327
> c@process float(rsqrt)                                                           23DEC04.2328
>       subroutine vrsqrt(y,x,n)                                                   23DEC04.2329
>       real*8 x(*),y(*)                                                           23DEC04.2330
>       do 10 j=1,n                                                                23DEC04.2331
>       y(j)=1.d0/sqrt(x(j))                                                       23DEC04.2332
>    10 continue                                                                   23DEC04.2333
>       return                                                                     23DEC04.2334
>       end                                                                        23DEC04.2335
>                                                                                  23DEC04.2336
> c@process float(rsqrt)                                                           23DEC04.2337
>       subroutine vsrsqrt(y,x,n)                                                  23DEC04.2338
>       real*4 x(*),y(*)                                                           23DEC04.2339
>       do 10 j=1,n                                                                23DEC04.2340
>       y(j)=1.d0/sqrt(x(j))                                                       23DEC04.2341
>    10 continue                                                                   23DEC04.2342
>       return                                                                     23DEC04.2343
>       end                                                                        23DEC04.2344
>                                                                                  23DEC04.2345
>       subroutine vsincos(x,y,z,n)                                                23DEC04.2346
>       real*8 x(*),y(*),z(*)                                                      23DEC04.2347
>       do 10 j=1,n                                                                23DEC04.2348
>       x(j)=sin(z(j))                                                             23DEC04.2349
>       y(j)=cos(z(j))                                                             23DEC04.2350
>    10 continue                                                                   23DEC04.2351
>       return                                                                     23DEC04.2352
>       end                                                                        23DEC04.2353
>                                                                                  23DEC04.2354
>       subroutine vssincos(x,y,z,n)                                               23DEC04.2355
>       real*4 x(*),y(*),z(*)                                                      23DEC04.2356
>       do 10 j=1,n                                                                23DEC04.2357
>       x(j)=sin(z(j))                                                             23DEC04.2358
>       y(j)=cos(z(j))                                                             23DEC04.2359
>    10 continue                                                                   23DEC04.2360
>       return                                                                     23DEC04.2361
>       end                                                                        23DEC04.2362
>                                                                                  23DEC04.2363
>       subroutine vsqrt(y,x,n)                                                    23DEC04.2364
>       real*8 x(*),y(*)                                                           23DEC04.2365
>       do 10 j=1,n                                                                23DEC04.2366
>       y(j)=sqrt(x(j))                                                            23DEC04.2367
>    10 continue                                                                   23DEC04.2368
>       return                                                                     23DEC04.2369
>       end                                                                        23DEC04.2370
>                                                                                  23DEC04.2371
>       subroutine vssqrt(y,x,n)                                                   23DEC04.2372
>       real*4 x(*),y(*)                                                           23DEC04.2373
>       do 10 j=1,n                                                                23DEC04.2374
>       y(j)=sqrt(x(j))                                                            23DEC04.2375
>    10 continue                                                                   23DEC04.2376
>       return                                                                     23DEC04.2377
>       end                                                                        23DEC04.2378
>                                                                                  23DEC04.2379
>       subroutine vtan(y,x,n)                                                     23DEC04.2380
>       real*8 x(*),y(*)                                                           23DEC04.2381
>       do 10 j=1,n                                                                23DEC04.2382
>       y(j)=tan(x(j))                                                             23DEC04.2383
>    10 continue                                                                   23DEC04.2384
>       return                                                                     23DEC04.2385
>       end                                                                        23DEC04.2386
>                                                                                  23DEC04.2387
>       subroutine vstan(y,x,n)                                                    23DEC04.2388
>       real*4 x(*),y(*)                                                           23DEC04.2389
>       do 10 j=1,n                                                                23DEC04.2390
>       y(j)=tan(x(j))                                                             23DEC04.2391
>    10 continue                                                                   23DEC04.2392
>       return                                                                     23DEC04.2393
>       end                                                                        23DEC04.2394
>                                                                                  23DEC04.2395
>       subroutine vatan2(z,y,x,n)                                                 23DEC04.2396
>       real*8 x(*),y(*),z(*)                                                      23DEC04.2397
>       do 10 j=1,n                                                                23DEC04.2398
>       z(j)=atan2(y(j),x(j))                                                      23DEC04.2399
>    10 continue                                                                   23DEC04.2400
>       return                                                                     23DEC04.2401
>       end                                                                        23DEC04.2402
>                                                                                  23DEC04.2403
>       subroutine vsatan2(z,y,x,n)                                                23DEC04.2404
>       real*4 x(*),y(*),z(*)                                                      23DEC04.2405
>       do 10 j=1,n                                                                23DEC04.2406
>       z(j)=atan2(y(j),x(j))                                                      23DEC04.2407
>    10 continue                                                                   23DEC04.2408
>       return                                                                     23DEC04.2409
>       end                                                                        23DEC04.2410
>                                                                                  23DEC04.2411
>       subroutine vasin(y,x,n)                                                    23DEC04.2412
>       real*8 x(*),y(*)                                                           23DEC04.2413
>       do 10 j=1,n                                                                23DEC04.2414
>       y(j)=asin(x(j))                                                            23DEC04.2415
>    10 continue                                                                   23DEC04.2416
>       return                                                                     23DEC04.2417
>       end                                                                        23DEC04.2418
>                                                                                  23DEC04.2419
>       subroutine vsin(y,x,n)                                                     23DEC04.2420
>       real*8 x(*),y(*)                                                           23DEC04.2421
>       do 10 j=1,n                                                                23DEC04.2422
>       y(j)=sin(x(j))                                                             23DEC04.2423
>    10 continue                                                                   23DEC04.2424
>       return                                                                     23DEC04.2425
>       end                                                                        23DEC04.2426
>                                                                                  23DEC04.2427
>       subroutine vssin(y,x,n)                                                    23DEC04.2428
>       real*4 x(*),y(*)                                                           23DEC04.2429
>       do 10 j=1,n                                                                23DEC04.2430
>       y(j)=sin(x(j))                                                             23DEC04.2431
>    10 continue                                                                   23DEC04.2432
>       return                                                                     23DEC04.2433
>       end                                                                        23DEC04.2434
>                                                                                  23DEC04.2435
>       subroutine vacos(y,x,n)                                                    23DEC04.2436
>       real*8 x(*),y(*)                                                           23DEC04.2437
>       do 10 j=1,n                                                                23DEC04.2438
>       y(j)=acos(x(j))                                                            23DEC04.2439
>    10 continue                                                                   23DEC04.2440
>       return                                                                     23DEC04.2441
>       end                                                                        23DEC04.2442
>                                                                                  23DEC04.2443
>       subroutine vcos(y,x,n)                                                     23DEC04.2444
>       real*8 x(*),y(*)                                                           23DEC04.2445
>       do 10 j=1,n                                                                23DEC04.2446
>       y(j)=cos(x(j))                                                             23DEC04.2447
>    10 continue                                                                   23DEC04.2448
>       return                                                                     23DEC04.2449
>       end                                                                        23DEC04.2450
>                                                                                  23DEC04.2451
>       subroutine vscos(y,x,n)                                                    23DEC04.2452
>       real*4 x(*),y(*)                                                           23DEC04.2453
>       do 10 j=1,n                                                                23DEC04.2454
>       y(j)=cos(x(j))                                                             23DEC04.2455
>    10 continue                                                                   23DEC04.2456
>       return                                                                     23DEC04.2457
>       end                                                                        23DEC04.2458
>                                                                                  23DEC04.2459
>       subroutine vcosisin(y,x,n)                                                 23DEC04.2460
>       complex*16 y(*)                                                            23DEC04.2461
>       real*8 x(*)                                                                23DEC04.2462
>       do 10 j=1,n                                                                23DEC04.2463
>       y(j)=dcmplx(cos(x(j)),sin(x(j)))                                           23DEC04.2464
>    10 continue                                                                   23DEC04.2465
>       return                                                                     23DEC04.2466
>       end                                                                        23DEC04.2467
>                                                                                  23DEC04.2468
>       subroutine vscosisin(y,x,n)                                                23DEC04.2469
>       complex*8 y(*)                                                             23DEC04.2470
>       real*4 x(*)                                                                23DEC04.2471
>       do 10 j=1,n                                                                23DEC04.2472
>       y(j)= cmplx(cos(x(j)),sin(x(j)))                                           23DEC04.2473
>    10 continue                                                                   23DEC04.2474
>       return                                                                     23DEC04.2475
>       end                                                                        23DEC04.2476
>                                                                                  23DEC04.2477
>       subroutine vdint(y,x,n)                                                    23DEC04.2478
>       real*8 x(*),y(*)                                                           23DEC04.2479
>       do 10 j=1,n                                                                23DEC04.2480
>       y(j)=dint(x(j))                                                            23DEC04.2481
>    10 continue                                                                   23DEC04.2482
>       return                                                                     23DEC04.2483
>       end                                                                        23DEC04.2484
>                                                                                  23DEC04.2485
>       subroutine vdnint(y,x,n)                                                   23DEC04.2486
>       real*8 x(*),y(*)                                                           23DEC04.2487
>       do 10 j=1,n                                                                23DEC04.2488
>       y(j)=dnint(x(j))                                                           23DEC04.2489
>    10 continue                                                                   23DEC04.2490
>       return                                                                     23DEC04.2491
>       end                                                                        23DEC04.2492
>                                                                                  23DEC04.2493
>       subroutine vlog10(y,x,n)                                                   23DEC04.2494
>       real*8 x(*),y(*)                                                           23DEC04.2495
>       do 10 j=1,n                                                                23DEC04.2496
>       y(j)=log10(x(j))                                                           23DEC04.2497
>    10 continue                                                                   23DEC04.2498
>       return                                                                     23DEC04.2499
>       end                                                                        23DEC04.2500
>                                                                                  23DEC04.2501
>       subroutine vcosh(y,x,n)                                                    23DEC04.2502
>       real*8 x(*),y(*)                                                           23DEC04.2503
>       do 10 j=1,n                                                                23DEC04.2504
>       y(j)=cosh(x(j))                                                            23DEC04.2505
>    10 continue                                                                   23DEC04.2506
>       return                                                                     23DEC04.2507
>       end                                                                        23DEC04.2508
>                                                                                  23DEC04.2509
>       subroutine vsinh(y,x,n)                                                    23DEC04.2510
>       real*8 x(*),y(*)                                                           23DEC04.2511
>       do 10 j=1,n                                                                23DEC04.2512
>       y(j)=sinh(x(j))                                                            23DEC04.2513
>    10 continue                                                                   23DEC04.2514
>       return                                                                     23DEC04.2515
>       end                                                                        23DEC04.2516
>                                                                                  23DEC04.2517
>       subroutine vtanh(y,x,n)                                                    23DEC04.2518
>       real*8 x(*),y(*)                                                           23DEC04.2519
>       do 10 j=1,n                                                                23DEC04.2520
>       y(j)=tanh(x(j))                                                            23DEC04.2521
>    10 continue                                                                   23DEC04.2522
>       return                                                                     23DEC04.2523
>       end                                                                        23DEC04.2524
>                                                                                  23DEC04.2525
>       subroutine vpow(z,y,x,n)                                                   23DEC04.2526
>       real*8 x(*),y(*),z(*)                                                      23DEC04.2527
>       do 10 j=1,n                                                                23DEC04.2528
>       z(j)=y(j)**x(j)                                                            23DEC04.2529
>    10 continue                                                                   23DEC04.2530
>       return                                                                     23DEC04.2531
>       end                                                                        23DEC04.2532
>                                                                                  23DEC04.2533
>       subroutine vsasin(y,x,n)                                                   23DEC04.2534
>       real*4 x(*),y(*)                                                           23DEC04.2535
>       do 10 j=1,n                                                                23DEC04.2536
>       y(j)=asin(x(j))                                                            23DEC04.2537
>    10 continue                                                                   23DEC04.2538
>       return                                                                     23DEC04.2539
>       end                                                                        23DEC04.2540
>                                                                                  23DEC04.2541
>       subroutine vsacos(y,x,n)                                                   23DEC04.2542
>       real*4 x(*),y(*)                                                           23DEC04.2543
>       do 10 j=1,n                                                                23DEC04.2544
>       y(j)=acos(x(j))                                                            23DEC04.2545
>    10 continue                                                                   23DEC04.2546
>       return                                                                     23DEC04.2547
>       end                                                                        23DEC04.2548
>                                                                                  23DEC04.2549
>       subroutine vscosh(y,x,n)                                                   23DEC04.2550
>       real*4 x(*),y(*)                                                           23DEC04.2551
>       do 10 j=1,n                                                                23DEC04.2552
>       y(j)=cosh(x(j))                                                            23DEC04.2553
>    10 continue                                                                   23DEC04.2554
>       return                                                                     23DEC04.2555
>       end                                                                        23DEC04.2556
>                                                                                  23DEC04.2557
>       subroutine vslog10(y,x,n)                                                  23DEC04.2558
>       real*4 x(*),y(*)                                                           23DEC04.2559
>       do 10 j=1,n                                                                23DEC04.2560
>       y(j)=log10(x(j))                                                           23DEC04.2561
>    10 continue                                                                   23DEC04.2562
>       return                                                                     23DEC04.2563
>       end                                                                        23DEC04.2564
>                                                                                  23DEC04.2565
>       subroutine vspow(z,y,x,n)                                                  23DEC04.2566
>       real*4 x(*),y(*),z(*)                                                      23DEC04.2567
>       do 10 j=1,n                                                                23DEC04.2568
>       z(j)=y(j)**x(j)                                                            23DEC04.2569
>    10 continue                                                                   23DEC04.2570
>       return                                                                     23DEC04.2571
>       end                                                                        23DEC04.2572
>                                                                                  23DEC04.2573
>       subroutine vssinh(y,x,n)                                                   23DEC04.2574
>       real*4 x(*),y(*)                                                           23DEC04.2575
>       do 10 j=1,n                                                                23DEC04.2576
>       y(j)=sinh(x(j))                                                            23DEC04.2577
>    10 continue                                                                   23DEC04.2578
>       return                                                                     23DEC04.2579
>       end                                                                        23DEC04.2580
>                                                                                  23DEC04.2581
>       subroutine vstanh(y,x,n)                                                   23DEC04.2582
>       real*4 x(*),y(*)                                                           23DEC04.2583
>       do 10 j=1,n                                                                23DEC04.2584
>       y(j)=tanh(x(j))                                                            23DEC04.2585
>    10 continue                                                                   23DEC04.2586
>       return                                                                     23DEC04.2587
>       end                                                                        23DEC04.2588
> C_FLIC_END_NOFLIC                                                                23DEC04.2589
> #endif                                                                           23DEC04.2590
===================================================================
fdda/grid/blnudgd.F
diff -r3.0 -r3.3
95a96,104
> #ifdef IBMopt                                                                    23DEC04.2591
>       integer is,nn                                                              23DEC04.2592
>       real temp1(mix),tim0                                                       23DEC04.2593
> #ifdef MPP1                                                                      23DEC04.2594
> #define nf(A) noflic(A)
> #else                                                                            23DEC04.2596
> #define nf(A) A       
> #endif                                                                           23DEC04.2598
> #endif                                                                           23DEC04.2599
126a136,144
> #ifdef IBMopt                                                                    23DEC04.2600
> #ifdef MPP1                                                                      23DEC04.2601
>       nn = ie_x0(ILX-IDC-ICUT) - is_x0(2+ICUT) + 1                               23DEC04.2602
>       is = is_x0(2+ICUT)                                                         23DEC04.2603
> #else                                                                            23DEC04.2604
>       nn = ILX -IDC-ICUT                                                         23DEC04.2605
>       is = 2+ICUT                                                                23DEC04.2606
> #endif                                                                           23DEC04.2607
> #endif                                                                           23DEC04.2608
189a208,210
> #ifdef IBMopt                                                                    23DEC04.2609
>         tim0 = 1./(TIME(5)-TIMB(5))                                              23DEC04.2610
> #endif                                                                           23DEC04.2611
192a214
> #ifndef IBMopt                                                                   23DEC04.2612
193a216,218
> #else                                                                            23DEC04.2613
>      +                   * tim0                                                  23DEC04.2614
> #endif                                                                           23DEC04.2615
213a239,241
> #ifdef IBMopt                                                                    23DEC04.2616
>         tim0 = 1./(TIME(NV)-TIMB(NV))                                            23DEC04.2617
> #endif                                                                           23DEC04.2618
216a245
> #ifndef IBMopt                                                                   23DEC04.2619
217a247,249
> #else                                                                            23DEC04.2620
>      +                   SFCOBS(NTB(NV),8,II,JJ)) * tim0                         23DEC04.2621
> #endif                                                                           23DEC04.2622
244a277,279
> #ifdef IBMopt                                                                    23DEC04.2623
>         tim0 = 1./(TIME(NV)-TIMB(NV))                                            23DEC04.2624
> #endif                                                                           23DEC04.2625
247a283
> #ifndef IBMopt                                                                   23DEC04.2626
249a286,289
> #else                                                                            23DEC04.2627
>      +                 SFCOBS(NTE(NV),NV,I,J)-SFCOBS(NTB(NV),NV,I,J))*           23DEC04.2628
>      +                 tim0                                                      23DEC04.2629
> #endif                                                                           23DEC04.2630
265a306,316
> #ifdef IBMopt                                                                    23DEC04.2631
>                                                                                  23DEC04.2632
>       call vslog(temp1(nf(is)),ZNTJ(nf(is)),nn)                                  23DEC04.2633
>                                                                                  23DEC04.2634
>         do i=2+ICUT,ILX-IDC-ICUT                                                 23DEC04.2635
>            temp1(i) = temp1(i) * 0.2                                             23DEC04.2636
>         end do                                                                   23DEC04.2637
>                                                                                  23DEC04.2638
>       call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                                 23DEC04.2639
>                                                                                  23DEC04.2640
> #endif                                                                           23DEC04.2641
267c318
<           DO 361 I=2+ICUT,ILX-IDC-ICUT                                           BLNUDGD.267
---
>           DO  I=2+ICUT,ILX-IDC-ICUT                                              23DEC04.2642
277a329
> #ifndef IBMopt                                                                   23DEC04.2643
278a331,333
> #else                                                                            23DEC04.2644
>              WNDCORP=1.0+0.320*temp1(i)                                          23DEC04.2645
> #endif                                                                           23DEC04.2646
300a356
>           ENDDO                                                                  23DEC04.2647
379,380c435,438
<             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(              BLNUDGD.379
<      +                  XOBBL(I,KL)-XB(I,J,KL)/PSTF(I,J))*BLW1D(I)*              BLNUDGD.380
---
> CB            XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(            23DEC04.2648
> CB     +                  XOBBL(I,KL)-XB(I,J,KL)/PSTF(I,J))*BLW1D(I)*            23DEC04.2649
>             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*(PSTF(I,J)*              23DEC04.2650
>      +                  XOBBL(I,KL)-XB(I,J,KL))*BLW1D(I)*                        23DEC04.2651
392,393c450,453
<             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(              BLNUDGD.392
<      +                  XOBBL(I,K)-XB(I,J,K)/PSTF(I,J))*BLW1D(I)*                BLNUDGD.393
---
> CB            XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(            23DEC04.2652
> CB     +                  XOBBL(I,K)-XB(I,J,K)/PSTF(I,J))*BLW1D(I)*              23DEC04.2653
>             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*(PSTF(I,J)*              23DEC04.2654
>      +                  XOBBL(I,K)-XB(I,J,K))*BLW1D(I)*                          23DEC04.2655
408,409c468,471
<             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(              BLNUDGD.408
<      +                  XOBBL(I,KL)-XB(I,J,KL)/PSTF(I,J))*WXY2(I,J)*             BLNUDGD.409
---
> CB            XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(            23DEC04.2656
> CB     +                  XOBBL(I,KL)-XB(I,J,KL)/PSTF(I,J))*WXY2(I,J)*           23DEC04.2657
>             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*(PSTF(I,J)*              23DEC04.2658
>      +                  XOBBL(I,KL)-XB(I,J,KL))*WXY2(I,J)*                       23DEC04.2659
419,420c481,484
<             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(              BLNUDGD.419
<      +                  XOBBL(I,K)-XB(I,J,K)/PSTF(I,J))*WXY2(I,J)*               BLNUDGD.420
---
> CB            XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*PSTF(I,J)*(            23DEC04.2660
> CB     +                  XOBBL(I,K)-XB(I,J,K)/PSTF(I,J))*WXY2(I,J)*             23DEC04.2661
>             XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,2)*TFAC(IN,2)*(PSTF(I,J)*              23DEC04.2662
>      +                  XOBBL(I,K)-XB(I,J,K))*WXY2(I,J)*                         23DEC04.2663
===================================================================
fdda/grid/bufslgd.F
diff -r3.0 -r3.2
22a23
> #ifndef IBMopt                                                                   23DEC04.2664
23a25,28
> #else                                                                            23DEC04.2665
>      1   XOBJK(MIXFG,MKXFG),PSTO(MIXFG,MJXFG),pstoi(MIXFG)                       23DEC04.2666
>       real xx                                                                    23DEC04.2667
> #endif                                                                           23DEC04.2668
26a32,42
> #ifdef IBMopt                                                                    23DEC04.2669
> #ifdef MPP1                                                                      23DEC04.2670
>       nn = ie_x 0 ( IMAX-ICUT  ) - is_x 0 ( 2+ICUT )  +1                         23DEC04.2671
>       is = is_x 0 ( 2+ICUT )                                                     23DEC04.2672
>       call vsrec(PSTOi(noflic(is)),PSTO(noflic(is),noflic(j)),nn)                23DEC04.2673
> #else                                                                            23DEC04.2674
>       nn = IMAX-2* ICUT - 1                                                      23DEC04.2675
>       is = 2+icut                                                                23DEC04.2676
>       call vsrec(PSTOi(is),PSTO(is,j),nn)                                        23DEC04.2677
> #endif                                                                           23DEC04.2678
> #endif                                                                           23DEC04.2679
33a50,52
> #ifdef IBMopt                                                                    23DEC04.2680
>       xx = IN * FDTIM                                                            23DEC04.2681
> #endif                                                                           23DEC04.2682
35a55
> #ifndef IBMopt                                                                   23DEC04.2683
37a58,60
> #else                                                                            23DEC04.2684
>           XOBJK(I,K)=(XOB(I,J,K)+ xx * XOBTEN(I,J,K)) * PSTOi(I)                 23DEC04.2685
> #endif                                                                           23DEC04.2686
===================================================================
fdda/grid/in4dgd.F
diff -r3.18 -r3.20
99c99
< #if defined(CRAY)||defined(rs6000)||defined(SGI_Origin)||defined(linux)
---
> #if defined(rs6000)||defined(SGI_Origin)||defined(linux)   
103a104,108
> #elif defined(CRAY)||defined(crayx1) 
>         IF (.NOT. OPENED) THEN                                                   23DEC04.2689
>           OPEN(IUN2, FILE='MMINPUT2_DOMAIN'//CHAR(IN+ICHAR('0')),                23DEC04.2690
>      &         FORM='UNFORMATTED',STATUS='OLD',ERR=9020)                         23DEC04.2691
>         ENDIF                                                                    23DEC04.2692
===================================================================
fdda/grid/nudgd.F
diff -r3.0 -r3.2
90a91
>       real dxi2                                                                  23DEC04.2693
97a99
>       dxi2 = 0.5/dx                                                              23DEC04.2694
213,214c215,218
<           XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*PSTF(I,J)*(                NUDGD.213
<      +                XOBJK(I,K)-XB(I,J,K)/PSTF(I,J))*WXY(I,J)*                  NUDGD.214
---
> CB          XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*PSTF(I,J)*(              23DEC04.2695
> CB     +                XOBJK(I,K)-XB(I,J,K)/PSTF(I,J))*WXY(I,J)*                23DEC04.2696
>           XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*(PSTF(I,J)*                23DEC04.2697
>      +                XOBJK(I,K)-XB(I,J,K))*WXY(I,J)*                            23DEC04.2698
227,228c231,234
<           XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*PSTF(I,J)*(                NUDGD.227
<      +                XOBJK(I,K)-XB(I,J,K)/PSTF(I,J))*WXY2(I,J)*                 NUDGD.228
---
> CB          XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*PSTF(I,J)*(              23DEC04.2699
> CB     +                XOBJK(I,K)-XB(I,J,K)/PSTF(I,J))*WXY2(I,J)*               23DEC04.2700
>           XTEN(I,J,K)=XTEN(I,J,K)+GX(IN,1)*TFAC(IN,1)*(PSTF(I,J)*                23DEC04.2701
>      +                XOBJK(I,K)-XB(I,J,K))*WXY2(I,J)*                           23DEC04.2702
271c277,278
<      +                  VORDIF(I-1,J-1,K))*0.5/DX*WXY(I,J)*ZFAC(IN,1,K)+         NUDGD.271
---
> CB     +                  VORDIF(I-1,J-1,K))*0.5/DX*WXY(I,J)*ZFAC(IN,1,K)+       23DEC04.2703
>      +                  VORDIF(I-1,J-1,K))*DXi2*WXY(I,J)*ZFAC(IN,1,K)+           23DEC04.2704
283c290,291
<      +                  VORDIF(I-1,J-1,K))*0.5/DX*WXY(I,J)*ZFAC(IN,1,K)+         NUDGD.283
---
> CB     +                  VORDIF(I-1,J-1,K))*0.5/DX*WXY(I,J)*ZFAC(IN,1,K)+       23DEC04.2705
>      +                  VORDIF(I-1,J-1,K))*DXi2*WXY(I,J)*ZFAC(IN,1,K)+           23DEC04.2706
===================================================================
fdda/grid/qsatgd.F
diff -r3.0 -r3.3
19a20,37
> #ifdef IBMopt                                                                    23DEC04.2707
>       integer nn,is                                                              23DEC04.2708
>       real temp1(MIXFG)                                                          23DEC04.2709
> #ifdef MPP1                                                                      23DEC04.2710
> #define nf(A) noflic(A) 
> #else                                                                            23DEC04.2712
> #define nf(A) A        
> #endif                                                                           23DEC04.2714
>                                                                                  23DEC04.2715
> #ifdef MPP1                                                                      23DEC04.2716
>       nn = ie_x0(ILX) - is_x0(2) + 1                                             23DEC04.2717
>       is = is_x0(2)                                                              23DEC04.2718
> #else                                                                            23DEC04.2719
>       nn = ILX - 1                                                               23DEC04.2720
>       is = 2                                                                     23DEC04.2721
> #endif                                                                           23DEC04.2722
> #endif                                                                           23DEC04.2723
> C                                                                                23DEC04.2724
20a39
> #ifndef IBMopt                                                                   23DEC04.2725
27c46,62
<    10   CONTINUE                                                                 QSATGD.27
---
> #else                                                                            23DEC04.2726
>         DO I=2,ILX                                                               23DEC04.2727
>           TT=T3D(I,J,K)                                                          23DEC04.2728
>           temp1(i) = SVP2*(TT-SVPT0)/(TT-SVP3)                                   23DEC04.2729
>         ENDDO                                                                    23DEC04.2730
>                                                                                  23DEC04.2731
>         call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                               23DEC04.2732
>                                                                                  23DEC04.2733
>         DO I=2,ILX                                                               23DEC04.2734
>           CORR=PP3D(I,J,K)*0.001                                                 23DEC04.2735
>           PP=PSB(I,J)*A(K)+PTOP+CORR                                             23DEC04.2736
>           ES=SVP1*temp1(i)                                                       23DEC04.2737
>           QSATF(I,K)=EP2*ES/(PP-ES)                                              23DEC04.2738
>         ENDDO                                                                    23DEC04.2739
> #endif                                                                           23DEC04.2740
>                                                                                  23DEC04.2741
>    10  CONTINUE                                                                  23DEC04.2742
31d65
<                                                                                  QSATGD.31
===================================================================
include/addr0.incl
diff -r3.0 -r3.2
4c4
< #ifdef DEC_ALPHA                                                                 ADDR0.4
---
> #if defined (DEC_ALPHA) || defined (crayx1)     
===================================================================
include/param2.incl
diff -r3.13 -r3.17
12c12,13
<      6 ,ITSN,JTSN,ISSTVAR,IZ0TOPT,IEXSI,IPOLAR                                   19DEC02.1312
---
>      6 ,ITSN,JTSN,ISSTVAR,IZ0TOPT,IEXSI,IPOLAR,ISFMTHD                           23DEC04.2744
>      7 ,LEVSLP,OROSHAW,ITADVM,IQADVM,TDKORR                                      23DEC04.2745
23c24,25
<      4  ISSTVAR,IZ0TOPT,CKH,IEXSI,IPOLAR                                         19DEC02.1313
---
>      4  ISSTVAR,IZ0TOPT,CKH,IEXSI,IPOLAR,ISFMTHD                                 23DEC04.2746
>      4 ,LEVSLP,OROSHAW,ITADVM,IQADVM,TDKORR,IFRSFA                               23DEC04.2747
25c27
<       LOGICAL IFREST,IFSAVE,SVLAST,IFSKIP,LFBTER                                 PARAM2.23
---
>       LOGICAL IFREST,IFSAVE,SVLAST,IFSKIP,LFBTER,IFRSFA                          23DEC04.2748
34a37
>      1 ,ITADVM(MAXSES),IQADVM(MAXSES)                                            23DEC04.2749
===================================================================
include/param3.incl
diff -r3.2 -r3.4
33a34,35
>       real shadint(mix,mjx,maxnes)                                               23DEC04.2750
>       common /ororad/ shadint                                                    23DEC04.2751
===================================================================
memory/address/addall.F
diff -r3.12 -r3.13
4c4
< #ifdef DEC_ALPHA                                                                 ADDALL.4
---
> #if defined (DEC_ALPHA) || defined (crayx1) 
===================================================================
memory/address/addrx1c.F
diff -r3.7 -r3.9
7c7
< #ifdef DEC_ALPHA                                                                 ADDRX1C.7
---
> #if defined (DEC_ALPHA) || defined (crayx1) 
===================================================================
memory/address/addrx1n.F
diff -r3.7 -r3.9
8c8
< #ifdef DEC_ALPHA                                                                 ADDRX1N.8
---
> #if defined (DEC_ALPHA) || defined (crayx1)  
===================================================================
physics/advection/simple/Makefile
diff -r3.0 -r3.1
10c10,11
< 	vadv.o
---
> 	vadv.o \
> 	vadv2.o
14c15,16
< 	vadv.i
---
> 	vadv.i \
> 	vadv2.i
18c20,21
< 	vadv.f
---
> 	vadv.f \
> 	vadv2.f
45a49,50
> vadv2.o: ../../../include/parame.incl ../../../include/param3.incl
> vadv2.o: ../../../include/various.incl ../../../include/nhcnst.incl
===================================================================
physics/advection/simple/hadv.F
diff -r3.2 -r3.5
1c1
<       SUBROUTINE HADV(KZZ,FTEN,UA,VA,F,MSF,DXX,IND,IN)                           HADV.1
---
>       SUBROUTINE HADV(KZZ,FTEN,UA,VA,F,MSF,DXX,IND,IN,VAR)                       23DEC04.2755
38a39
>       character*1 VAR                                                            23DEC04.2756
63c64
<       GOTO (10,30,50,70),IND                                                     HADV.63
---
>       GOTO (10,30,50,70,90),IND                                                  23DEC04.2757
205a207,307
> c                                                                                23DEC04.2758
> c advection of cross-point variables with divergence already removed             23DEC04.2759
> c                                                                                23DEC04.2760
>    90 CONTINUE                                                                   23DEC04.2761
> cmic$ do all autoscope                                                           23DEC04.2762
> cmic$1 shared(ILXM,JLXM,KL,ICUT,FTEN,F,UA,VA,DXXMSF)                             23DEC04.2763
> cmic$2 private(I,J,K)                                                            23DEC04.2764
> c$omp parallel do default(shared)                                                23DEC04.2765
> c$omp&private(i,j,k)                                                             23DEC04.2766
>       DO 100 J=2+ICUT,JLXM-ICUT                                                  23DEC04.2767
>         DO 100 K=1,KL                                                            23DEC04.2768
>           DO 100 I=2+ICUT,ILXM-ICUT                                              23DEC04.2769
>              FTEN(I,J,K)=                                                        23DEC04.2770
>      1           -((UA(I+1,J+1,K)+UA(I,J+1,K))*(F(I,J+1,K)-F(I,J,K))             23DEC04.2771
>      2           + (UA(I+1,J,  K)+UA(I,J,  K))*(F(I,J,K)-F(I,J-1,K))             23DEC04.2772
>      3           + (VA(I+1,J+1,K)+VA(I+1,J,K))*(F(I+1,J,K)-F(I,J,K))             23DEC04.2773
>      4           + (VA(I,  J+1,K)+VA(I,  J,K))*(F(I,J,K)-F(I-1,J,K)))            23DEC04.2774
>      5           *DXXMSF(I,J)                                                    23DEC04.2775
>   100     CONTINUE                                                               23DEC04.2776
>                                                                                  23DEC04.2777
> c  Instability correction (local extrema exceeding a certain threshold           23DEC04.2778
> c                   must not grow further due to advection)                      23DEC04.2779
>       if (var.eq.'T') then  ! Temperature                                        23DEC04.2780
> C                                                                                23DEC04.2781
> c$omp parallel do default(shared)                                                23DEC04.2782
> c$omp&private(i,j,k)                                                             23DEC04.2783
>       DO 220 J=2+ICUT,JLXM-ICUT                                                  23DEC04.2784
>         DO 220 K=1,KL                                                            23DEC04.2785
>           DO 220 I=2+ICUT,ILXM-ICUT                                              23DEC04.2786
>       if (abs(F(I+1,J,K)+F(I-1,J,K)-2*F(I,J,K)).gt.5) then                       23DEC04.2787
>       if ((F(I,J,K).gt.F(I+1,J,K)).and.(F(I,J,K).gt.F(I-1,J,K))) then            23DEC04.2788
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2789
>       else if ((F(I,J,K).lt.F(I+1,J,K)).and.(F(I,J,K).lt.F(I-1,J,K)))            23DEC04.2790
>      f then                                                                      23DEC04.2791
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2792
>       endif                                                                      23DEC04.2793
>       endif                                                                      23DEC04.2794
>       if (abs(F(I,J+1,K)+F(I,J-1,K)-2*F(I,J,K)).gt.5) then                       23DEC04.2795
>       if ((F(I,J,K).gt.F(I,J+1,K)).and.(F(I,J,K).gt.F(I,J-1,K))) then            23DEC04.2796
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2797
>       else if ((F(I,J,K).lt.F(I,J+1,K)).and.(F(I,J,K).lt.F(I,J-1,K)))            23DEC04.2798
>      f then                                                                      23DEC04.2799
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2800
>       endif                                                                      23DEC04.2801
>       endif                                                                      23DEC04.2802
>  220   continue                                                                  23DEC04.2803
> C                                                                                23DEC04.2804
>        else if (var.eq.'Q') then   ! WV mixing ratio                             23DEC04.2805
> C                                                                                23DEC04.2806
> c$omp parallel do default(shared)                                                23DEC04.2807
> c$omp&private(i,j,k)                                                             23DEC04.2808
>       DO 230 J=2+ICUT,JLXM-ICUT                                                  23DEC04.2809
>         DO 230 K=1,KL                                                            23DEC04.2810
>           DO 230 I=2+ICUT,ILXM-ICUT                                              23DEC04.2811
>       if (abs(F(I+1,J,K)+F(I-1,J,K)-2*F(I,J,K))/F(I,J,K).gt.0.2) then            23DEC04.2812
>       if ((F(I,J,K).gt.F(I+1,J,K)).and.(F(I,J,K).gt.F(I-1,J,K))) then            23DEC04.2813
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2814
>       else if ((F(I,J,K).lt.F(I+1,J,K)).and.(F(I,J,K).lt.F(I-1,J,K)))            23DEC04.2815
>      f then                                                                      23DEC04.2816
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2817
>       endif                                                                      23DEC04.2818
>       endif                                                                      23DEC04.2819
>       if (abs(F(I,J+1,K)+F(I,J-1,K)-2*F(I,J,K))/F(I,J,K).gt.0.2) then            23DEC04.2820
>       if ((F(I,J,K).gt.F(I,J+1,K)).and.(F(I,J,K).gt.F(I,J-1,K))) then            23DEC04.2821
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2822
>       else if ((F(I,J,K).lt.F(I,J+1,K)).and.(F(I,J,K).lt.F(I,J-1,K)))            23DEC04.2823
>      f then                                                                      23DEC04.2824
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2825
>       endif                                                                      23DEC04.2826
>       endif                                                                      23DEC04.2827
>  230  continue                                                                   23DEC04.2828
> c                                                                                23DEC04.2829
>         else if (var.eq.'C') then   ! CLW mixing ratio                           23DEC04.2830
> c                                                                                23DEC04.2831
> c$omp parallel do default(shared)                                                23DEC04.2832
> c$omp&private(i,j,k)                                                             23DEC04.2833
>       DO 240 J=2+ICUT,JLXM-ICUT                                                  23DEC04.2834
>         DO 240 K=1,KL                                                            23DEC04.2835
>           DO 240 I=2+ICUT,ILXM-ICUT                                              23DEC04.2836
>       if (abs(F(I+1,J,K)+F(I-1,J,K)-2*F(I,J,K)).gt.2.e-4) then                   23DEC04.2837
>       if ((F(I,J,K).gt.F(I+1,J,K)).and.(F(I,J,K).gt.F(I-1,J,K))) then            23DEC04.2838
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2839
>       else if ((F(I,J,K).lt.F(I+1,J,K)).and.(F(I,J,K).lt.F(I-1,J,K)))            23DEC04.2840
>      f then                                                                      23DEC04.2841
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2842
>       endif                                                                      23DEC04.2843
>       endif                                                                      23DEC04.2844
>       if (abs(F(I,J+1,K)+F(I,J-1,K)-2*F(I,J,K)).gt.2.e-4) then                   23DEC04.2845
>       if ((F(I,J,K).gt.F(I,J+1,K)).and.(F(I,J,K).gt.F(I,J-1,K))) then            23DEC04.2846
>         FTEN(I,J,K) = min(FTEN(I,J,K),0.)                                        23DEC04.2847
>       else if ((F(I,J,K).lt.F(I,J+1,K)).and.(F(I,J,K).lt.F(I,J-1,K)))            23DEC04.2848
>      f then                                                                      23DEC04.2849
>       FTEN(I,J,K) = max(FTEN(I,J,K),0.)                                          23DEC04.2850
>       endif                                                                      23DEC04.2851
>       endif                                                                      23DEC04.2852
>  240  continue                                                                   23DEC04.2853
>                                                                                  23DEC04.2854
>       endif                                                                      23DEC04.2855
> c                                                                                23DEC04.2856
>       return                                                                     23DEC04.2857
>                                                                                  23DEC04.2858
207a310,490
>                                                                                  23DEC04.2859
>                                                                                  23DEC04.2860
> C----------------------------------------------------------------------------    23DEC04.2861
>       SUBROUTINE ADVDUV( UTEN, VTEN, UA, VA, QDOT, DXX, REARTH,                  23DEC04.2862
>      &                   WA, DIVX, U3D, V3D, UCD, VCD, IN )                      23DEC04.2863
>       IMPLICIT NONE                                                              23DEC04.2864
>                                                                                  23DEC04.2865
> CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC          23DEC04.2866
> C  UNIFIED 3-D ADVECTION OF U,V                                       C          23DEC04.2867
> C                                                                     C          23DEC04.2868
> C     This subroutine computes the horizontal and vertical            C          23DEC04.2869
> C     flux-divergence terms, divergence terms, curvature terms,       C          23DEC04.2870
> C     and Coriolis terms for wind components U and V                  C          23DEC04.2871
> C     Second-order difference is used for flux-divergence terms.      C          23DEC04.2872
> C                                                                     C          23DEC04.2873
> C     Adapted from SOLVE parallel loop 6, and optimized HADV          C          23DEC04.2874
> C     and VADV by CJC, March. 2004                                    C          23DEC04.2875
> C                                                                     C          23DEC04.2876
> C INPUT ARGUMENTS                                                     C          23DEC04.2877
> C                                                                     C          23DEC04.2878
> C     IN     : Nest subscript                                         C          23DEC04.2879
> C                                                                     C          23DEC04.2880
> C     UA, VA, WA : are P*U, P*V, P*W.                                 C          23DEC04.2881
> C                                                                     C          23DEC04.2882
> C     QDOT   : is the vertical SIGMA-velocity                         C          23DEC04.2883
> C                                                                     C          23DEC04.2884
> C     DIVX   : is the (3D) divergence of (U,V,W)                      C          23DEC04.2885
> C                                                                     C          23DEC04.2886
> C     DXX    : is the horizontal distance.                            C          23DEC04.2887
> C              = DX16 FOR IND=3.                                      C          23DEC04.2888
> C                                                                     C          23DEC04.2889
> C     REARTH : is the radius of the Earth.                            C          23DEC04.2890
> C                                                                     C          23DEC04.2891
> C     U3D, V3D : are decoupled U and V.                               C          23DEC04.2892
> C                                                                     C          23DEC04.2893
> C     UCD, VCD : are  coupled  U and V.                               C          23DEC04.2894
> C                                                                     C          23DEC04.2895
> C OUTPUT ARGUMENTS                                                    C          23DEC04.2896
> C                                                                     C          23DEC04.2897
> C     UTEN,VTEN : is the tendency for variables U, V                  C          23DEC04.2898
> C                                                                     C          23DEC04.2899
> CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC          23DEC04.2900
>                                                                                  23DEC04.2901
> #       include <parame.incl>                                                    23DEC04.2902
> #       include <param3.incl>                                                    23DEC04.2903
> #       include <various.incl>                                                   23DEC04.2904
> #       include <point2d.incl>                                                   23DEC04.2905
> #       include <rpstar.incl>                                                    23DEC04.2906
>                                                                                  23DEC04.2907
> C.......  Arguments:                                                             23DEC04.2908
>                                                                                  23DEC04.2909
>       INTEGER IN                                                                 23DEC04.2910
>       REAL    UTEN(MIX,MJX,MKX), VTEN(MIX,MJX,MKX)                               23DEC04.2911
>       REAL    UA(MIX,MJX,MKX),   VA(MIX,MJX,MKX)                                 23DEC04.2912
>       REAL    QDOT(MIX,MJX,KXP1),WA(MIX,MJX,KXP1)                                23DEC04.2913
>       REAL   DIVX(MIX,MJX,MKX),  MSF(MIX,MJX)                                    23DEC04.2914
>       REAL    U3D(MIX,MJX,MKX),  V3D(MIX,MJX,MKX)                                23DEC04.2915
>       REAL    UCD(MIX,MJX,MKX),  VCD(MIX,MJX,MKX)                                23DEC04.2916
>       REAL    DXX, REARTH                                                        23DEC04.2917
>                                                                                  23DEC04.2918
> C.......  Local Variables:                                                       23DEC04.2919
>                                                                                  23DEC04.2920
>       REAL    DXXMSF(MIX), EFC(MIX), EFS(MIX)                                    23DEC04.2921
>       REAL    DDS(KXP1)                                                          23DEC04.2922
>       REAL    WADOT(MIX,KXP1)                                                    23DEC04.2923
>       INTEGER ICUT,I,J,K                                                         23DEC04.2924
>                                                                                  23DEC04.2925
>       REAL    UU, VV, QQ                                                         23DEC04.2926
>       REAL    UCMONA, VCMONA, UCMONB, VCMONB, UCMONC, VCMONC                     23DEC04.2927
>       REAL    DIVD, DIAG, WABAR, AMFAC, DUV                                      23DEC04.2928
>                                                                                  23DEC04.2929
> C----------------------------------------------------------------------          23DEC04.2930
>                                                                                  23DEC04.2931
>       ICUT=0                                                                     23DEC04.2932
>       IF ( IN.GT.1 ) ICUT=1                                                      23DEC04.2933
>                                                                                  23DEC04.2934
>       DO K=1,KL                                                                  23DEC04.2935
>           DDS(K) = 1.0 / DSIGMA(K)                                               23DEC04.2936
>       END DO                                                                     23DEC04.2937
>                                                                                  23DEC04.2938
> cmic$ do all autoscope                                                           23DEC04.2939
> cmic$1    shared(ILX,JLX,KL,ICUT,                                                23DEC04.2940
> cmic$2           UTEN,VTEN,U3D,V3D,UCD,VCD,UA,VA,QDOT,MSF,DXX,DDS)               23DEC04.2941
> cmic$3   private(I,J,K,ucmona,vcmona,ucmonb,vcmonb,ucmonc,vcmonc,                23DEC04.2942
> cmic$4           WADOT,WABAR,AMFAC,DUV,DIVD,DIAG,DXXMSF,EFC,EFS,UU,VV,QQ)        23DEC04.2943
>                                                                                  23DEC04.2944
> c$doacross local(i,j,k,ucmona,vcmona,ucmonb,vcmonb,ucmonc,vcmonc,                23DEC04.2945
> c$&              WADOT,WABAR,AMFAC,DUV,DIVD,DIAG,DXXMSF,EFC,EFS,UU,VV,QQ)        23DEC04.2946
>                                                                                  23DEC04.2947
> c$omp parallel do                                                                23DEC04.2948
> c$omp&   default(shared)                                                         23DEC04.2949
> c$omp&   private(i,j,k,ucmona,vcmona,ucmonb,vcmonb,ucmonc,vcmonc,                23DEC04.2950
> c$omp&          WADOT,WABAR,AMFAC,DUV,DIVD,DIAG,DXXMSF,EFC,EFS,UU,VV,QQ)         23DEC04.2951
>                                                                                  23DEC04.2952
>       DO  J=2+ICUT,JLX-ICUT                                                      23DEC04.2953
>                                                                                  23DEC04.2954
>          DO I=2+ICUT,ILX-ICUT                                                    23DEC04.2955
>             DXXMSF(I) = 1.0/(DXX*MSFD(I,J)*MSFD(I,J))                            23DEC04.2956
>             EFC(I)    = EF(I,J)*COSROT(I,J)                                      23DEC04.2957
>             EFS(I)    = EF(I,J)*SINROT(I,J)                                      23DEC04.2958
>          ENDDO                                                                   23DEC04.2959
>                                                                                  23DEC04.2960
>          DO K=1,KL+1                                                             23DEC04.2961
>          DO I=2+ICUT,ILX-ICUT                                                    23DEC04.2962
>             WADOT(I,K)=0.125*(WA(I-1,J-1,K) + WA(I,J-1,K)+                       23DEC04.2963
>      &                        WA(I-1,J  ,K) + WA(I,J  ,K))                       23DEC04.2964
>          ENDDO                                                                   23DEC04.2965
>          ENDDO                                                                   23DEC04.2966
>                                                                                  23DEC04.2967
>          DO  K=1,KL                                                              23DEC04.2968
>                                                                                  23DEC04.2969
>             !!         Horizontal advection                                      23DEC04.2970
>                                                                                  23DEC04.2971
>             DO  I=2+ICUT,ILX-ICUT                                                23DEC04.2972
>                DIVD = 0.25*(DIVX(I,J  ,K) + DIVX(I-1,J  ,K)+                     23DEC04.2973
>      &                      DIVX(I,J-1,K) + DIVX(I-1,J-1,K))                     23DEC04.2974
>                UCMONA = UA(I+1,J,K)   + 2.*UA(I,J,K)   + UA(I-1,J,K)             23DEC04.2975
>                VCMONA = VA(I,J+1,K)   + 2.*VA(I,J,K)   + VA(I,J-1,K)             23DEC04.2976
>                UCMONB = UA(I+1,J+1,K) + 2.*UA(I,J+1,K) + UA(I-1,J+1,K)           23DEC04.2977
>                VCMONB = VA(I+1,J+1,K) + 2.*VA(I+1,J,K) + VA(I+1,J-1,K)           23DEC04.2978
>                UCMONC = UA(I+1,J-1,K) + 2.*UA(I,J-1,K) + UA(I-1,J-1,K)           23DEC04.2979
>                VCMONC = VA(I-1,J+1,K) + 2.*VA(I-1,J,K) + VA(I-1,J-1,K)           23DEC04.2980
>                DIAG   = DIVD - DXXMSF(I)*( (UCMONB - UCMONC)                     23DEC04.2981
>      &                                   + (VCMONB - VCMONC) )                   23DEC04.2982
>                UCMONB = UCMONB + UCMONA                                          23DEC04.2983
>                VCMONB = VCMONB + VCMONA                                          23DEC04.2984
>                UCMONC = UCMONC + UCMONA                                          23DEC04.2985
>                VCMONC = VCMONC + VCMONA                                          23DEC04.2986
>                UTEN(I,J,K) =  U3D(I,J,K)*DIAG -                                  23DEC04.2987
>      &                        DXXMSF(I)*( U3D(I,J+1,K)*UCMONB                    23DEC04.2988
>      &                                  - U3D(I,J-1,K)*UCMONC                    23DEC04.2989
>      &                                  + U3D(I+1,J,K)*VCMONB                    23DEC04.2990
>      &                                  - U3D(I-1,J,K)*VCMONC )                  23DEC04.2991
>                VTEN(I,J,K) =  V3D(I,J,K)*DIAG -                                  23DEC04.2992
>      &                        DXXMSF(I)*( V3D(I,J+1,K)*UCMONB                    23DEC04.2993
>      &                                  - V3D(I,J-1,K)*UCMONC                    23DEC04.2994
>      &                                  + V3D(I+1,J,K)*VCMONB                    23DEC04.2995
>      &                                  - V3D(I-1,J,K)*VCMONC )                  23DEC04.2996
>             ENDDO                                                                23DEC04.2997
>                                                                                  23DEC04.2998
>             !!         Coriolis and curvature terms                              23DEC04.2999
>                                                                                  23DEC04.3000
>             DO  I=2+ICUT,ILX-ICUT                                                23DEC04.3001
>                WABAR = WADOT(I,K) + WADOT(I,K+1)                                 23DEC04.3002
>                AMFAC = WABAR*RPDOTA(I,J)*REARTH                                  23DEC04.3003
>                DUV   = UCD(I,J,K)*DMDY(I,J) - VCD(I,J,K)*DMDX(I,J)               23DEC04.3004
>                UTEN(I,J,K) = UTEN(I,J,K) + F(I,J)*VCD(I,J,K)    !  H. Coriolis   23DEC04.3005
>      &                                   - EFC(I)*WABAR         !  V. Coriolis   23DEC04.3006
>      &                                   + V3D(I,J,K)*DUV       !  XY-curvature  23DEC04.3007
>      &                                   - UCD(I,J,K)*AMFAC     !  Z-curvature   23DEC04.3008
>                VTEN(I,J,K) = VTEN(I,J,K) - F(I,J)*UCD(I,J,K)                     23DEC04.3009
>      &                                   + EFS(I)*WABAR                          23DEC04.3010
>      &                                   - U3D(I,J,K)*DUV                        23DEC04.3011
>      &                                   - VCD(I,J,K)*AMFAC                      23DEC04.3012
>             ENDDO                                                                23DEC04.3013
>                                                                                  23DEC04.3014
>             IF ( K .EQ. 1 ) GO TO  99   !! no vertical advection at k=1          23DEC04.3015
>                                                                                  23DEC04.3016
>             !!         Vertical advection                                        23DEC04.3017
>                                                                                  23DEC04.3018
>             DO  I=2+ICUT,ILX-ICUT                                                23DEC04.3019
>                QQ  = 0.25*( QDOT(I,J  ,K) + QDOT(I-1,J  ,K)                      23DEC04.3020
>      &                    + QDOT(I,J-1,K) + QDOT(I-1,J-1,K))                     23DEC04.3021
>                UU = QQ*( TWT(K,1)*UCD(I,J,K) + TWT(K,2)*UCD(I,J,K-1) )           23DEC04.3022
>                UTEN(I,J,K-1) = UTEN(I,J,K-1) - UU*DDS(K-1)                       23DEC04.3023
>                UTEN(I,J,K  ) = UTEN(I,J,K  ) + UU*DDS(K  )                       23DEC04.3024
>                VV = QQ*( TWT(K,1)*VCD(I,J,K) + TWT(K,2)*VCD(I,J,K-1) )           23DEC04.3025
>                VTEN(I,J,K-1) = VTEN(I,J,K-1) - VV*DDS(K-1)                       23DEC04.3026
>                VTEN(I,J,K  ) = VTEN(I,J,K  ) + VV*DDS(K  )                       23DEC04.3027
>             END DO                                                               23DEC04.3028
>                                                                                  23DEC04.3029
>   99        CONTINUE    !!  target of "if K=1" (no vertical advection)           23DEC04.3030
>                                                                                  23DEC04.3031
>          END DO         !!  end loop on K                                        23DEC04.3032
>                                                                                  23DEC04.3033
>       ENDDO             !!  end parallel loop on J                               23DEC04.3034
>                                                                                  23DEC04.3035
>       RETURN                                                                     23DEC04.3036
>                                                                                  23DEC04.3037
>       END                                                                        23DEC04.3038
>                                                                                  23DEC04.3039
===================================================================
physics/advection/simple/vadv.F
diff -r3.8 -r3.10
17c17
< C     F      : IS THE WORKING SPACE USED TO STORE THE INTERLATED      C          VADV.17
---
> C     F      : IS THE WORKING SPACE USED TO STORE THE INTERPOLATED    C          VADV.17
31,144c31,138
<       REAL      EPSI                                                             07NOV00.1193
<       PARAMETER (EPSI=1.E-15)                                                    07NOV00.1194
< #       include <parame.incl>                                                    VADV.31
< #       include <param3.incl>                                                    VADV.32
< #       include <various.incl>                                                   VADV.33
< #       include <nhcnst.incl>                                                    VADV.34
< C                                                                                VADV.35
<       INTEGER   KZZ,IND,IN                                                       07NOV00.1195
<       REAL      FTEN(MIX,MJX,KZZ),QDOT(MIX,MJX,KXP1)                             VADV.37
<       REAL        FA(MIX,MJX,KZZ), PSA(MIX,MJX)                                  VADV.38
<       REAL         F(MIX,MJX,KXP1),DOTQDOT(MIX,KXP1)                             VADV.39
< C                                                                                VADV.40
<       REAL      PA287                                                            07NOV00.1196
<       REAL      PS287                                                            07NOV00.1197
<       INTEGER   ICUT,I,J,K                                                       VADV.43
< C                                                                                VADV.44
< C                                                                                VADV.45
<       ICUT=0                                                                     VADV.46
<       IF(IN.GT.1)ICUT=1                                                          VADV.47
< C                                                                                VADV.48
< C----------------------------------------------------------------------          VADV.49
< C                                                                                VADV.50
<       GOTO (10,40,40,150,210,65),IND                                             VADV.51
< C                                                                                VADV.52
< C-----VERTICAL ADVECTION TERMS FOR:                                              VADV.53
< C                                                                                VADV.54
<    10 CONTINUE                                                                   VADV.55
< C                                                                                VADV.56
< C.....INTERPOLATE TA TO FULL SIGMA LEVELS:                                       VADV.57
< C                                                                                VADV.58
< cmic$ do all autoscope                                                           VADV.59
< c$doacross                                                                       VADV.60
< c$& local(i,j,k,dotqdot,pa287,ps287)                                             07NOV00.1198
< c$omp parallel do default(shared)                                                VADV.62
< c$omp&private(i,j,k,dotqdot,pa287,ps287)                                         07NOV00.1199
<       DO J=2+ICUT,JLXM-ICUT                                                      VADV.64
<         DO K=1,KL                                                                VADV.65
<           DO I=2+ICUT,ILXM-ICUT                                                  VADV.66
<             PA287=1.0/(PSA(I,J)*A(K)+PTOP)**0.287                                07NOV00.1200
<             DOTQDOT(I,K)=FA(I,J,K)*PA287                                         07NOV00.1201
<           ENDDO                                                                  VADV.70
<         ENDDO                                                                    VADV.71
<         DO K=2,KL                                                                VADV.72
<           DO I=2+ICUT,ILXM-ICUT                                                  VADV.73
<             PS287=(PSA(I,J)*SIGMA(K)+PTOP)**0.287                                07NOV00.1202
<             F(I,J,K)=PS287*(TWT(K,1)*DOTQDOT(I,K)+TWT(K,2)*                      07NOV00.1203
<      +               DOTQDOT(I,K-1))                                             VADV.75
<           ENDDO                                                                  VADV.76
<         ENDDO                                                                    VADV.77
<       ENDDO                                                                      VADV.78
< C                                                                                VADV.79
<       GOTO 70                                                                    VADV.80
< C                                                                                VADV.81
< C-----VERTICAL ADVECTION TERM FOR QV:                                            VADV.82
< C                                                                                VADV.83
<    40 CONTINUE                                                                   VADV.84
< C                                                                                VADV.85
< C.....INTERPOLATE QV TO FULL SIGMA LEVELS:                                       VADV.86
< C                                                                                VADV.87
< cmic$ do all autoscope                                                           VADV.88
< c$doacross                                                                       VADV.89
< c$& local(i,j,k)                                                                 VADV.90
< c$omp parallel do default(shared)                                                VADV.91
< c$omp&private(i,j,k)                                                             VADV.92
<       DO 60 J=2+ICUT,JLXM-ICUT                                                   VADV.93
<         DO 60 K=2,KL                                                             VADV.94
<           DO 60 I=2+ICUT,ILXM-ICUT                                               VADV.95
<             IF(FA(I,J,K).GT.EPSI.AND.FA(I,J,K-1).GT.EPSI)THEN                    25JAN00.464
<               F(I,J,K)=FA(I,J,K)*(FA(I,J,K-1)/FA(I,J,K))**QCON(K)                25JAN00.465
<             ELSE                                                                 25JAN00.466
<               F(I,J,K)=0.                                                        25JAN00.467
<             ENDIF                                                                25JAN00.468
<    60     CONTINUE                                                               VADV.97
<                                                                                  VADV.98
<                                                                                  VADV.99
< C                                                                                VADV.100
< C.....K = 1                                                                      VADV.101
< C                                                                                VADV.102
<       GOTO 70                                                                    VADV.103
< C----- VERTICAL ADVECTION TERM FOR PP                                            VADV.104
<    65 CONTINUE                                                                   VADV.105
< cmic$ do all autoscope                                                           VADV.106
< c$doacross                                                                       VADV.107
< c$& local(i,j,k)                                                                 VADV.108
< c$omp parallel do default(shared)                                                VADV.109
< c$omp&private(i,j,k)                                                             VADV.110
<       DO 66 J=2+ICUT,JLXM-ICUT                                                   24SEP99.413
<         DO 66 K=2,KL                                                             VADV.112
<           DO 66 I=2+ICUT,ILXM-ICUT                                               24SEP99.414
<             F(I,J,K)=TWT(K,1)*FA(I,J,K)+TWT(K,2)*FA(I,J,K-1)                     VADV.114
<    66     CONTINUE                                                               VADV.115
<                                                                                  VADV.116
<                                                                                  VADV.117
< C                                                                                VADV.118
< C                                                                                VADV.119
< C                                                                                VADV.120
<    70 CONTINUE                                                                   VADV.121
< cmic$ do all autoscope                                                           VADV.122
< c$doacross                                                                       VADV.123
< c$& local(i,j,k)                                                                 VADV.124
< c$omp parallel do default(shared)                                                VADV.125
< c$omp&private(i,j,k)                                                             VADV.126
<       DO J=2+ICUT,JLXM-ICUT                                                      VADV.127
<         DO 80 I=2+ICUT,ILXM-ICUT                                                 VADV.128
<           FTEN(I,J,1)=FTEN(I,J,1)-QDOT(I,J,2)*F(I,J,2)/DSIGMA(1)                 VADV.129
<    80   CONTINUE                                                                 VADV.130
< C                                                                                VADV.131
< C.....K = 2,KLM                                                                  VADV.132
< C                                                                                VADV.133
<         DO 90 K=2,KLM                                                            VADV.134
<           DO 90 I=2+ICUT,ILXM-ICUT                                               VADV.135
<             FTEN(I,J,K)=FTEN(I,J,K)-(QDOT(I,J,K+1)*F(I,J,K+1)-                   VADV.136
<      +                  QDOT(I,J,K)*F(I,J,K))/DSIGMA(K)                          VADV.137
<    90     CONTINUE                                                               VADV.138
---
>       REAL      EPSI                                                             VADV.31
>       PARAMETER (EPSI=1.E-15)                                                    VADV.32
> #       include <parame.incl>                                                    VADV.33
> #       include <param3.incl>                                                    VADV.34
> #       include <various.incl>                                                   VADV.35
> #       include <nhcnst.incl>                                                    VADV.36
>                                                                                  VADV.37
> C.......  Arguments                                                              VADV.38
>                                                                                  VADV.39
>       INTEGER   KZZ,IND,IN                                                       VADV.40
>       REAL      FTEN(MIX,MJX,KZZ),QDOT(MIX,MJX,KXP1)                             VADV.41
>       REAL        FA(MIX,MJX,KZZ), PSA(MIX,MJX)                                  VADV.42
>                                                                                  VADV.43
> C.......  Local Variables:                                                       VADV.44
>                                                                                  VADV.45
>       REAL      DOTQDOT(MIX,KXP1)                                                VADV.46
>       REAL      PA287                                                            VADV.47
>       REAL      PS287                                                            VADV.48
>       INTEGER   ICUT,I,J,K                                                       VADV.49
>                                                                                  VADV.50
>       REAL      FF, QQ                                                           VADV.51
>       REAL      DDS(KXP1)                                                        VADV.52
>                                                                                  VADV.53
> C----------------------------------------------------------------------          VADV.54
>                                                                                  VADV.55
>       ICUT=0                                                                     VADV.56
>       IF(IN.GT.1)ICUT=1                                                          VADV.57
>                                                                                  VADV.58
>       GOTO (10,40,40,150,210,65),IND                                             VADV.59
> C                                                                                VADV.60
> C-----Vertical advection terms for:                                              VADV.61
> C                                                                                VADV.62
>    10 CONTINUE                                                                   VADV.63
>                                                                                  VADV.64
>       DO K=1,KL                                                                  VADV.65
>           DDS(K) = 1.0 / DSIGMA(K)                                               VADV.66
>       END DO                                                                     VADV.67
>                                                                                  VADV.68
> C                                                                                VADV.69
> C.....Interpolate TA to full sigma levels:                                       VADV.70
> C                                                                                VADV.71
> cmic$ do all autoscope                                                           VADV.72
> c$doacross                                                                       VADV.73
> c$&     local(i,j,k,dotqdot,pa287,ps287,FF)                                      VADV.74
> c$omp parallel do default(shared)                                                VADV.75
> c$omp&private(i,j,k,dotqdot,pa287,ps287,FF)                                      VADV.76
>                                                                                  VADV.77
>       DO J=2+ICUT,JLXM-ICUT                                                      VADV.78
>                                                                                  VADV.79
>           K=1                                                                    VADV.80
>           DO I=2+ICUT,ILXM-ICUT                                                  VADV.81
>               !! pa287 = 1.0/(psa(i,j)*a(k)+ptop)**0.287                         VADV.82
>               PA287 = EXP( -0.287*LOG( PSA(I,J)*A(K) + PTOP ) )                  VADV.83
>               DOTQDOT(I,K) = FA(I,J,K)*PA287                                     VADV.84
>           END DO                                                                 VADV.85
>                                                                                  VADV.86
>           DO K=2,KL                                                              VADV.87
>           DO I=2+ICUT,ILXM-ICUT                                                  VADV.88
>               !!  PA287 = 1.0/(PSA(I,J)*A(K)+PTOP)**0.287                        VADV.89
>               !!  PS287 = (PSA(I,J)*SIGMA(K)+PTOP)**0.287                        VADV.90
>               PA287 = EXP( -0.287*LOG( PSA(I,J)*A(K)     + PTOP ) )              VADV.91
>               PS287 = EXP(  0.287*LOG( PSA(I,J)*SIGMA(K) + PTOP ) )              VADV.92
>               DOTQDOT(I,K) = FA(I,J,K)*PA287                                     VADV.93
>               FF = PS287*QDOT(I,J,K)*( TWT(K,1)*DOTQDOT(I,K)                     VADV.94
>      +                               + TWT(K,2)*DOTQDOT(I,K-1))                  VADV.95
>               FTEN(I,J,K-1) = FTEN(I,J,K-1) - FF*DDS(K-1)                        VADV.96
>               FTEN(I,J,K  ) = FTEN(I,J,K  ) + FF*DDS(K  )                        VADV.97
>           END DO                                                                 VADV.98
>           END DO                                                                 VADV.99
>                                                                                  VADV.100
>       END DO                                                                     VADV.101
>                                                                                  VADV.102
>       RETURN                                                                     VADV.103
> C                                                                                VADV.104
> C-----Vertical advection term for QV:                                            VADV.105
> C                                                                                VADV.106
>    40 CONTINUE                                                                   VADV.107
>                                                                                  VADV.108
>       DO K=1,KL                                                                  VADV.109
>           DDS(K) = 1.0 / DSIGMA(K)                                               VADV.110
>       END DO                                                                     VADV.111
>                                                                                  VADV.112
> C                                                                                VADV.113
> C.....Interpolate QV to full sigma levels:                                       VADV.114
> C                                                                                VADV.115
> cmic$ do all autoscope                                                           VADV.116
> c$doacross                                                                       VADV.117
> c$&     local(i,j,k,FF)                                                          VADV.118
> c$omp parallel do default(shared)                                                VADV.119
> c$omp&private(i,j,k,FF)                                                          VADV.120
>                                                                                  VADV.121
>       DO J=2+ICUT,JLXM-ICUT                                                      VADV.122
>                                                                                  VADV.123
>           DO  K=2,KL                                                             VADV.124
>           DO  I=2+ICUT,ILXM-ICUT                                                 VADV.125
>               IF(FA(I,J,K).GT.EPSI.AND.FA(I,J,K-1).GT.EPSI)THEN                  VADV.126
>                   FF = FA(I,J,K) * (FA(I,J,K-1)/FA(I,J,K))**QCON(K)              VADV.127
>                   FF = QDOT(I,J,K)*FF                                            VADV.128
>                   FTEN(I,J,K-1) = FTEN(I,J,K-1) - FF*DDS(K-1)                    VADV.129
>                   FTEN(I,J,K  ) = FTEN(I,J,K  ) + FF*DDS(K  )                    VADV.130
>               END IF                                                             VADV.131
>           END DO                                                                 VADV.132
>           END DO                                                                 VADV.133
>                                                                                  VADV.134
>       END DO                                                                     VADV.135
>                                                                                  VADV.136
>       RETURN                                                                     VADV.137
>                                                                                  VADV.138
146,173c140,167
< C                                                                                VADV.140
< C,....K = KL                                                                     VADV.141
< C                                                                                VADV.142
<         DO 100 I=2+ICUT,ILXM-ICUT                                                VADV.143
<           FTEN(I,J,KL)=FTEN(I,J,KL)+QDOT(I,J,KL)*F(I,J,KL)/DSIGMA(KL)            VADV.144
<   100   CONTINUE                                                                 VADV.145
<       ENDDO                                                                      VADV.146
< C                                                                                VADV.147
<       RETURN                                                                     VADV.148
< C                                                                                VADV.149
< C-----VERTICAL ADVECTION TERMS FOR U AND V:                                      VADV.150
< C                                                                                VADV.151
<   150 CONTINUE                                                                   VADV.152
< C                                                                                VADV.153
< C.....INTERPOLATE UA OR VA TO FULL SIGMA LEVELS:                                 VADV.154
< C                                                                                VADV.155
< cmic$ do all autoscope                                                           VADV.156
< c$doacross                                                                       VADV.157
< c$& local(i,j,k,dotqdot)                                                         VADV.158
< c$omp parallel do default(shared)                                                VADV.159
< c$omp&private(i,j,k,dotqdot)                                                     VADV.160
<       DO J=2+ICUT,JLX-ICUT                                                       VADV.161
<         DO 170 K=2,KL                                                            VADV.162
<           DO 170 I=2+ICUT,ILX-ICUT                                               VADV.163
<             F(I,J,K)=(TWT(K,1)*FA(I,J,K)+TWT(K,2)*FA(I,J,K-1))                   VADV.164
<             DOTQDOT(I,K)=0.25*(QDOT(I,J,K)+QDOT(I-1,J,K)+QDOT(I,J-1,K)+          VADV.165
<      +                   QDOT(I-1,J-1,K))                                        VADV.166
<   170     CONTINUE                                                               VADV.167
---
> C----- Vertical advection term for PP                                            VADV.140
>                                                                                  VADV.141
>    65 CONTINUE                                                                   VADV.142
>                                                                                  VADV.143
>       DO K=1,KL                                                                  VADV.144
>           DDS(K) = 1.0 / DSIGMA(K)                                               VADV.145
>       END DO                                                                     VADV.146
>                                                                                  VADV.147
> cmic$ do all autoscope                                                           VADV.148
> c$doacross                                                                       VADV.149
> c$&     local(i,j,k,FF)                                                          VADV.150
> c$omp parallel do default(shared)                                                VADV.151
> c$omp&private(i,j,k,FF)                                                          VADV.152
>                                                                                  VADV.153
>       DO J=2+ICUT,JLXM-ICUT                                                      VADV.154
>                                                                                  VADV.155
>           DO  K=2,KL                                                             VADV.156
>           DO  I=2+ICUT,ILXM-ICUT                                                 VADV.157
>               FF = TWT(K,1)*FA(I,J,K)+TWT(K,2)*FA(I,J,K-1)                       VADV.158
>               FF = QDOT(I,J,K)*FF                                                VADV.159
>               FTEN(I,J,K-1) = FTEN(I,J,K-1) - FF*DDS(K-1)                        VADV.160
>               FTEN(I,J,K  ) = FTEN(I,J,K  ) + FF*DDS(K  )                        VADV.161
>           END DO                                                                 VADV.162
>           END DO                                                                 VADV.163
>                                                                                  VADV.164
>       END DO                                                                     VADV.165
>                                                                                  VADV.166
>       RETURN                                                                     VADV.167
175,176c169,170
< C                                                                                VADV.169
< C.....K = 1                                                                      VADV.170
---
>                                                                                  VADV.169
> C-----Vertical advection terms for U and V:                                      VADV.170
178,225c172,232
<         DO 180 I=2+ICUT,ILX-ICUT                                                 VADV.172
<           FTEN(I,J,1)=FTEN(I,J,1)-DOTQDOT(I,2)*F(I,J,2)/DSIGMA(1)                VADV.173
<   180   CONTINUE                                                                 VADV.174
< C                                                                                VADV.175
< C.....K = 2,KLM                                                                  VADV.176
< C                                                                                VADV.177
<         DO 190 K=2,KLM                                                           VADV.178
<           DO 190 I=2+ICUT,ILX-ICUT                                               VADV.179
<             FTEN(I,J,K)=FTEN(I,J,K)-(DOTQDOT(I,K+1)*F(I,J,K+1)-                  VADV.180
<      +                  DOTQDOT(I,K)*F(I,J,K))/DSIGMA(K)                         VADV.181
<   190     CONTINUE                                                               VADV.182
<                                                                                  VADV.183
< C                                                                                VADV.184
< C.....K = KL                                                                     VADV.185
< C                                                                                VADV.186
<         DO 200 I=2+ICUT,ILX-ICUT                                                 VADV.187
<           FTEN(I,J,KL)=FTEN(I,J,KL)+DOTQDOT(I,KL)*F(I,J,KL)/DSIGMA(KL)           VADV.188
<   200   CONTINUE                                                                 VADV.189
<       ENDDO                                                                      VADV.190
<       RETURN                                                                     VADV.191
< C                                                                                VADV.192
< C --- VERTICAL ADVECTION OF W                                                    VADV.193
< C                                                                                VADV.194
<   210 CONTINUE                                                                   VADV.195
< cmic$ do all autoscope                                                           VADV.196
< c$doacross                                                                       VADV.197
< c$& local(i,j,k,dotqdot)                                                         VADV.198
< c$omp parallel do default(shared)                                                VADV.199
< c$omp&private(i,j,k,dotqdot)                                                     VADV.200
<       DO J=2+ICUT,JLXM-ICUT                                                      VADV.201
<         DO K=1,KL                                                                VADV.202
<           DO I=2+ICUT,ILXM-ICUT                                                  VADV.203
<             DOTQDOT(I,K)=(QDOT(I,J,K)+QDOT(I,J,K+1))                             VADV.204
<             F(I,J,K)=0.5*(FA(I,J,K)+FA(I,J,K+1))                                 VADV.205
<           ENDDO                                                                  VADV.206
<         ENDDO                                                                    VADV.207
<         DO K=2,KL                                                                VADV.208
<           DO I=2+ICUT,ILXM-ICUT                                                  VADV.209
<             FTEN(I,J,K)=FTEN(I,J,K)-(DOTQDOT(I,K)*F(I,J,K)-                      VADV.210
<      +                  DOTQDOT(I,K-1)*F(I,J,K-1))/(DSIGMA(K)+                   VADV.211
<      +                  DSIGMA(K-1))                                             VADV.212
<           ENDDO                                                                  VADV.213
<         ENDDO                                                                    VADV.214
<       ENDDO                                                                      VADV.215
< C                                                                                VADV.216
<       RETURN                                                                     VADV.217
<       END                                                                        VADV.218
<                                                                                  VADV.219
---
>   150 CONTINUE                                                                   VADV.172
>                                                                                  VADV.173
>       DO K=1,KL                                                                  VADV.174
>           DDS(K) = 1.0 / DSIGMA(K)                                               VADV.175
>       END DO                                                                     VADV.176
>                                                                                  VADV.177
> C                                                                                VADV.178
> C.....Interpolate UA or VA to full sigma levels:                                 VADV.179
> C                                                                                VADV.180
> cmic$ do all autoscope                                                           VADV.181
> c$doacross                                                                       VADV.182
> c$&     local(i,j,k,FF,QQ)                                                       VADV.183
> c$omp parallel do default(shared)                                                VADV.184
> c$omp&private(i,j,k,FF,QQ)                                                       VADV.185
>                                                                                  VADV.186
>       DO J=2+ICUT,JLX-ICUT                                                       VADV.187
>                                                                                  VADV.188
>           DO  K=2,KL                                                             VADV.189
>           DO  I=2+ICUT,ILX-ICUT                                                  VADV.190
>               QQ  = 0.25*( QDOT(I,J  ,K) + QDOT(I-1,J  ,K)                       VADV.191
>      +                   + QDOT(I,J-1,K) + QDOT(I-1,J-1,K))                      VADV.192
>               FF = QQ*( TWT(K,1)*FA(I,J,K) + TWT(K,2)*FA(I,J,K-1) )              VADV.193
>               FTEN(I,J,K-1) = FTEN(I,J,K-1) - FF*DDS(K-1)                        VADV.194
>               FTEN(I,J,K  ) = FTEN(I,J,K  ) + FF*DDS(K  )                        VADV.195
>           END DO                                                                 VADV.196
>           END DO                                                                 VADV.197
>                                                                                  VADV.198
>       END DO                                                                     VADV.199
>                                                                                  VADV.200
>       RETURN                                                                     VADV.201
> C                                                                                VADV.202
> C --- Vertical advection of W                                                    VADV.203
> C                                                                                VADV.204
>   210 CONTINUE                                                                   VADV.205
>                                                                                  VADV.206
>       DO K=2,KL+1                                                                VADV.207
>           DDS(K) = 1.0 / (DSIGMA(K) + DSIGMA(K-1))                               VADV.208
>       END DO                                                                     VADV.209
>                                                                                  VADV.210
> cmic$ do all autoscope                                                           VADV.211
> c$doacross                                                                       VADV.212
> c$&     local(i,j,k,FF,QQ)                                                       VADV.213
> c$omp parallel do default(shared)                                                VADV.214
> c$omp&private(i,j,k,FF,QQ)                                                       VADV.215
>                                                                                  VADV.216
>       DO J=2+ICUT,JLX-ICUT                                                       VADV.217
>                                                                                  VADV.218
>           DO K=2,KL                                                              VADV.219
>           DO I=2+ICUT,ILXM-ICUT                                                  VADV.220
>               QQ = 0.5*(QDOT(I,J,K) + QDOT(I,J,K+1))                             VADV.221
>               FF = QQ*(FA(I,J,K) + FA(I,J,K+1))                                  VADV.222
>               FTEN(I,J,K+1) = FTEN(I,J,K+1) + FF*DDS(K+1)                        VADV.223
>               FTEN(I,J,K  ) = FTEN(I,J,K  ) - FF*DDS(K  )                        VADV.224
>           END DO                                                                 VADV.225
>           END DO                                                                 VADV.226
>                                                                                  VADV.227
>       END DO                                                                     VADV.228
>                                                                                  VADV.229
>       RETURN                                                                     VADV.230
>       END                                                                        VADV.231
>                                                                                  VADV.232
===================================================================
physics/cumulus/bm/cupara7.F
diff -r3.2 -r3.4
16c16
<       REAL XLAND(MIX,MKX)                                                        07NOV00.1212
---
>       REAL XLAND(MIX,MJX)                                                        23DEC04.3040
===================================================================
physics/cumulus/grell/cup.F
diff -r3.8 -r3.11
51a52,54
> #ifdef IBMopt                                                                    23DEC04.3041
>       real zzz,zz1                                                               23DEC04.3042
> #endif                                                                           23DEC04.3043
65a69,78
> #ifdef IBMopt                                                                    23DEC04.3044
>       real plog(mix,mkx),polog(mix,mkx),psurlog(mix)                             23DEC04.3045
>       real temp1(mix),temp2(mix),e1                                              23DEC04.3046
>       integer ind1(mix),icount1,is,nn                                            23DEC04.3047
> #ifdef MPP1                                                                      23DEC04.3048
> #define nf(A) noflic(A)
> #else                                                                            23DEC04.3050
> #define nf(A) A       
> #endif                                                                           23DEC04.3052
> #endif                                                                           23DEC04.3053
93a107,115
> #ifdef IBMopt                                                                    23DEC04.3054
> #ifdef MPP1                                                                      23DEC04.3055
>       nn = ie_x0(IEN) - is_x0(IST) + 1                                           23DEC04.3056
>       is = is_x0(IST)                                                            23DEC04.3057
> #else                                                                            23DEC04.3058
>       nn = IEN - IST + 1                                                         23DEC04.3059
>       is = IST                                                                   23DEC04.3060
> #endif                                                                           23DEC04.3061
> #endif                                                                           23DEC04.3062
97a120
> #ifndef IBMopt                                                                   23DEC04.3063
98a122,124
> #else                                                                            23DEC04.3064
>         DO  I=IST,IEN                                                            23DEC04.3065
> #endif                                                                           23DEC04.3066
103a130
> #ifndef IBMopt                                                                   23DEC04.3067
105a133,144
> #else                                                                            23DEC04.3068
>           temp1(i)=AE(IPH)-BE(IPH)/T(I,K)                                        23DEC04.3069
>           temp2(i)=AE(IPHO)-BE(IPHO)/TN(I,K)                                     23DEC04.3070
>         ENDDO                                                                    23DEC04.3071
>                                                                                  23DEC04.3072
>         call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                               23DEC04.3073
>         call vsexp(temp2(nf(is)),temp2(nf(is)),nn)                               23DEC04.3074
>                                                                                  23DEC04.3075
>          DO I=IST,IEN                                                            23DEC04.3076
>             E=temp1(i)                                                           23DEC04.3077
>             EO=temp2(i)                                                          23DEC04.3078
> #endif                                                                           23DEC04.3079
113a153,155
> #ifdef IBMopt                                                                    23DEC04.3080
>         ENDDO                                                                    23DEC04.3081
> #endif                                                                           23DEC04.3082
114a157,163
> #ifdef IBMopt                                                                    23DEC04.3083
>          k=1                                                                     23DEC04.3084
>                                                                                  23DEC04.3085
>          call vslog(plog(nf(is),k),p(nf(is),k),nn)                               23DEC04.3086
>          call vslog(polog(nf(is),k),po(nf(is),k),nn)                             23DEC04.3087
>          call vslog(psurlog(nf(is)),psur(nf(is)),nn)                             23DEC04.3088
> #endif                                                                           23DEC04.3089
144a194
> #ifndef IBMopt                                                                   23DEC04.3090
146a197,200
> #else                                                                            23DEC04.3091
>         Z(I,1)=Z1(I)-(plog(I,1)-psurlog(I))*RD*TV(I,1)/9.81                      23DEC04.3092
>         ZO(I,1)=Z1(I)-(polog(I,1)-psurlog(I))*RD*TVO(I,1)/9.81                   23DEC04.3093
> #endif                                                                           23DEC04.3094
148a203,208
> #ifdef IBMopt                                                                    23DEC04.3095
>                                                                                  23DEC04.3096
>          call vslog(plog(nf(is),k),p(nf(is),k),nn)                               23DEC04.3097
>          call vslog(polog(nf(is),k),po(nf(is),k),nn)                             23DEC04.3098
>                                                                                  23DEC04.3099
> #endif                                                                           23DEC04.3100
150a211
> #ifndef IBMopt                                                                   23DEC04.3101
151a213,215
> #else                                                                            23DEC04.3102
>           Z(I,K)=Z(I,K-1)-(plog(I,K)-plog(I,K-1))*RD*TVBAR/9.81                  23DEC04.3103
> #endif                                                                           23DEC04.3104
152a217
> #ifndef IBMopt                                                                   23DEC04.3105
154a220,223
> #else                                                                            23DEC04.3106
>           ZO(I,K)=ZO(I,K-1)-(polog(I,K)-polog(I,K-1))*RD*TVBARO/                 23DEC04.3107
>      +            9.81                                                           23DEC04.3108
> #endif                                                                           23DEC04.3109
570a640
> #ifndef IBMopt                                                                   23DEC04.3110
571a642,644
> #else                                                                            23DEC04.3111
>         XZ(I,1)=Z1(I)-(plog(I,1)-psurlog(I))*RD*XTV(I,1)/9.81                    23DEC04.3112
> #endif                                                                           23DEC04.3113
576a650
> #ifndef IBMopt                                                                   23DEC04.3114
577a652,654
> #else                                                                            23DEC04.3115
>           XZ(I,K)=XZ(I,K-1)-(plog(I,K)-plog(I,K-1))*RD*TVBAR/9.81                23DEC04.3116
> #endif                                                                           23DEC04.3117
728a806
> #ifndef IBMopt                                                                   23DEC04.3118
730a809,812
> #else                                                                            23DEC04.3119
>         F=(AA1(I)-AA0(I))                                                        23DEC04.3120
>         XK=(XAA0(I)-AA0(I))                                                      23DEC04.3121
> #endif                                                                           23DEC04.3122
733a816
> #ifndef IBMopt                                                                   23DEC04.3123
734a818,820
> #else                                                                            23DEC04.3124
>           XMB(I)=-F/XK * 5.e-03                                                  23DEC04.3125
> #endif                                                                           23DEC04.3126
767a854,856
> #ifdef IBMopt                                                                    23DEC04.3127
>         zz1 = log(1.-CLFRCV)                                                     23DEC04.3128
> #endif                                                                           23DEC04.3129
772a862,864
> #ifdef IBMopt                                                                    23DEC04.3130
>               zzz = exp(AKCLTH*zz1)                                              23DEC04.3131
> #endif                                                                           23DEC04.3132
774a867
> #ifndef IBMopt                                                                   23DEC04.3133
775a869,871
> #else                                                                            23DEC04.3134
>                 CLDFRA(I,KK)=1.- zzz                                             23DEC04.3135
> #endif                                                                           23DEC04.3136
===================================================================
physics/cumulus/grell/cupara3.F
diff -r3.3 -r3.5
75,79c75,84
<           IF(Q(I,K).LT.1.E-08)Q(I,K)=1.E-08                                      CUPARA3.61
<           TN(I,K)=T(I,K)+(T3DTEN(I,J,KK))*RPSA(I,J)*DTIME                        CUPARA3.62
<           QO(I,K)=Q(I,K)+(QV3DTEN(I,J,KK))*RPSA(I,J)*DTIME                       CUPARA3.63
<           P(I,K)=10.*PSB(I,J)*A(KK)+10.*PTOP+PP3D(I,J,KK)*0.01                   CUPARA3.64
<           IF(QO(I,K).LT.1.E-08)QO(I,K)=1.E-08                                    CUPARA3.65
---
> CB          IF(Q(I,K).LT.1.E-08)Q(I,K)=1.E-08                                    23DEC04.3137
> CB          TN(I,K)=T(I,K)+(T3DTEN(I,J,KK))*RPSA(I,J)*DTIME                      23DEC04.3138
> CB          QO(I,K)=Q(I,K)+(QV3DTEN(I,J,KK))*RPSA(I,J)*DTIME                     23DEC04.3139
> CB          P(I,K)=10.*PSB(I,J)*A(KK)+10.*PTOP+PP3D(I,J,KK)*0.01                 23DEC04.3140
> CB          IF(QO(I,K).LT.1.E-08)QO(I,K)=1.E-08                                  23DEC04.3141
>           Q(I,K)=amax1(Q(I,K),1.E-08)                                            23DEC04.3142
>           TN(I,K)=T(I,K)+(T3DTEN(I,J,KK))*(RPSA(I,J)*DTIME)                      23DEC04.3143
>           QO(I,K)=Q(I,K)+(QV3DTEN(I,J,KK))*(RPSA(I,J)*DTIME)                     23DEC04.3144
>           P(I,K)=10.*(PSB(I,J)*A(KK)+PTOP)+PP3D(I,J,KK)*0.01                     23DEC04.3145
>           QO(I,K)=amax1(QO(I,K),1.E-08)                                          23DEC04.3146
82c87,88
<           PSUR(I)=10.*PSB(I,J)+10.*PTOP+PP3D(I,J,MKX)*0.01                       CUPARA3.68
---
> CB          PSUR(I)=10.*PSB(I,J)+10.*PTOP+PP3D(I,J,MKX)*0.01                     23DEC04.3147
>           PSUR(I)=10.*(PSB(I,J)+PTOP)+PP3D(I,J,MKX)*0.01                         23DEC04.3148
87c93,94
<           TER11(I)=HT(I,J)/9.81                                                  CUPARA3.73
---
> CB          TER11(I)=HT(I,J)/9.81                                                23DEC04.3149
>           TER11(I)=HT(I,J)*0.1019368                                             23DEC04.3150
109c116,117
<       CALC=.5                                                                    CUPARA3.95
---
> CB      CALC=.5                                                                  23DEC04.3151
>       CALC=.05*dt                                                                23DEC04.3152
113c121,122
<         RAINC(I,J)=RAINC(I,J)+PRET(I)*CALC*DT*.1                                 CUPARA3.99
---
> CB        RAINC(I,J)=RAINC(I,J)+PRET(I)*CALC*DT*.1                               23DEC04.3153
>         RAINC(I,J)=RAINC(I,J)+PRET(I)*CALC                                       23DEC04.3154
===================================================================
physics/cumulus/kf2/dtfrz2.F
diff -r1.2 -r1.4
13c13
<       CP=1005.7*(1.+0.89*QU)                                                     DTFRZ2.13
---
>       CP=1004.*(1.+0.89*QU)                                                      23DEC04.3155
===================================================================
physics/cumulus/kf2/kfpara2.F
diff -r1.9 -r1.11
70a71,73
> C                                                                      C         23DEC04.3156
> C         KAIN (2004):  "The Kain-Fritsch Convective Parameterization: C         23DEC04.3157
> C         An update.  Journ. Appl. Meteor., 170-181                    C         23DEC04.3158
86,94d88
< C NOTE:  THE KAIN-FRITSCH SCHEME IS UNDER CONTINUED DEVELOPMENT.  IF   C         KFPARA2.86
< C        YOU WOULD LIKE TO BE NOTIFIED WHEN THERE ARE UPDATES OR       C         KFPARA2.87
< C        CHANGES TO THE SCHEME, OR IF YOU HAVE PROBLEMS, QUESTIONS, OR C         KFPARA2.88
< C        SUGGESTIONS PLEASE NOTIFY ME AT                               C         KFPARA2.89
< C                                                                      C         KFPARA2.90
< C                                  jkain@spock.nssl.ou.edu             C         KFPARA2.91
< C                                                                      C         KFPARA2.92
< C        JACK KAIN                                                     C         KFPARA2.93
< C        MARCH 1997                                                    C         KFPARA2.94
484,493c478,482
<         WABS=ABS(WKL)                                                            KFPARA2.484
<         IF(WABS.EQ.0.)THEN                                                       KFPARA2.485
<           WSIGNE=1.                                                              KFPARA2.486
<           DTLCL=0.                                                               KFPARA2.487
<           GOTO 26                                                                KFPARA2.488
<         ENDIF                                                                    KFPARA2.489
<         WSIGNE=WKL/WABS                                                          KFPARA2.490
<         DTLCL=4.64*WSIGNE*WABS**0.33                                             KFPARA2.491
<         DTLCL = AMAX1(DTLCL,0.)                                                  KFPARA2.492
<  26     continue                                                                 KFPARA2.493
---
>         IF(WKL.LT.0.0001)THEN                                                    23DEC04.3159
>           DTLCL=0.                                                               23DEC04.3160
>         ELSE                                                                     23DEC04.3161
>           DTLCL=4.64*WKL**0.33                                                   23DEC04.3162
>         ENDIF                                                                    23DEC04.3163
558,565c547,554
< c        GDT=G*DTLCL*(ZLCL-Z00(LC))/(TV0(LC)+TVEN)                               KFPARA2.558
< c        WLCL=1.+.5*WSIGNE*SQRT(ABS(GDT)+1.E-10)                                 KFPARA2.559
<         GDT=2.*G*(DTLCL+DTRH)*500./TVEN                                          KFPARA2.560
< c        WLCL=1.+0.5*WSIGNE*SQRT(ABS(GDT)+1.E-10)                                KFPARA2.561
<         WLCL=1.+0.5*SQRT(ABS(GDT)+1.E-10)                                        KFPARA2.562
< c       WLCL = AMIN1(WLCL,5.)                                                    KFPARA2.563
< c       WLCL = AMIN1(WLCL,4.)                                                    KFPARA2.564
<         WLCL = AMIN1(WLCL,3.)                                                    KFPARA2.565
---
>         DTTOT = DTLCL+DTRH                                                       23DEC04.3164
>         IF(DTTOT.GT.1.E-4)THEN                                                   23DEC04.3165
>           GDT=2.*G*DTTOT*500./TVEN                                               23DEC04.3166
>           WLCL=1.+0.5*SQRT(GDT)                                                  23DEC04.3167
>           WLCL = AMIN1(WLCL,3.)                                                  23DEC04.3168
>         ELSE                                                                     23DEC04.3169
>           WLCL=1.                                                                23DEC04.3170
>         ENDIF                                                                    23DEC04.3171
723,729c712,720
<          WABS=SQRT(ABS(WTW))                                                     KFPARA2.723
<          WU(NK1)=WTW/WABS                                                        KFPARA2.724
< C                                                                                KFPARA2.725
< C...IF VERT VELOCITY IS LESS THAN ZERO, EXIT THE UPDRAFT LOOP AND,               KFPARA2.726
< C...IF CLOUD IS TALL ENOUGH, FINALIZE UPDRAFT CALCULATIONS...                    KFPARA2.727
< C                                                                                KFPARA2.728
<          IF(WU(NK1).LT.0.)GOTO 65                                                KFPARA2.729
---
> C                                                                                23DEC04.3172
> C...IF VERT VELOCITY IS LESS THAN ZERO, EXIT THE UPDRAFT LOOP AND,               23DEC04.3173
> C...IF CLOUD IS TALL ENOUGH, FINALIZE UPDRAFT CALCULATIONS...                    23DEC04.3174
> C                                                                                23DEC04.3175
>          IF(WTW.LT.1.E-3)THEN                                                    23DEC04.3176
>            GOTO 65                                                               23DEC04.3177
>          ELSE                                                                    23DEC04.3178
>            WU(NK1)=SQRT(WTW)                                                     23DEC04.3179
>          ENDIF                                                                   23DEC04.3180
818c809,810
<         IF(TU10.EQ.TVQU(NK1))THEN                                                KFPARA2.818
---
>         TVDIFF = ABS(TU10-TVQU(NK1))                                             23DEC04.3181
>         IF(TVDIFF.LT.1.e-3)THEN                                                  23DEC04.3182
1741,1743c1733,1736
<           IF((UER(NK)-DER(NK)).GT.0.)AINCM1=EMS(NK)/((UER(NK)-DER(NK))*          KFPARA2.1741
<      +      TIMEC)                                                               KFPARA2.1742
<           AINCMX=AMIN1(AINCMX,AINCM1)                                            KFPARA2.1743
---
>          IF((UER(NK)-DER(NK)).GT.1.e-3)THEN                                      23DEC04.3183
>            AINCM1=EMS(NK)/((UER(NK)-DER(NK))*TIMEC)                              23DEC04.3184
>            AINCMX=AMIN1(AINCMX,AINCM1)                                           23DEC04.3185
>          ENDIF                                                                   23DEC04.3186
1820,1821c1813,1819
<             DTT1=0.75*DP(NK-1)/(ABS(OMG(NK))+1.E-10)                             KFPARA2.1820
<             DTT=AMIN1(DTT,DTT1)                                                  KFPARA2.1821
---
>             ABSOMG = ABS(OMG(NK))                                                23DEC04.3187
>             ABSOMGTC = ABSOMG*TIMEC                                              23DEC04.3188
>             FRDP = 0.75*DP(NK-1)                                                 23DEC04.3189
>             IF(ABSOMGTC.GT.FRDP)THEN                                             23DEC04.3190
>               DTT1 = FRDP/ABSOMG                                                 23DEC04.3191
>               DTT=AMIN1(DTT,DTT1)                                                23DEC04.3192
>             ENDIF                                                                23DEC04.3193
2055a2054,2058
>           IF(ABS(AINC-AINCOLD).LT.0.0001)THEN                                    23DEC04.3194
>             NOITR=1                                                              23DEC04.3195
>             AINC=AINCOLD                                                         23DEC04.3196
>             GOTO 255                                                             23DEC04.3197
>           ENDIF                                                                  23DEC04.3198
2085c2088,2093
<           AINC=AINC*STAB*ABE/(DABE+1.E-8)                                        KFPARA2.2085
---
>           IF(DABE.LT.1.e-4)THEN                                                  23DEC04.3199
>             NOITR=1                                                              23DEC04.3200
>             AINC=AINCOLD                                                         23DEC04.3201
>           ELSE                                                                   23DEC04.3202
>             AINC=AINC*STAB*ABE/DABE                                              23DEC04.3203
>           ENDIF                                                                  23DEC04.3204
2333c2341,2345
<         RELERR=ERR2*QINIT/(PPTFLX*TIMEC+1.E-10)                                  KFPARA2.2333
---
>         IF(PPTFLX.GT.0.)THEN                                                     23DEC04.3205
>           RELERR=ERR2*QINIT/(PPTFLX*TIMEC)                                       23DEC04.3206
>         ELSE                                                                     23DEC04.3207
>           RELERR=0.                                                              23DEC04.3208
>         ENDIF                                                                    23DEC04.3209
2488a2501
>                                                                                  23DEC04.3210
===================================================================
physics/cumulus/kf2/lutab.F
diff -r1.3 -r1.5
18c18
<       pttop=100.0                                                                LUTAB.18
---
>       pttop=5000.0                                                               23DEC04.3211
===================================================================
physics/cumulus/kf2/tpmix2.F
diff -r1.3 -r1.6
44,101c44,94
<       IF(QS.LE.QU)THEN                                                           TPMIX2.44
<         QNEW=QU-QS                                                               TPMIX2.45
<         QU=QS                                                                    TPMIX2.46
<         GOTO 96                                                                  TPMIX2.47
<       ENDIF                                                                      TPMIX2.48
< C                                                                                TPMIX2.49
< C   IF THE PARCEL IS SUBSATURATED, TEMPERATURE AND MIXING RATIO MUST BE          TPMIX2.50
< C   ADJUSTED...IF LIQUID WATER IS PRESENT, IT IS ALLOWED TO EVAPORATE            TPMIX2.51
< C                                                                                TPMIX2.52
<       QNEW=0.                                                                    TPMIX2.53
<       DQ=QS-QU                                                                   TPMIX2.54
<       QTOT=QLIQ+QICE                                                             TPMIX2.55
< C                                                                                TPMIX2.56
< C   IF THERE IS ENOUGH LIQUID OR ICE TO SATURATE THE PARCEL, TEMP STAYS AT ITS   TPMIX2.57
< C   WET BULB VALUE, VAPOR MIXING RATIO IS AT SATURATED LEVEL, AND THE MIXING     TPMIX2.58
< C   RATIOS OF LIQUID AND ICE ARE ADJUSTED TO MAKE UP THE ORIGINAL SATURATION     TPMIX2.59
< C   DEFICIT... OTHERWISE, ANY AVAILABLE LIQ OR ICE VAPORIZES AND APPROPRIATE     TPMIX2.60
< C   ADJUSTMENTS TO PARCEL TEMP; VAPOR, LIQUID, AND ICE MIXING RATIOS ARE MADE.   TPMIX2.61
< C                                                                                TPMIX2.62
< C...NOTE THAT THE LIQ AND ICE MAY BE PRESENT IN PROPORTIONS SLIGHTLY DIFFEREN    TPMIX2.63
< C   THAN SUGGESTED BY THE VALUE OF RATIO2...CHECK TO MAKE SURE THAT LIQ AND      TPMIX2.64
< C   ICE CONCENTRATIONS ARE NOT REDUCED TO BELOW ZERO WHEN EVAPORATION/           TPMIX2.65
< C   SUBLIMATION OCCURS...                                                        TPMIX2.66
< C                                                                                TPMIX2.67
< c...subsaturated values only occur in calculations involving various mixtures of TPMIX2.68
< c...updraft and environmental air for estimation of entrainment and detrainment. TPMIX2.69
< c...For these purposes, assume that reasonable estimates can be given using      TPMIX2.70
< c...liquid water saturation calculations only - i.e., ignore the effect of the   TPMIX2.71
< c...ice phase in this process only...                                            TPMIX2.72
< c                                                                                TPMIX2.73
<       IF(QTOT.GE.DQ)THEN                                                         TPMIX2.74
<         qliq=qliq-dq*qliq/qtot                                                   TPMIX2.75
<         qice=qice-dq*qice/qtot                                                   TPMIX2.76
<         QU=QS                                                                    TPMIX2.77
<         GOTO 96                                                                  TPMIX2.78
<       ELSE                                                                       TPMIX2.79
<         RLL=XLV0-XLV1*TEMP                                                       TPMIX2.80
<         CP=1005.7*(1.+0.89*QU)                                                   TPMIX2.81
<         IF(QTOT.LT.1.E-10)THEN                                                   TPMIX2.82
< C                                                                                TPMIX2.83
< C...IF NO LIQUID WATER OR ICE IS AVAILABLE, TEMPERATURE IS GIVEN BY:             TPMIX2.84
<           TEMP=TEMP+RLL*(DQ/(1.+DQ))/CP                                          TPMIX2.85
<           GOTO 96                                                                TPMIX2.86
<         ELSE                                                                     TPMIX2.87
< C                                                                                TPMIX2.88
< C...IF SOME LIQ WATER/ICE IS AVAILABLE, BUT NOT ENOUGH TO ACHIEVE SATURATION,    TPMIX2.89
< C   THE TEMPERATURE IS GIVEN BY:                                                 TPMIX2.90
< C                                                                                TPMIX2.91
<           TEMP=TEMP+RLL*((DQ-QTOT)/(1+DQ-QTOT))/CP                               TPMIX2.92
<           QU=QU+QTOT                                                             TPMIX2.93
<           QTOT=0.                                                                TPMIX2.94
<         ENDIF                                                                    TPMIX2.95
<         QLIQ=0.                                                                  TPMIX2.96
<         QICE=0.                                                                  TPMIX2.97
<       ENDIF                                                                      TPMIX2.98
< 96    TU=TEMP                                                                    TPMIX2.99
<       qnewlq=qnew                                                                TPMIX2.100
<       qnewic=0.                                                                  TPMIX2.101
---
>       DQ=QS-QU                                                                   23DEC04.3212
>       IF(DQ.LE.0.)THEN                                                           23DEC04.3213
>         QNEW=QU-QS                                                               23DEC04.3214
>         QU=QS                                                                    23DEC04.3215
>       ELSE                                                                       23DEC04.3216
> c                                                                                23DEC04.3217
> c   IF THE PARCEL IS SUBSATURATED, TEMPERATURE AND MIXING RATIO MUST BE          23DEC04.3218
> c   ADJUSTED...IF LIQUID WATER IS PRESENT, IT IS ALLOWED TO EVAPORATE            23DEC04.3219
> c                                                                                23DEC04.3220
>         QNEW=0.                                                                  23DEC04.3221
>         QTOT=QLIQ+QICE                                                           23DEC04.3222
> c                                                                                23DEC04.3223
> c   IF THERE IS ENOUGH LIQUID OR ICE TO SATURATE THE PARCEL, TEMP STAYS AT ITS   23DEC04.3224
> c   WET BULB VALUE, VAPOR MIXING RATIO IS AT SATURATED LEVEL, AND THE MIXING     23DEC04.3225
> c   RATIOS OF LIQUID AND ICE ARE ADJUSTED TO MAKE UP THE ORIGINAL SATURATION     23DEC04.3226
> c   DEFICIT... OTHERWISE, ANY AVAILABLE LIQ OR ICE VAPORIZES AND APPROPRIATE     23DEC04.3227
> c   ADJUSTMENTS TO PARCEL TEMP; VAPOR, LIQUID, AND ICE MIXING RATIOS ARE MADE.   23DEC04.3228
> c                                                                                23DEC04.3229
> c...subsaturated values only occur in calculations involving various mixtures o  23DEC04.3230
> c...updraft and environmental air for estimation of entrainment and detrainment  23DEC04.3231
> c...For these purposes, assume that reasonable estimates can be given using      23DEC04.3232
> c...liquid water saturation calculations only - i.e., ignore the effect of the   23DEC04.3233
> c...ice phase in this process only...will not affect conservative properties...  23DEC04.3234
> c                                                                                23DEC04.3235
>         IF(QTOT.GE.DQ)THEN                                                       23DEC04.3236
>           qliq=qliq-dq*qliq/(qtot+1.e-10)                                        23DEC04.3237
>           qice=qice-dq*qice/(qtot+1.e-10)                                        23DEC04.3238
>           QU=QS                                                                  23DEC04.3239
>         ELSE                                                                     23DEC04.3240
>           RLL=XLV0-XLV1*TEMP                                                     23DEC04.3241
>           CPP=1004.*(1.+0.89*QU)                                                 23DEC04.3242
>           IF(QTOT.LT.1.E-10)THEN                                                 23DEC04.3243
> c                                                                                23DEC04.3244
> c...IF NO LIQUID WATER OR ICE IS AVAILABLE, TEMPERATURE IS GIVEN BY:             23DEC04.3245
>             TEMP=TEMP+RLL*(DQ/(1.+DQ))/CPP                                       23DEC04.3246
>           ELSE                                                                   23DEC04.3247
> c                                                                                23DEC04.3248
> c...IF SOME LIQ WATER/ICE IS AVAILABLE, BUT NOT ENOUGH TO ACHIEVE SATURATION,    23DEC04.3249
> c   THE TEMPERATURE IS GIVEN BY:                                                 23DEC04.3250
> c                                                                                23DEC04.3251
>             TEMP=TEMP+RLL*((DQ-QTOT)/(1+DQ-QTOT))/CPP                            23DEC04.3252
>             QU=QU+QTOT                                                           23DEC04.3253
>             QTOT=0.                                                              23DEC04.3254
>             QLIQ=0.                                                              23DEC04.3255
>             QICE=0.                                                              23DEC04.3256
>           ENDIF                                                                  23DEC04.3257
>         ENDIF                                                                    23DEC04.3258
>       ENDIF                                                                      23DEC04.3259
>       TU=TEMP                                                                    23DEC04.3260
>       qnewlq=qnew                                                                23DEC04.3261
>       qnewic=0.                                                                  23DEC04.3262
===================================================================
physics/explicit/Makefile
diff -r3.0 -r3.1
20c20,23
< 		else \
---
>                 fi; \
> 		if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) all); \
>                 fi; \
> 		if [ $(MPHYSTBL) = 1 ]; then \
31c34,37
< 		else \
---
> 		fi; \
> 		if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) all); \
> 		fi; \
> 		if [ $(MPHYSTBL) = 1 ]; then \
42c48,51
< 		else \
---
>                 fi;\
> 		if [ $(MPHYSTBL) = 2 ]; then (cd reisner1; $(MAKE) zex); \
>                 fi;\
> 		if [ $(MPHYSTBL) = 1 ]; then  \
45c54,55
< 		(cd shared; $(MAKE) table); fi; \
---
> 		(cd shared; $(MAKE) table); \
>                 fi; \
85c95,98
<                 else \
---
>                 fi;  \
>                 if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) code); \
>                 fi;  \
>                 if [ $(MPHYSTBL) = 1 ]; then  \
96c109,112
<                 else \
---
>                 fi;  \
>                 if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) code); \
>                 fi;  \
>                 if [ $(MPHYSTBL) = 1 ]; then  \
106,107c122,126
<                 if [ $(MPHYSTBL) = 0 ]; then (cd reisner1; $(MAKE) code); \
<                 else \
---
> 		if [ $(MPHYSTBL) = 0 ]; then (cd reisner1; $(MAKE) code); \
>                 fi;\
> 		if [ $(MPHYSTBL) = 2 ]; then (cd reisner1; $(MAKE) zex_code); \
>                 fi;\
> 		if [ $(MPHYSTBL) = 1 ]; then  \
145c164,167
< 		else \
---
> 		fi;  \
> 		if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) little_f); \
> 		fi;  \
> 		if [ $(MPHYSTBL) = 1 ]; then \
156c178,181
< 		else \
---
> 		fi;  \
> 		if [ $(MPHYSTBL) = 2 ]; then (cd simple; $(MAKE) little_f); \
> 		fi;  \
> 		if [ $(MPHYSTBL) = 1 ]; then \
166,167c191,195
< 		if [ $(MPHYSTBL) = 0 ]; then (cd reisner1; $(MAKE) little_f); \
< 		else \
---
> 		if [ $(MPHYSTBL) = 0 ]; then (cd reisner1; $(MAKE) littte_f); \
>                 fi;\
> 		if [ $(MPHYSTBL) = 2 ]; then (cd reisner1; $(MAKE) zex_littte_f); \
>                 fi;\
> 		if [ $(MPHYSTBL) = 1 ]; then  \
===================================================================
physics/explicit/gsfc/satice.F
diff -r3.3 -r3.4
47,52c47,52
< C	* OPTION OF SATURATION ADJUSTMENT SCHEMES                      *               SATICE.47
< C	* NEW FORMULATION OF PSFI                                      *               SATICE.48
< C	* REDUCED COLLECTION EFFICIENCIES (EGS) FOR COLLECTION OF SNOW *               SATICE.49
< C	  BY GRAUPEL                                                   *               SATICE.50
< C	* MODIFICATIONS TO PIDEP, PINT INCLUDING NEW COEFFICIENTS FOR  *               SATICE.51
< C	  THE FLETCHER EQ., A LIMIT OF 1 CM**-3 FOR THE NUMBER         *               SATICE.52
---
> C       * OPTION OF SATURATION ADJUSTMENT SCHEMES                      *         SATICE.47
> C       * NEW FORMULATION OF PSFI                                      *         SATICE.48
> C       * REDUCED COLLECTION EFFICIENCIES (EGS) FOR COLLECTION OF SNOW *         SATICE.49
> C         BY GRAUPEL                                                   *         SATICE.50
> C       * MODIFICATIONS TO PIDEP, PINT INCLUDING NEW COEFFICIENTS FOR  *         SATICE.51
> C         THE FLETCHER EQ., A LIMIT OF 1 CM**-3 FOR THE NUMBER         *         SATICE.52
54c54
< C	* ELIMINATED THE PGAUT TERM                                    *               SATICE.54
---
> C       * ELIMINATED THE PGAUT TERM                                    *         SATICE.54
278c278
< 	  IF(QC(I)+QR(I).LT.1.e-4) THEN                                                 SATICE.278
---
>          IF(QC(I)+QR(I).LT.1.e-4) THEN                                           SATICE.278
280,282c280,282
< 	  ELSE                                                                          SATICE.280
< 	     EE1=1.                                                                     SATICE.281
< 	  ENDIF                                                                         SATICE.282
---
>           ELSE                                                                   SATICE.280
>              EE1=1.                                                              SATICE.281
>           ENDIF                                                                  SATICE.282
675c675
< 	  IF (TAIR(I) .GE. 253.16) THEN                                                 SATICE.675
---
>           IF (TAIR(I) .GE. 253.16) THEN                                          SATICE.675
687,688c687,688
< 	  ENDIF                                                                         SATICE.687
< 	  IF (TAIR(I) .LE. 258.16) THEN                                                 SATICE.688
---
>           ENDIF                                                                  SATICE.687
>           IF (TAIR(I) .LE. 258.16) THEN                                          SATICE.688
700,702c700,702
< 	  ENDIF                                                                         SATICE.700
< 	 ENDDO                                                                          SATICE.701
< 	ENDIF                                                                           SATICE.702
---
>           ENDIF                                                                  SATICE.700
>          ENDDO                                                                   SATICE.701
>         ENDIF                                                                    SATICE.702
===================================================================
physics/explicit/reisner1/Makefile
diff -r3.2 -r3.3
13a14,16
> OBJS_ZEX =\
> 	zexmoisr.o
> 
19a23,25
> SRC_ZEX =\
> 	zexmoisr.i
> 
25a32,34
> SRCF_ZEX =\
> 	zexmoisr.f
> 
36a46,48
> zex:: zexmoisr.o
> 	$(AR) $(TARGETDIR)lib$(LIBTARGET).a $(OBJS_ZEX)
> 
40a53,54
> zex_code:: $(SRC_ZEX)
> 
46a61,63
> zex_little_f:: $(SRCF_ZEX) $(OBJS_ZEX)
> 	$(AR) $(TARGETDIR)lib$(LIBTARGET).a $(ONJS_ZEX)
> 
69a87,91
> zexmoisr.o: ../../../include/parame.incl ../../../include/varia.incl
> zexmoisr.o: ../../../include/param3.incl ../../../include/param2.incl
> zexmoisr.o: ../../../include/pmoist.incl ../../../include/nhcnst.incl
> zexmoisr.o: ../../../include/various.incl
> zexmoisr.o: ../../../include/defines.incl ../../../include/jrg.incl
===================================================================
physics/explicit/reisner1/exmoisr.F
diff -r3.18 -r3.21
543c543
< 	  r2 = r1 * psb(i,j)                                                            19DEC02.1401
---
>           r2 = r1 * psb(i,j)                                                     23DEC04.3263
===================================================================
physics/explicit/reisner1/lexmoisr.F
diff -r3.8 -r3.11
89,90d88
< #     include <hdtabl.incl>                                                      LEXMOISR.85
< #     include <functb.incl>                                                      LEXMOISR.86
92a91,94
>                                                                                  23DEC04.3264
>       real r1, r2                                                                23DEC04.3265
> #     include <hdtabl.incl>                                                      23DEC04.3266
> #     include <functb.incl>                                                      23DEC04.3267
96a99
>       r1 = 1.e-25                                                                23DEC04.3268
124,127c127,130
<           CLOUD(I,K)=AMAX1(1.E-25,QC3D(I,J,K))                                   LEXMOISR.114
<           ICE(I,K)=AMAX1(1.E-25,QI3D(I,J,K))                                     LEXMOISR.115
<           RAIN(I,K)=AMAX1(1.E-25,QR3D(I,J,K))                                    LEXMOISR.116
<           SNOW(I,K)=AMAX1(1.E-25,QNI3D(I,J,K))                                   LEXMOISR.117
---
>           CLOUD(I,K)=AMAX1(r1,QC3D(I,J,K))                                       23DEC04.3269
>           ICE(I,K)=AMAX1(r1,QI3D(I,J,K))                                         23DEC04.3270
>           RAIN(I,K)=AMAX1(r1,QR3D(I,J,K))                                        23DEC04.3271
>           SNOW(I,K)=AMAX1(r1,QNI3D(I,J,K))                                       23DEC04.3272
213c216
<           IF(CLOUD(I,K).GT.0.)THEN                                               LEXMOISR.197
---
>           IF(CLOUD(I,K).GT.r1)THEN                                               23DEC04.3273
268c271
<           IF((SNOW(I,K).GT.0.).AND.(ISAT.EQ.1))THEN                              LEXMOISR.252
---
>           IF((SNOW(I,K).GT.r1).AND.(ISAT.EQ.1))THEN                              23DEC04.3274
327c330
<           IF((SNOW(I,K).GT.0.).AND.(QAOUT(I,K)-QVS(I,K).GE.0.))THEN              LEXMOISR.311
---
>           IF((SNOW(I,K).GT.r1).AND.(QAOUT(I,K)-QVS(I,K).GE.0.))THEN              23DEC04.3275
444a448
>           r2 = r1 * psb(i,j)                                                     23DEC04.3276
461c465
<           SCR4R(I,K)=AMAX1(1.E-23,QR3D(I,J,K)*PSB(I,J)+                          LEXMOISR.445
---
>           SCR4R(I,K)=AMAX1(r2,QR3D(I,J,K)*PSB(I,J)+                              23DEC04.3277
463c467
<           SCR4S(I,K)=AMAX1(1.E-23,QNI3D(I,J,K)*PSB(I,J)+                         LEXMOISR.447
---
>           SCR4S(I,K)=AMAX1(r2,QNI3D(I,J,K)*PSB(I,J)+                             23DEC04.3278
465c469
<           SCR4I(I,K)=AMAX1(1.E-25,QI3D(I,J,K)*PSB(I,J)+                          LEXMOISR.449
---
>           SCR4I(I,K)=AMAX1(r2,QI3D(I,J,K)*PSB(I,J)+                              23DEC04.3279
499c503
<           IF(ICE(I,K).GT.1.E-25)THEN                                             LEXMOISR.483
---
>           IF(ICE(I,K).GT.r1)THEN                                                 23DEC04.3280
===================================================================
physics/explicit/reisner2/exmoisg.F
diff -r3.11 -r3.15
2c2
< #undef CALL_EVERY_OTHER_TSTEP                                                    19DEC02.1425
---
> #undef CALL_EVERY_OTHER_TSTEP 
9c9
< #if defined (CALL_EVERY_OTHER_TSTEP) 
---
> #if defined (CALL_EVERY_OTHER_TSTEP)
12c12
< #endif                                                                           19DEC02.1431
---
> #endif                                                                           23DEC04.3283
75a76,101
> C    15 MAY 2003                                                      C          23DEC04.3284
> C       PSACW MUST BE 5.0 TIMES GREATER THAN PREI BEFORE CREATING     C          23DEC04.3285
> C       GRAUPEL.  MAJOR BUG FIX TO BERRY/REINHARDT AUTOCONV AFTER     C          23DEC04.3286
> C       DISCOVERING MISTAKES IN JOURNAL PAPERS.  REQUIRE MIN DIAMETER C          23DEC04.3287
> C       OF ICE GREATER THAN 100 MICRONS BEFORE RIMING ICE BASED ON    C          23DEC04.3288
> C       PRUPPACHER AND KLETT, 1997 (PAGE 600).  ICE MULTIPLICATION    C          23DEC04.3289
> C       SECTION: CHANGED PSACW TO PGACW PER DISC WITH I. GERESDI.     C          23DEC04.3290
> C    01 SEP 2003                                                      C          23DEC04.3291
> C       PSACW MUST BE 3.0 TIMES GREATER THAN PREI FOR GRAUPEL INIT.   C          23DEC04.3292
> C       CHANGED AFTER MORE TESTING AGAINST GERESDI BIN MODEL AND TO   C          23DEC04.3293
> C       MATCH THE THOMPSON, RASMUSSEN, MANNING MWR-PART 1 PAPER.      C          23DEC04.3294
> C    RELEASE 3.7:                                                     C          23DEC04.3295
> C    06 DEC 2004                                                      C          23DEC04.3296
> C       Mods to the rain y-intercept value, RONV, (parameters in      C          23DEC04.3297
> C       paramr.F) to eliminate "rain-gush" effect.                    C          23DEC04.3298
> C       Added parameter xnu calculated from CNP to make maritime CCN  C          23DEC04.3299
> C       use broad drop spectra but narrow the distrib (decrease       C          23DEC04.3300
> C       dispersion) as CNP increases to continental values.  Net      C          23DEC04.3301
> C       effect: increase autoconversion for maritime CNP values;      C          23DEC04.3302
> C       little change for continental.                                C          23DEC04.3303
> C       Graupel intercept parameter, GONV, was not correct for gamma  C          23DEC04.3304
> C       size distrib as described in MWR Part1.  Went back to old exp C          23DEC04.3305
> C       distrib and not allow GONV to exceed old M-P value of 4.E6.   C          23DEC04.3306
> C       Assigned min fallspeed of cloud ice to 0.3 m/s.               C          23DEC04.3307
> C       Changed aggregation of cloud ice according to new fallspeed.  C          23DEC04.3308
> C       A few other minor bug fixes.                                  C          23DEC04.3309
178a205
>       xnu = amax1(0.0, (CNP*1E-6 - 100.)/100.)                                   23DEC04.3311
181,186c208,213
<           IF(ABS(QI3DTEN(i,j,k)).lt.R1) QI3DTEN(i,j,k)=0.                        EXMOISG.155
<           IF(ABS(QC3DTEN(i,j,k)).lt.R1) QC3DTEN(i,j,k)=0.                        EXMOISG.156
<           IF(ABS(QNI3DTEN(i,j,k)).lt.R1) QNI3DTEN(i,j,k)=0.                      EXMOISG.157
<           IF(ABS(QR3DTEN(i,j,k)).lt.R1) QR3DTEN(i,j,k)=0.                        EXMOISG.158
<           IF(ABS(QG3DTEN(i,j,k)).lt.R1) QG3DTEN(i,j,k)=0.                        EXMOISG.159
<           IF(ABS(QNC3DTEN(i,j,k)).lt.R1) QNC3DTEN(i,j,k)=0.                      EXMOISG.160
---
> Cgt       IF(ABS(QI3DTEN(i,j,k)).lt.R1) QI3DTEN(i,j,k)=0.                        23DEC04.3312
> Cgt       IF(ABS(QC3DTEN(i,j,k)).lt.R1) QC3DTEN(i,j,k)=0.                        23DEC04.3313
> Cgt       IF(ABS(QNI3DTEN(i,j,k)).lt.R1) QNI3DTEN(i,j,k)=0.                      23DEC04.3314
> Cgt       IF(ABS(QR3DTEN(i,j,k)).lt.R1) QR3DTEN(i,j,k)=0.                        23DEC04.3315
> Cgt       IF(ABS(QG3DTEN(i,j,k)).lt.R1) QG3DTEN(i,j,k)=0.                        23DEC04.3316
> Cgt       IF(ABS(QNC3DTEN(i,j,k)).lt.R1) QNC3DTEN(i,j,k)=0.                      23DEC04.3317
323c350
< #if defined (CALL_EVERY_OTHER_TSTEP)   
---
> #if defined (CALL_EVERY_OTHER_TSTEP)
360a388
>             VT2R=AMIN1(VT2R, 9.0)                                                23DEC04.3319
361a390
>             VT2S=AMIN1(VT2S, 2.0)                                                23DEC04.3320
363,365c392,396
<             DIACE=AMAX1(DIACE_min, ((6.*RHOd(I,K)*ICE(I,K)                       EXMOISG.314
<      +              /(PI*DICE*NCON(I,K)))**0.3333) )                             EXMOISG.315
<             VT2I=700. * AMIN1(DIACE, 2.*XR0S) * RHO_FAC                          EXMOISG.316
---
>             VT2G=AMIN1(VT2G, 10.0)                                               23DEC04.3321
>             DIACE=(6.*RHOd(I,K)*ICE(I,K)/(PI*DICE*NCON(I,K)))**0.3333            23DEC04.3322
>             DIACE=AMAX1(AMIN1(1.99*XR0S, DIACE), DIACE_min)                      23DEC04.3323
>             VT2I=700. * DIACE * RHO_FAC                                          23DEC04.3324
>             VT2I=AMAX1(AMIN1(1.0, VT2I), 0.3)                                    23DEC04.3325
370a402
>             DCLO = AMAX1(1.e-6, DCLO)                                            23DEC04.3326
376,385c408,417
< C+---+-----------------------------------------------------------------+         19DEC02.1507
< CC      ! Berry and Reinhardt autoconversion used in RAMS from Walko             19DEC02.1508
< CC      ! et al. (1995) with exponential size distrib (nu=1) though              19DEC02.1509
< CC      ! DCLO (above) is computed using monodisperse distrib.                   19DEC02.1510
<             walko_zeta = 2.7E-2*cloud(i,k)*(6.25E18*DCLO**4*0.707 - 0.4)         19DEC02.1511
<             walko_tau  = 3.7/(rho(i,k)*cloud(i,k))                               19DEC02.1512
<      +                          / (0.5E6*DCLO*0.707 - 0.75)                      19DEC02.1513
<             DQr_Dt = drain/rho(i,k) * (walko_zeta/walko_tau)                     19DEC02.1514
<             PRC(I,K) = AMAX1(0.0, DQr_Dt)                                        19DEC02.1515
< C+---+-----------------------------------------------------------------+         19DEC02.1516
---
> C+---+-----------------------------------------------------------------+         23DEC04.3327
> CC      ! Berry and Reinhardt autoconversion (1974, Part II) as in               23DEC04.3328
> CC      ! Walko et al., (1995) but WITH TYPOS CORRECTED IN BOTH!!!               23DEC04.3329
>             BandR_L2 = 0.027*cloud(I,K)*(6.25E18*(DCLO**4)*(1.+xnu)              23DEC04.3330
>      +                 **(-0.5) - 0.4)                                           23DEC04.3331
>             BandR_T2  = 3.72/(rho(I,K)*cloud(I,K)) / (0.5E6*DCLO                 23DEC04.3332
>      +                       *(1.+xnu)**(-1./6.) - 7.5)                          23DEC04.3333
>             if (BandR_L2.gt.0.0 .and. BandR_T2.gt.0.0)                           23DEC04.3334
>      +      PRC(I,K) = BandR_L2/BandR_T2                                         23DEC04.3335
> C+---+-----------------------------------------------------------------+         23DEC04.3336
398c430
< C...EVAPORATION OF RAINWATER  (R-A.62) [No depositional growth of rain - 17Feb2  19DEC02.1529
---
> C...EVAPORATION OF RAINWATER  (R-A.62) [No depositional growth of rain - 17Feb2  23DEC04.3337
413c445
<                XNC=TNO*EXP(ATO*(TO-AMAX1(TAOUT(I,K),233.)))                      EXMOISG.330
---
>                XNC=TNO*EXP(ATO*(TO-AMAX1(TAOUT(I,K),240.)))                      23DEC04.3338
449,453c481,485
< CCCCC          IF(SNOW(I,K).GT.R1)THEN                                           19DEC02.1541
< CCCCC             PSACR(I,K)=(CSR*RONV(I,K)*SONV(I,K)/RHOd(I,K))*                19DEC02.1542
< CCCCC+                 SQRT((ALPHA1*VT2R-BETA1*VT2S)**2+GAMMA1*VT2R              19DEC02.1543
< CCCCC+                 *VT2S)*(5.*SLOR(I,K)**6*SLOS(I,K)+2.*SLOR(I,K)**5         19DEC02.1544
< CCCCC+                 *SLOS(I,K)**2+0.5*SLOR(I,K)**4*SLOS(I,K)**3)              19DEC02.1545
---
>                IF(SNOW(I,K).GT.R1)THEN                                           23DEC04.3339
>                   PSACR(I,K)=(CSR*RONV(I,K)*SONV(I,K)/RHOd(I,K))*                23DEC04.3340
>      +                 SQRT((ALPHA1*VT2R-BETA1*VT2S)**2+GAMMA1*VT2R              23DEC04.3341
>      +                 *VT2S)*(5.*SLOR(I,K)**6*SLOS(I,K)+2.*SLOR(I,K)**5         23DEC04.3342
>      +                 *SLOS(I,K)**2+0.5*SLOR(I,K)**4*SLOS(I,K)**3)              23DEC04.3343
455,459c487,491
< CCCCC             PRACS(I,K)=(CRS*RONV(I,K)*SONV(I,K)/RHOd(I,K))*                19DEC02.1546
< CCCCC+                 SQRT((ALPHA1*VT2R-BETA1*VT2S)**2+GAMMA1*VT2R              19DEC02.1547
< CCCCC+                 *VT2S)*(5.*SLOS(I,K)**6*SLOR(I,K)+2.*SLOS(I,K)**5         19DEC02.1548
< CCCCC+                 *SLOR(I,K)**2+0.5*SLOS(I,K)**4*SLOR(I,K)**3)              19DEC02.1549
< CCCCC          ENDIF                                                             19DEC02.1550
---
>                   PRACS(I,K)=(CRS*RONV(I,K)*SONV(I,K)/RHOd(I,K))*                23DEC04.3344
>      +                 SQRT((ALPHA1*VT2R-BETA1*VT2S)**2+GAMMA1*VT2R              23DEC04.3345
>      +                 *VT2S)*(5.*SLOS(I,K)**6*SLOR(I,K)+2.*SLOS(I,K)**5         23DEC04.3346
>      +                 *SLOR(I,K)**2+0.5*SLOS(I,K)**4*SLOR(I,K)**3)              23DEC04.3347
>                ENDIF                                                             23DEC04.3348
479c511
<                SLOGN = 0.75785828 * (SLOG(I,K)**0.8)                             EXMOISG.409
---
> C              SLOGN = 0.75785828 * (SLOG(I,K)**0.8)                             23DEC04.3349
481c513
<                   DGRO = 4.*SLOGN                                                EXMOISG.414
---
>                   DGRO = 4.*SLOG(I,K)                                            23DEC04.3350
485,486c517,518
<                   PGACW(I,K)=ACRCG*GONV(I,K)*EFF_CG/EFGC*SLOGN**BACRCG           EXMOISG.418
<      +                 *CLOUD(I,K)                                               EXMOISG.419
---
>                   PGACW(I,K)=ACRCG*GONV(I,K)*EFF_CG/EFGC*                        23DEC04.3351
>      +                 SLOG(I,K)**BACRCG*CLOUD(I,K)                              23DEC04.3352
505c537
<                NI_RS(I,K)=RHOd(I,K)*3.5E8*TF*PSACW(I,K)                          EXMOISG.446
---
>                NI_RS(I,K)=RHOd(I,K)*3.5E8*TF*PGACW(I,K)                          23DEC04.3353
527,531c559,563
< C+---+-----------------------------------------------------------------+         19DEC02.1552
< C  changed snow to graupel conversion to require riming growth exceed            19DEC02.1553
< C  depositional growth by factor 2.5 (Murakami required a 1.0 factor             19DEC02.1554
< C  while RH1984 required qc>0.5 and qs>0.1 - similar to 5.0 factor)              19DEC02.1555
<                if (psacw(i,k).gt.2.5*prei(i,k)) then                             19DEC02.1556
---
> C+---+-----------------------------------------------------------------+         23DEC04.3354
> C  changed snow to graupel conversion to require riming growth exceed            23DEC04.3355
> C  depositional growth by factor 3.0 (Murakami required a 1.0 factor             23DEC04.3356
> C  while RH1984 required qc>0.5 and qs>0.1 - similar to 5.0 factor)              23DEC04.3357
>                if (psacw(i,k).gt.3.0*prei(i,k)) then                             23DEC04.3358
546,547c578,579
<      +              *(0.78*SLOGN**3+((DEPG2*RHO(I,K)                             EXMOISG.496
<      +              /DUM21(I,K))**0.5)*.31*4.098*SLOGN**(DEPG4+1.))              EXMOISG.497
---
>      +              *(0.78*SLOG(I,K)*SLOG(I,K)+((DEPG2*RHO(I,K)                  23DEC04.3359
>      +              /DUM21(I,K))**0.5)*DEPG3*SLOG(I,K)**(DEPG4))                 23DEC04.3360
550c582
<             FUDGEF = 0.5                                                         19DEC02.1566
---
>             FUDGEF = 0.95                                                        23DEC04.3361
563c595
<      +           . ICE(I,K).GT.R1.AND.TAOUT(I,K).LT.TO)THEN                      EXMOISG.518
---
>      +           . DIACE.GT.100.E-6.AND.TAOUT(I,K).LT.TO)THEN                    23DEC04.3362
564a597
>                EIC1=AMIN1(EIC1,0.5)                                              23DEC04.3363
588c621
<      +                    *ICE(I,K)/DTSAVE                                       19DEC02.1567
---
>      +                    *ICE(I,K)/(2.*DTSAVE)                                  23DEC04.3364
599,600c632,635
<                C1_AG = C1*RHOd(I,K)*ICE(I,K)*RHO_FAC                             EXMOISG.554
<                NI_AG(I,K) = 0.5*C1_AG*NCON(I,K)                                  EXMOISG.555
---
> C              C1_AG = C1*RHOd(I,K)*ICE(I,K)*RHO_FAC                             23DEC04.3365
>                C1_AG = PI/6.*0.1*0.25*VT2I*DIACE*DIACE                           23DEC04.3366
> C              NI_AG(I,K) = 0.5*C1_AG*NCON(I,K)                                  23DEC04.3367
>                NI_AG(I,K) = 0.5*C1_AG*NCON(I,K)*NCON(I,K)                        23DEC04.3368
602c637,639
<                   DTAU=-2.0/C1_AG*ALOG10((DIACE/(2.*XR0S))**3)                   EXMOISG.557
---
> C                 DTAU=-2.0/C1_AG*ALOG10((DIACE/(2.*XR0S))**3)                   23DEC04.3369
>                   DTAU=-2.0/(C1_AG*NCON(I,K))                                    23DEC04.3370
>      +                           *ALOG10((DIACE/(2.*XR0S))**3)                   23DEC04.3371
662,665c699,702
< CCCCC       ALPSNOW=AMAX1(1.E-25,DSNOW**2*(4.*SLOS(I,K))**6)                     19DEC02.1574
< CCCCC       ALPRAIN=AMAX1(1.E-25,DRAIN**2*(4.*SLOR(I,K))**6)                     19DEC02.1575
< CCCCC       ALPHARS=ALPSNOW/(ALPSNOW+ALPRAIN)                                    19DEC02.1576
<             alphars = 0.0                                                        19DEC02.1577
---
>             ALPSNOW=AMAX1(1.E-25,DSNOW**2*(4.*SLOS(I,K))**6)                     23DEC04.3372
>             ALPRAIN=AMAX1(1.E-25,DRAIN**2*(4.*SLOR(I,K))**6)                     23DEC04.3373
>             ALPHARS=ALPSNOW/(ALPSNOW+ALPRAIN)                                    23DEC04.3374
> CCCCC       alphars = 0.0                                                        23DEC04.3375
908c945
< #if defined (CALL_EVERY_OTHER_TSTEP)  
---
> #if defined (CALL_EVERY_OTHER_TSTEP)
1047a1085
>             VT2R=AMIN1(VT2R, 9.0)                                                23DEC04.3377
1048a1087
>             VT2S=AMIN1(VT2S, 2.0)                                                23DEC04.3378
1050,1052c1089,1093
<             DIAMI=AMAX1(DIACE_min, (6.*RHO3*UPDT_I                               EXMOISG.994
<      +            /(PI*DICE*UPDT_N))**0.3333)                                    EXMOISG.995
<             VT2I=700. * AMIN1(DIAMI, 2.*XR0S) * RHO_FAC                          EXMOISG.996
---
>             VT2G=AMIN1(VT2G, 10.0)                                               23DEC04.3379
>             DIAMI=(6.*RHOd(I,K)*UPDT_I/(PI*DICE*UPDT_N))**0.3333                 23DEC04.3380
>             DIAMI=AMAX1(AMIN1(0.001, DIAMI), DIACE_min)                          23DEC04.3381
>             VT2I=700. * DIAMI * RHO_FAC                                          23DEC04.3382
>             VT2I=AMAX1(AMIN1(1.0,VT2I), 0.3)                                     23DEC04.3383
===================================================================
physics/explicit/schultz/schultz.F
diff -r3.0 -r3.2
71,214c71,238
< C     INTEGER TOTAL_TIME, IUNIT, NCALL                                           SCHULTZ.71
< C     DATA NCALL /0/                                                             SCHULTZ.72
< C     DATA TOTAL_TIME /0/                                                        SCHULTZ.73
< C     DATA IUNIT /76/                                                            SCHULTZ.74
< C     SAVE                                                                       SCHULTZ.75
< C                                                                                SCHULTZ.76
< C     NCALL = NCALL + 1                                                          SCHULTZ.77
< C     PRINT_FLAG = .FALSE.                                                       SCHULTZ.78
< C     TIME_FLAG = .FALSE.                                                        SCHULTZ.79
< C     IF (NCALL.GT.1) THEN                                                       SCHULTZ.80
< C        DTO2 = DT/2.                                                            SCHULTZ.81
< C     ELSE                                                                       SCHULTZ.82
< C        DTO2 = DT                                                               SCHULTZ.83
< C     ENDIF                                                                      SCHULTZ.84
< C     TOTAL_TIME = TOTAL_TIME + NINT(DTO2)                                       SCHULTZ.85
< C     IF (MOD(TOTAL_TIME,3600).EQ.0) TIME_FLAG = .TRUE.                          SCHULTZ.86
<                                                                                  SCHULTZ.87
<       DO K=1,KL                                                                  SCHULTZ.88
<         DO I=IST,IEN                                                             SCHULTZ.89
<           TAOUT(I,K)=T3D(I,J,K)                                                  SCHULTZ.90
<           QAOUT(I,K)=AMAX1(0.0,QV3D(I,J,K))                                      SCHULTZ.91
<           PRES(I,K)=(A(K)*PSB(I,J)+PTOP)*1.E3+PP3D(I,J,K)                        SCHULTZ.92
<           RHO(I,K)=PRES(I,K)/(R*TAOUT(I,K))                                      SCHULTZ.93
<           CLOUD(I,K)=AMAX1(0.0,QC3D(I,J,K))                                      SCHULTZ.94
<           ICE(I,K)=AMAX1(0.0,QI3D(I,J,K))                                        SCHULTZ.95
<           RAIN(I,K)=AMAX1(0.0,QR3D(I,J,K))                                       SCHULTZ.96
<           SNOW(I,K)=AMAX1(0.0,QNI3D(I,J,K))                                      SCHULTZ.97
<           GRAUPEL(I,K)=AMAX1(0.0,QG3D(I,J,K))                                    SCHULTZ.98
<           VT2R=0.0                                                               SCHULTZ.99
<           VT2I=0.0                                                               SCHULTZ.100
<           VT2S=0.0                                                               SCHULTZ.101
<           VT2G=0.0                                                               SCHULTZ.102
<           TAOUT1=TAOUT(I,K)                                                      SCHULTZ.103
<           TAOUT(I,K)=TAOUT(I,K)+T3DTEN(I,J,K)*RPSB(I,J)*DT                       SCHULTZ.104
<           QAOUT1=QAOUT(I,K)                                                      SCHULTZ.105
<           QAOUT(I,K)=QAOUT(I,K)+QV3DTEN(I,J,K)*RPSB(I,J)*DT                      SCHULTZ.106
<           CLOUD1=CLOUD(I,K)                                                      SCHULTZ.107
<           CLOUD(I,K)=CLOUD(I,K)+QC3DTEN(I,J,K)*RPSB(I,J)*DT                      SCHULTZ.108
<           ICE1=ICE(I,K)                                                          SCHULTZ.109
<           ICE(I,K)=ICE(I,K)+QI3DTEN(I,J,K)*RPSB(I,J)*DT                          SCHULTZ.110
<           RAIN1=RAIN(I,K)                                                        SCHULTZ.111
<           RAIN(I,K)=RAIN(I,K)+QR3DTEN(I,J,K)*RPSB(I,J)*DT                        SCHULTZ.112
<           SNOW1=SNOW(I,K)                                                        SCHULTZ.113
<           SNOW(I,K)=SNOW(I,K)+QNI3DTEN(I,J,K)*RPSB(I,J)*DT                       SCHULTZ.114
<           GRAUP1=GRAUPEL(I,K)                                                    SCHULTZ.115
<           GRAUPEL(I,K)=GRAUPEL(I,K)+QG3DTEN(I,J,K)*RPSB(I,J)*DT                  SCHULTZ.116
< CC            IF (I.EQ.INT(FLOAT(IEN)*45./100.).AND.TIME_FLAG)                   SCHULTZ.117
< CC     +           PRINT_FLAG = .TRUE.                                           SCHULTZ.118
<           CALL SCHULTZ_MIC(PRES(I,K),TAOUT(I,K),RHO(I,K),DT,QAOUT(I,K),          SCHULTZ.119
<      +         CLOUD(I,K),RAIN(I,K),ICE(I,K),SNOW(I,K),GRAUPEL(I,K),VT2R         SCHULTZ.120
<      +         ,VT2I,VT2S,VT2G,PRINT_FLAG)                                       SCHULTZ.121
<           SCR4R(I,K)=-VT2R                                                       SCHULTZ.122
<           SCR4S(I,K)=-VT2S                                                       SCHULTZ.123
<           SCR4G(I,K)=-VT2G                                                       SCHULTZ.124
<           SCR4I(I,K)=-VT2I                                                       SCHULTZ.125
< C           T3DTEN(I,J,K)  = T3DTEN(I,J,K)                                       SCHULTZ.126
< C    +                     + PSB(I,J)*(TAOUT(I,K)-TAOUT1)/DT                     SCHULTZ.127
< C           QV3DTEN(I,J,K) = QV3DTEN(I,J,K)                                      SCHULTZ.128
< C    +                     + PSB(I,J)*(QAOUT(I,K)-QAOUT1)/DT                     SCHULTZ.129
<           T3DTEN(I,J,K)=PSB(I,J)*(TAOUT(I,K)-TAOUT1)/DT                          SCHULTZ.130
<           QV3DTEN(I,J,K)=PSB(I,J)*(QAOUT(I,K)-QAOUT1)/DT                         SCHULTZ.131
<           QC3DTEN(I,J,K)=PSB(I,J)*(CLOUD(I,K)-CLOUD1)/DT                         SCHULTZ.132
<           QI3DTEN(I,J,K)=PSB(I,J)*(ICE(I,K)-ICE1)/DT                             SCHULTZ.133
<           QR3DTEN(I,J,K)=PSB(I,J)*(RAIN(I,K)-RAIN1)/DT                           SCHULTZ.134
<           QNI3DTEN(I,J,K)=PSB(I,J)*(SNOW(I,K)-SNOW1)/DT                          SCHULTZ.135
<           QG3DTEN(I,J,K)=PSB(I,J)*(GRAUPEL(I,K)-GRAUP1)/DT                       SCHULTZ.136
<           QNC3DTEN(I,J,K)=0.0                                                    SCHULTZ.137
< CC            PRINT_FLAG = .FALSE.                                               SCHULTZ.138
<         ENDDO                                                                    SCHULTZ.139
<       ENDDO                                                                      SCHULTZ.140
< C--COMPUTE THE FALLOUT TERMS:                                                    SCHULTZ.141
< C     COMPUTE FALL TERM WITH SHORTER TIME STEPS WHERE VFALL>DZ/DT                SCHULTZ.142
<       DO I=IST,IEN                                                               SCHULTZ.143
<         NSTEP=0                                                                  SCHULTZ.144
<         DO K=1,KL                                                                SCHULTZ.145
<           SCR7=T3D(I,J,K)*PSB(I,J)+DT*T3DTEN(I,J,K)                              SCHULTZ.146
<           RHO2=(PRES(I,K)*1.E-3)/(R*SCR7)                                        SCHULTZ.147
< C UNITS ARE G-M/S2, RHO2-S2/M2,VT2-M/S                                           SCHULTZ.148
<           FR(K)=G*RHO2*SCR4R(I,K)                                                SCHULTZ.149
<           FS(K)=G*RHO2*SCR4S(I,K)                                                SCHULTZ.150
<           FG(K)=G*RHO2*SCR4G(I,K)                                                SCHULTZ.151
<           FI(K)=G*RHO2*SCR4I(I,K)                                                SCHULTZ.152
<           RGVM=AMAX1(FR(K),FS(K),FG(K),FI(K))                                    SCHULTZ.153
< C 1 IS TO ROUND UP, REPRESENTS NUMBER OF STEPS                                   SCHULTZ.154
<           IF(RGVM.GT.0.0)NSTEP=MAX0(INT(RGVM*DT/DSIGMA(K)+1.),NSTEP)             SCHULTZ.155
< C--COMPUTE P*T AND P*QR (WITHOUT FALLOUT TERM) AT TAU+1:                         SCHULTZ.156
<           SCR4R(I,K)=AMAX1(0.0,QR3D(I,J,K)*PSB(I,J)+DT*QR3DTEN(I,J,K))           SCHULTZ.157
<           SCR4S(I,K)=AMAX1(0.0,QNI3D(I,J,K)*PSB(I,J)+DT*QNI3DTEN(I,J,K))         SCHULTZ.158
<           SCR4G(I,K)=AMAX1(0.0,QG3D(I,J,K)*PSB(I,J)+DT*QG3DTEN(I,J,K))           SCHULTZ.159
<           SCR4I(I,K)=AMAX1(0.0,QI3D(I,J,K)*PSB(I,J)+DT*QI3DTEN(I,J,K))           SCHULTZ.160
<         ENDDO                                                                    SCHULTZ.161
<         DO N=1,NSTEP                                                             SCHULTZ.162
<           DO K=1,KL                                                              SCHULTZ.163
<             FALOUTR(K)=FR(K)*SCR4R(I,K)                                          SCHULTZ.164
<             FALOUTS(K)=FS(K)*SCR4S(I,K)                                          SCHULTZ.165
<             FALOUTG(K)=FG(K)*SCR4G(I,K)                                          SCHULTZ.166
<             FALOUTI(K)=FI(K)*SCR4I(I,K)                                          SCHULTZ.167
<           ENDDO                                                                  SCHULTZ.168
< C FOR TOP OF MODEL                                                               SCHULTZ.169
<           K=1                                                                    SCHULTZ.170
<           FALTNDR=FALOUTR(K)/DSIGMA(K)                                           SCHULTZ.171
<           FALTNDS=FALOUTS(K)/DSIGMA(K)                                           SCHULTZ.172
<           FALTNDG=FALOUTG(K)/DSIGMA(K)                                           SCHULTZ.173
<           FALTNDI=FALOUTI(K)/DSIGMA(K)                                           SCHULTZ.174
<           QR3DTEN(I,J,K)=QR3DTEN(I,J,K)-FALTNDR/NSTEP                            SCHULTZ.175
<           QNI3DTEN(I,J,K)=QNI3DTEN(I,J,K)-FALTNDS/NSTEP                          SCHULTZ.176
<           QG3DTEN(I,J,K)=QG3DTEN(I,J,K)-FALTNDG/NSTEP                            SCHULTZ.177
<           QI3DTEN(I,J,K)=QI3DTEN(I,J,K)-FALTNDI/NSTEP                            SCHULTZ.178
<           SCR4R(I,K)=SCR4R(I,K)-FALTNDR*DT/NSTEP                                 SCHULTZ.179
<           SCR4S(I,K)=SCR4S(I,K)-FALTNDS*DT/NSTEP                                 SCHULTZ.180
<           SCR4G(I,K)=SCR4G(I,K)-FALTNDG*DT/NSTEP                                 SCHULTZ.181
<           SCR4I(I,K)=SCR4I(I,K)-FALTNDI*DT/NSTEP                                 SCHULTZ.182
<           DO K=2,KL                                                              SCHULTZ.183
<             FALTNDR=(FALOUTR(K)-FALOUTR(K-1))/DSIGMA(K)                          SCHULTZ.184
<             FALTNDS=(FALOUTS(K)-FALOUTS(K-1))/DSIGMA(K)                          SCHULTZ.185
<             FALTNDG=(FALOUTG(K)-FALOUTG(K-1))/DSIGMA(K)                          SCHULTZ.186
<             FALTNDI=(FALOUTI(K)-FALOUTI(K-1))/DSIGMA(K)                          SCHULTZ.187
<             QR3DTEN(I,J,K)=QR3DTEN(I,J,K)-FALTNDR/NSTEP                          SCHULTZ.188
<             QNI3DTEN(I,J,K)=QNI3DTEN(I,J,K)-FALTNDS/NSTEP                        SCHULTZ.189
<             QG3DTEN(I,J,K)=QG3DTEN(I,J,K)-FALTNDG/NSTEP                          SCHULTZ.190
<             QI3DTEN(I,J,K)=QI3DTEN(I,J,K)-FALTNDI/NSTEP                          SCHULTZ.191
<             SCR4R(I,K)=SCR4R(I,K)-FALTNDR*DT/NSTEP                               SCHULTZ.192
<             SCR4S(I,K)=SCR4S(I,K)-FALTNDS*DT/NSTEP                               SCHULTZ.193
<             SCR4G(I,K)=SCR4G(I,K)-FALTNDG*DT/NSTEP                               SCHULTZ.194
<             SCR4I(I,K)=SCR4I(I,K)-FALTNDI*DT/NSTEP                               SCHULTZ.195
<           ENDDO                                                                  SCHULTZ.196
< C     ACCUMULATED RAIN                                                           SCHULTZ.197
< C 6000 CONVERTS FROM SEC TO MIN AND FROM M TO CM                                 SCHULTZ.198
<           RAINNC(I,J)=RAINNC(I,J)+(FALOUTR(KL)+FALOUTS(KL)+FALOUTG(KL)+          SCHULTZ.199
<      +                FALOUTI(KL))*DTMIN*6000./G/NSTEP                           SCHULTZ.200
<         ENDDO                                                                    SCHULTZ.201
<       ENDDO                                                                      SCHULTZ.202
< C     IF (TIME_FLAG) THEN                                                        SCHULTZ.203
< C        PRINT*, ' OPENING PRECIP (SCHULTZ) FILE CALLED FORT.',IUNIT             SCHULTZ.204
< C        OPEN(UNIT=IUNIT, FORM='FORMATTED')                                      SCHULTZ.205
< C        DO I=IST,IEN                                                            SCHULTZ.206
< C           WRITE (IUNIT, '(F9.6)') RAINNC(I,2)                                  SCHULTZ.207
< C        ENDDO                                                                   SCHULTZ.208
< C        CLOSE(IUNIT)                                                            SCHULTZ.209
< C        IUNIT = IUNIT + 1                                                       SCHULTZ.210
< C     ENDIF                                                                      SCHULTZ.211
<       RETURN                                                                     SCHULTZ.212
<       END                                                                        SCHULTZ.213
<                                                                                  SCHULTZ.214
---
>                                                                                  SCHULTZ.71
>       real tbar, dtemp, deezee, lapse, dxkm                                      SCHULTZ.72
>                                                                                  SCHULTZ.73
>       dxkm = dx/1000.                                                            SCHULTZ.74
>                                                                                  SCHULTZ.75
> C     INTEGER TOTAL_TIME, IUNIT, NCALL                                           SCHULTZ.76
> C     DATA NCALL /0/                                                             SCHULTZ.77
> C     DATA TOTAL_TIME /0/                                                        SCHULTZ.78
> C     DATA IUNIT /76/                                                            SCHULTZ.79
> C     SAVE                                                                       SCHULTZ.80
> C                                                                                SCHULTZ.81
> C     NCALL = NCALL + 1                                                          SCHULTZ.82
> C     PRINT_FLAG = .FALSE.                                                       SCHULTZ.83
> C     TIME_FLAG = .FALSE.                                                        SCHULTZ.84
> C     IF (NCALL.GT.1) THEN                                                       SCHULTZ.85
> C        DTO2 = DT/2.                                                            SCHULTZ.86
> C     ELSE                                                                       SCHULTZ.87
> C        DTO2 = DT                                                               SCHULTZ.88
> C     ENDIF                                                                      SCHULTZ.89
> C     TOTAL_TIME = TOTAL_TIME + NINT(DTO2)                                       SCHULTZ.90
> C     IF (MOD(TOTAL_TIME,3600).EQ.0) TIME_FLAG = .TRUE.                          SCHULTZ.91
>                                                                                  SCHULTZ.92
>       DO K=1,KL                                                                  SCHULTZ.93
>         DO I=IST,IEN                                                             SCHULTZ.94
>           TAOUT(I,K)=T3D(I,J,K)                                                  SCHULTZ.95
>           QAOUT(I,K)=AMAX1(0.0,QV3D(I,J,K))                                      SCHULTZ.96
>           PRES(I,K)=(A(K)*PSB(I,J)+PTOP)*1.E3+PP3D(I,J,K)                        SCHULTZ.97
>           RHO(I,K)=PRES(I,K)/(R*TAOUT(I,K))                                      SCHULTZ.98
>         ENDDO                                                                    SCHULTZ.99
>       ENDDO                                                                      SCHULTZ.100
>                                                                                  SCHULTZ.101
> C Calculation of lapse rate is done over the layer *below*                       SCHULTZ.102
> C the level.  The lapse rate is assumed isothermal from the                      SCHULTZ.103
> C dirt to the lowest level.                                                      SCHULTZ.104
>                                                                                  SCHULTZ.105
> C Probably should include moisture/virtual effects in lapse                      SCHULTZ.106
> C rate calculation.                                                              SCHULTZ.107
>                                                                                  SCHULTZ.108
>       DO K=1,KL                                                                  SCHULTZ.109
>         DO I=IST,IEN                                                             SCHULTZ.110
>           CLOUD(I,K)=AMAX1(0.0,QC3D(I,J,K))                                      SCHULTZ.111
>           ICE(I,K)=AMAX1(0.0,QI3D(I,J,K))                                        SCHULTZ.112
>           RAIN(I,K)=AMAX1(0.0,QR3D(I,J,K))                                       SCHULTZ.113
>           SNOW(I,K)=AMAX1(0.0,QNI3D(I,J,K))                                      SCHULTZ.114
>           GRAUPEL(I,K)=AMAX1(0.0,QG3D(I,J,K))                                    SCHULTZ.115
>           VT2R=0.0                                                               SCHULTZ.116
>           VT2I=0.0                                                               SCHULTZ.117
>           VT2S=0.0                                                               SCHULTZ.118
>           VT2G=0.0                                                               SCHULTZ.119
>           if (k.lt.kl) then                                                      SCHULTZ.120
>             tbar = .5*(taout(i,k)+taout(i,k+1))                                  SCHULTZ.121
>             dtemp = (taout(i,k)-taout(i,k+1))                                    SCHULTZ.122
>             deezee = -ROVG*tbar*(alog(pres(i,k)/pres(i,k+1)))                    SCHULTZ.123
>             lapse = 1000.*dtemp/deezee                                           SCHULTZ.124
>           else                                                                   SCHULTZ.125
>             lapse = 0.                                                           SCHULTZ.126
>           end if                                                                 SCHULTZ.127
>           TAOUT1=TAOUT(I,K)                                                      SCHULTZ.128
>           TAOUT(I,K)=TAOUT(I,K)+T3DTEN(I,J,K)*RPSB(I,J)*DT                       SCHULTZ.129
>           QAOUT1=QAOUT(I,K)                                                      SCHULTZ.130
>           QAOUT(I,K)=QAOUT(I,K)+QV3DTEN(I,J,K)*RPSB(I,J)*DT                      SCHULTZ.131
>           CLOUD1=CLOUD(I,K)                                                      SCHULTZ.132
>           CLOUD(I,K)=CLOUD(I,K)+QC3DTEN(I,J,K)*RPSB(I,J)*DT                      SCHULTZ.133
>           ICE1=ICE(I,K)                                                          SCHULTZ.134
>           ICE(I,K)=ICE(I,K)+QI3DTEN(I,J,K)*RPSB(I,J)*DT                          SCHULTZ.135
>           RAIN1=RAIN(I,K)                                                        SCHULTZ.136
>           RAIN(I,K)=RAIN(I,K)+QR3DTEN(I,J,K)*RPSB(I,J)*DT                        SCHULTZ.137
>           SNOW1=SNOW(I,K)                                                        SCHULTZ.138
>           SNOW(I,K)=SNOW(I,K)+QNI3DTEN(I,J,K)*RPSB(I,J)*DT                       SCHULTZ.139
>           GRAUP1=GRAUPEL(I,K)                                                    SCHULTZ.140
>           GRAUPEL(I,K)=GRAUPEL(I,K)+QG3DTEN(I,J,K)*RPSB(I,J)*DT                  SCHULTZ.141
> CC            IF (I.EQ.INT(FLOAT(IEN)*45./100.).AND.TIME_FLAG)                   SCHULTZ.142
> CC     +           PRINT_FLAG = .TRUE.                                           SCHULTZ.143
>           CALL SCHULTZ_MIC(PRES(I,K),TAOUT(I,K),RHO(I,K),lapse,dxkm,DT,          SCHULTZ.144
>      +         QAOUT(I,K),CLOUD(I,K),RAIN(I,K),ICE(I,K),SNOW(I,K),               SCHULTZ.145
>      +         GRAUPEL(I,K),VT2R,VT2I,VT2S,VT2G,PRINT_FLAG)                      SCHULTZ.146
>           SCR4R(I,K)=-VT2R                                                       SCHULTZ.147
>           SCR4S(I,K)=-VT2S                                                       SCHULTZ.148
>           SCR4G(I,K)=-VT2G                                                       SCHULTZ.149
>           SCR4I(I,K)=-VT2I                                                       SCHULTZ.150
> C           T3DTEN(I,J,K)  = T3DTEN(I,J,K)                                       SCHULTZ.151
> C    +                     + PSB(I,J)*(TAOUT(I,K)-TAOUT1)/DT                     SCHULTZ.152
> C           QV3DTEN(I,J,K) = QV3DTEN(I,J,K)                                      SCHULTZ.153
> C    +                     + PSB(I,J)*(QAOUT(I,K)-QAOUT1)/DT                     SCHULTZ.154
>           T3DTEN(I,J,K)=PSB(I,J)*(TAOUT(I,K)-TAOUT1)/DT                          SCHULTZ.155
>           QV3DTEN(I,J,K)=PSB(I,J)*(QAOUT(I,K)-QAOUT1)/DT                         SCHULTZ.156
>           QC3DTEN(I,J,K)=PSB(I,J)*(CLOUD(I,K)-CLOUD1)/DT                         SCHULTZ.157
>           QI3DTEN(I,J,K)=PSB(I,J)*(ICE(I,K)-ICE1)/DT                             SCHULTZ.158
>           QR3DTEN(I,J,K)=PSB(I,J)*(RAIN(I,K)-RAIN1)/DT                           SCHULTZ.159
>           QNI3DTEN(I,J,K)=PSB(I,J)*(SNOW(I,K)-SNOW1)/DT                          SCHULTZ.160
>           QG3DTEN(I,J,K)=PSB(I,J)*(GRAUPEL(I,K)-GRAUP1)/DT                       SCHULTZ.161
>           QNC3DTEN(I,J,K)=0.0                                                    SCHULTZ.162
> CC            PRINT_FLAG = .FALSE.                                               SCHULTZ.163
>         ENDDO                                                                    SCHULTZ.164
>       ENDDO                                                                      SCHULTZ.165
> C--COMPUTE THE FALLOUT TERMS:                                                    SCHULTZ.166
> C     COMPUTE FALL TERM WITH SHORTER TIME STEPS WHERE VFALL>DZ/DT                SCHULTZ.167
>       DO I=IST,IEN                                                               SCHULTZ.168
>         NSTEP=0                                                                  SCHULTZ.169
>         DO K=1,KL                                                                SCHULTZ.170
>           SCR7=T3D(I,J,K)*PSB(I,J)+DT*T3DTEN(I,J,K)                              SCHULTZ.171
>           RHO2=(PRES(I,K)*1.E-3)/(R*SCR7)                                        SCHULTZ.172
> C UNITS ARE G-M/S2, RHO2-S2/M2,VT2-M/S                                           SCHULTZ.173
>           FR(K)=G*RHO2*SCR4R(I,K)                                                SCHULTZ.174
>           FS(K)=G*RHO2*SCR4S(I,K)                                                SCHULTZ.175
>           FG(K)=G*RHO2*SCR4G(I,K)                                                SCHULTZ.176
>           FI(K)=G*RHO2*SCR4I(I,K)                                                SCHULTZ.177
>           RGVM=AMAX1(FR(K),FS(K),FG(K),FI(K))                                    SCHULTZ.178
> C 1 IS TO ROUND UP, REPRESENTS NUMBER OF STEPS                                   SCHULTZ.179
>           IF(RGVM.GT.0.0)NSTEP=MAX0(INT(RGVM*DT/DSIGMA(K)+1.),NSTEP)             SCHULTZ.180
> C--COMPUTE P*T AND P*QR (WITHOUT FALLOUT TERM) AT TAU+1:                         SCHULTZ.181
>           SCR4R(I,K)=AMAX1(0.0,QR3D(I,J,K)*PSB(I,J)+DT*QR3DTEN(I,J,K))           SCHULTZ.182
>           SCR4S(I,K)=AMAX1(0.0,QNI3D(I,J,K)*PSB(I,J)+DT*QNI3DTEN(I,J,K))         SCHULTZ.183
>           SCR4G(I,K)=AMAX1(0.0,QG3D(I,J,K)*PSB(I,J)+DT*QG3DTEN(I,J,K))           SCHULTZ.184
>           SCR4I(I,K)=AMAX1(0.0,QI3D(I,J,K)*PSB(I,J)+DT*QI3DTEN(I,J,K))           SCHULTZ.185
>         ENDDO                                                                    SCHULTZ.186
>         DO N=1,NSTEP                                                             SCHULTZ.187
>           DO K=1,KL                                                              SCHULTZ.188
>             FALOUTR(K)=FR(K)*SCR4R(I,K)                                          SCHULTZ.189
>             FALOUTS(K)=FS(K)*SCR4S(I,K)                                          SCHULTZ.190
>             FALOUTG(K)=FG(K)*SCR4G(I,K)                                          SCHULTZ.191
>             FALOUTI(K)=FI(K)*SCR4I(I,K)                                          SCHULTZ.192
>           ENDDO                                                                  SCHULTZ.193
> C FOR TOP OF MODEL                                                               SCHULTZ.194
>           K=1                                                                    SCHULTZ.195
>           FALTNDR=FALOUTR(K)/DSIGMA(K)                                           SCHULTZ.196
>           FALTNDS=FALOUTS(K)/DSIGMA(K)                                           SCHULTZ.197
>           FALTNDG=FALOUTG(K)/DSIGMA(K)                                           SCHULTZ.198
>           FALTNDI=FALOUTI(K)/DSIGMA(K)                                           SCHULTZ.199
>           QR3DTEN(I,J,K)=QR3DTEN(I,J,K)-FALTNDR/NSTEP                            SCHULTZ.200
>           QNI3DTEN(I,J,K)=QNI3DTEN(I,J,K)-FALTNDS/NSTEP                          SCHULTZ.201
>           QG3DTEN(I,J,K)=QG3DTEN(I,J,K)-FALTNDG/NSTEP                            SCHULTZ.202
>           QI3DTEN(I,J,K)=QI3DTEN(I,J,K)-FALTNDI/NSTEP                            SCHULTZ.203
>           SCR4R(I,K)=SCR4R(I,K)-FALTNDR*DT/NSTEP                                 SCHULTZ.204
>           SCR4S(I,K)=SCR4S(I,K)-FALTNDS*DT/NSTEP                                 SCHULTZ.205
>           SCR4G(I,K)=SCR4G(I,K)-FALTNDG*DT/NSTEP                                 SCHULTZ.206
>           SCR4I(I,K)=SCR4I(I,K)-FALTNDI*DT/NSTEP                                 SCHULTZ.207
>           DO K=2,KL                                                              SCHULTZ.208
>             FALTNDR=(FALOUTR(K)-FALOUTR(K-1))/DSIGMA(K)                          SCHULTZ.209
>             FALTNDS=(FALOUTS(K)-FALOUTS(K-1))/DSIGMA(K)                          SCHULTZ.210
>             FALTNDG=(FALOUTG(K)-FALOUTG(K-1))/DSIGMA(K)                          SCHULTZ.211
>             FALTNDI=(FALOUTI(K)-FALOUTI(K-1))/DSIGMA(K)                          SCHULTZ.212
>             QR3DTEN(I,J,K)=QR3DTEN(I,J,K)-FALTNDR/NSTEP                          SCHULTZ.213
>             QNI3DTEN(I,J,K)=QNI3DTEN(I,J,K)-FALTNDS/NSTEP                        SCHULTZ.214
>             QG3DTEN(I,J,K)=QG3DTEN(I,J,K)-FALTNDG/NSTEP                          SCHULTZ.215
>             QI3DTEN(I,J,K)=QI3DTEN(I,J,K)-FALTNDI/NSTEP                          SCHULTZ.216
>             SCR4R(I,K)=SCR4R(I,K)-FALTNDR*DT/NSTEP                               SCHULTZ.217
>             SCR4S(I,K)=SCR4S(I,K)-FALTNDS*DT/NSTEP                               SCHULTZ.218
>             SCR4G(I,K)=SCR4G(I,K)-FALTNDG*DT/NSTEP                               SCHULTZ.219
>             SCR4I(I,K)=SCR4I(I,K)-FALTNDI*DT/NSTEP                               SCHULTZ.220
>           ENDDO                                                                  SCHULTZ.221
> C     ACCUMULATED RAIN                                                           SCHULTZ.222
> C 6000 CONVERTS FROM SEC TO MIN AND FROM M TO CM                                 SCHULTZ.223
>           RAINNC(I,J)=RAINNC(I,J)+(FALOUTR(KL)+FALOUTS(KL)+FALOUTG(KL)+          SCHULTZ.224
>      +                FALOUTI(KL))*DTMIN*6000./G/NSTEP                           SCHULTZ.225
>         ENDDO                                                                    SCHULTZ.226
>       ENDDO                                                                      SCHULTZ.227
> C     IF (TIME_FLAG) THEN                                                        SCHULTZ.228
> C        PRINT*, ' OPENING PRECIP (SCHULTZ) FILE CALLED FORT.',IUNIT             SCHULTZ.229
> C        OPEN(UNIT=IUNIT, FORM='FORMATTED')                                      SCHULTZ.230
> C        DO I=IST,IEN                                                            SCHULTZ.231
> C           WRITE (IUNIT, '(F9.6)') RAINNC(I,2)                                  SCHULTZ.232
> C        ENDDO                                                                   SCHULTZ.233
> C        CLOSE(IUNIT)                                                            SCHULTZ.234
> C        IUNIT = IUNIT + 1                                                       SCHULTZ.235
> C     ENDIF                                                                      SCHULTZ.236
>       RETURN                                                                     SCHULTZ.237
>       END                                                                        SCHULTZ.238
===================================================================
physics/explicit/schultz/schultz_mic.F
diff -r3.0 -r3.2
1,2c1,2
<       SUBROUTINE SCHULTZ_MIC (P, T, RHO, DT, RV, RC, RR, RP, RS, RI,             SCHULTZ_MIC.1
<      +     TVR, TVP, TVS, TVI, PFLAG)                                            SCHULTZ_MIC.2
---
>       SUBROUTINE SCHULTZ_MIC (P, T, RHO, lapse, dx, DT, RV, RC,                  SCHULTZ_MIC.1
>      +      RR, RP, RS, RI, TVR, TVP, TVS, TVI, PFLAG)                           SCHULTZ_MIC.2
4,24c4,24
< C P ------ PRESSURE                 PA                                           SCHULTZ_MIC.4
< C T ------ TEMP                     K                                            SCHULTZ_MIC.5
< C RHO ---- DENSITY                  KG/M**3                                      SCHULTZ_MIC.6
< C DT ----- TIME STEP                SEC                                          SCHULTZ_MIC.7
< C MIXING RATIOS (KGX/KG) ARE GENERALLY USED BY DYNAMIC MODELS BECAUSE TH         SCHULTZ_MIC.8
< C CONSERVE, BUT SOME OF THE CONVERSION PROCESSES AREN'T INFLUENCED BY TH         SCHULTZ_MIC.9
< C PRESENCE OF OTHER GASES, SO SPECIFIC CONTENTS (KGX/M**3) ARE USED.             SCHULTZ_MIC.10
< C THE DIFFERENCE IS SCALING BY AIR DENSITY, RHO (KG/M**3).                       SCHULTZ_MIC.11
< C RV, QV ----- WATER VAPOR                                                       SCHULTZ_MIC.12
< C RC, QC ----- CLOUD WATER                                                       SCHULTZ_MIC.13
< C RR, QR ----- RAIN WATER                                                        SCHULTZ_MIC.14
< C RP, QP ----- PRISTINE CRYSTALS                                                 SCHULTZ_MIC.15
< C RS, QS ----- SNOW                                                              SCHULTZ_MIC.16
< C RI, QI ----- GRAUPEL/HAIL/SLEET                                                SCHULTZ_MIC.17
< C                                                                                SCHULTZ_MIC.18
< C TVP, TVR, TVS, TVI -- TERMINAL VELOCITIES (M/S)                                SCHULTZ_MIC.19
< C                                                                                SCHULTZ_MIC.20
< C TUNING KNOBS:                                                                  SCHULTZ_MIC.21
< C QCMIN AND QPMIN ARE THE MINUMUM AMOUNTS OF CLOUD MATTER CONTENT BEFORE         SCHULTZ_MIC.22
< C CONVERSION TO RAIN AND SNOW BEGIN.                                             SCHULTZ_MIC.23
< C V2P, C2P, ETC. ADJUST THE CONVERSION RATES.                                    SCHULTZ_MIC.24
---
> C p ------ pressure                 Pa                                           SCHULTZ_MIC.4
> C t ------ temp                     K                                            SCHULTZ_MIC.5
> C rho ---- density                  kg/m**3                                      SCHULTZ_MIC.6
> C lapse -- lapse rate               K/km                                         SCHULTZ_MIC.7
> C dx ----- grid increment           m?  km?                                      SCHULTZ_MIC.8
> C dt ----- time step                sec                                          SCHULTZ_MIC.9
>                                                                                  SCHULTZ_MIC.10
> C Mixing ratios (kgx/kg) are generally used by dynamic models                    SCHULTZ_MIC.11
> C because they conserve, but some of the conversion processes                    SCHULTZ_MIC.12
> C aren't influenced by the presence of other gases, so specific                  SCHULTZ_MIC.13
> C contents (kgx/m**3) are used.  The difference is scaling by                    SCHULTZ_MIC.14
> C air density, rho (kg/m**3).                                                    SCHULTZ_MIC.15
>                                                                                  SCHULTZ_MIC.16
> C rv, qv ----- water vapor                                                       SCHULTZ_MIC.17
> C rc, qc ----- cloud water                                                       SCHULTZ_MIC.18
> C rr, qr ----- rain water                                                        SCHULTZ_MIC.19
> C rp, qp ----- pristine crystals                                                 SCHULTZ_MIC.20
> C rs, qs ----- snow                                                              SCHULTZ_MIC.21
> C ri, qi ----- graupel/hail/sleet                                                SCHULTZ_MIC.22
>                                                                                  SCHULTZ_MIC.23
> C tvp, tvr, tvs, tvi -- terminal velocities (m/s)                                SCHULTZ_MIC.24
26,86c26,86
<       LOGICAL PFLAG                                                              SCHULTZ_MIC.26
<       REAL P, T, RHO, DT, QCMIN, QPMIN                                           SCHULTZ_MIC.27
<       REAL V2P, C2P, C2R, C2S, C2I, P2S                                          SCHULTZ_MIC.28
<       REAL R2I, I2R, S2R, R2V, P2V, S2V, I2V                                     SCHULTZ_MIC.29
<       REAL RV,  RC,  RR,  RP,  RS,  RI                                           SCHULTZ_MIC.30
<       REAL QV,  QC,  QR,  QP,  QS,  QI                                           SCHULTZ_MIC.31
<       REAL          TVR, TVP, TVS, TVI                                           SCHULTZ_MIC.32
<                                                                                  SCHULTZ_MIC.33
<       REAL RVSATL, RVSATI, RSAT                                                  SCHULTZ_MIC.34
<       REAL RLIQ, RICE, RTOT0, RTOT1, TIL0, TIL1, T1, X                           SCHULTZ_MIC.35
<       REAL RP_NUC, CHANGE, MAXMELT, EFF, RATE                                    SCHULTZ_MIC.36
<       REAL NEED, NEEDR, NEEDS, NEEDI, RATIO                                      SCHULTZ_MIC.37
<       REAL LVL, LVI, LLI                                                         SCHULTZ_MIC.38
<       REAL CP, CPINV, AKLV, AKIV                                                 SCHULTZ_MIC.39
<       INTEGER I                                                                  SCHULTZ_MIC.40
<                                                                                  SCHULTZ_MIC.41
<       PARAMETER(LLI   = 0.334E6)                                                 SCHULTZ_MIC.42
<       PARAMETER(QCMIN = .0005)  ! THRESHOLD FOR RAIN AUTOCON (KG/M**3)           SCHULTZ_MIC.43
<       PARAMETER(QPMIN = .0001)  ! THRESHOLD FOR SNOW AUTOCON (KG/M**3)           SCHULTZ_MIC.44
<       PARAMETER(V2P   = 25.0)   ! DIFFUSIONAL CRYSTAL GROWTH (*RP*RHO MU         SCHULTZ_MIC.45
<       PARAMETER(C2P   = 16.7E-6)! CLOUD LIQUID FREEZING AT T<253                 SCHULTZ_MIC.46
<       PARAMETER(C2R   = 33.0)   ! WARM RAINMAKING                                SCHULTZ_MIC.47
<       PARAMETER(C2S   = 33.3)   ! RIMING OF SNOW                                 SCHULTZ_MIC.48
<       PARAMETER(C2I   = 16.7)   ! RIMING OF ICE                                  SCHULTZ_MIC.49
<       PARAMETER(P2S   = 5.0)    ! AGGREGATION                                    SCHULTZ_MIC.50
<       PARAMETER(R2I   = 8.33E-6)! FREEZING RAIN                                  SCHULTZ_MIC.51
<       PARAMETER(S2R   = 8.33E-6)! MELTING SNOW                                   SCHULTZ_MIC.52
<       PARAMETER(I2R   = 1.67E-6)! MELTING ICE                                    SCHULTZ_MIC.53
<       PARAMETER(R2V   = .001)   ! RAIN EVAPORATION (MUST BE <= 1/DT)             SCHULTZ_MIC.54
<       PARAMETER(P2V   = .004)   ! CLOUD ICE EVAPORATION (MUST BE <= 1/DT         SCHULTZ_MIC.55
<       PARAMETER(S2V   = .002)   ! SNOW EVAPORATION (MUST BE <= 1/DT)             SCHULTZ_MIC.56
<       PARAMETER(I2V   = .001)   ! GRAUPEL EVAPORATION (MUST BE <= 1/DT)          SCHULTZ_MIC.57
<       PARAMETER(CP=1004., CPINV=1.0/CP, AKLV=2.5E6/CP, AKIV=2.834E6/CP)          SCHULTZ_MIC.58
<                                                                                  SCHULTZ_MIC.59
< C INITIALIZE THE TERMINAL VELOCITIES.                                            SCHULTZ_MIC.60
<       TVP = 0.                                                                   SCHULTZ_MIC.61
<       TVR = 0.                                                                   SCHULTZ_MIC.62
<       TVS = 0.                                                                   SCHULTZ_MIC.63
<       TVI = 0.                                                                   SCHULTZ_MIC.64
<                                                                                  SCHULTZ_MIC.65
< C NOTHING IN THIS ROUTINE CAN CHANGE THE QUANTITIES TIL, WHICH IS THE            SCHULTZ_MIC.66
< C TEMPERATURE WITH CORRECTIONS FOR LATENT HEATING BY ICE AND LIQUID,             SCHULTZ_MIC.67
< C AND RTOT.  TIL IS SIMILAR TO THETA-IL OF TRIPOLI AND COTTON (1981 MWR)         SCHULTZ_MIC.68
< C THESE ARE CHECKED AT THE END.                                                  SCHULTZ_MIC.69
< C ***SHOULD COMPARE TO RTP0 COMING FROM DYNAMIC MODEL!                           SCHULTZ_MIC.70
<       RLIQ = RC + RR                                                             SCHULTZ_MIC.71
<       RICE = RP + RS + RI                                                        SCHULTZ_MIC.72
<       RTOT0 = RV + RLIQ + RICE                                                   SCHULTZ_MIC.73
<       TIL0 = T  - (AKLV*RLIQ+AKIV*RICE)                                          SCHULTZ_MIC.74
<                                                                                  SCHULTZ_MIC.75
< C CONDENSATION AND EVAPORATION OF LIQUID.  CLOUD LIQUID IS ASSUMED TO OC         SCHULTZ_MIC.76
< C INSTANTANEOUSLY.  EVAPORATION OF RAIN IS AS IN DUDHIA AND MONCRIEFF            SCHULTZ_MIC.77
< C (JAS 89).  NO CONDENSATIONAL GROWTH OF RAIN.                                   SCHULTZ_MIC.78
<                                                                                  SCHULTZ_MIC.79
< C THE EVAPORATION PROCESS EATS UP LIQUID BEFORE ICE, AND SMALL PARTICLES         SCHULTZ_MIC.80
< C BEFORE LARGE, SO THE ORDER IS CLOUD LIQUID, RAIN, PRISTINE CRYSTALS, S         SCHULTZ_MIC.81
< C AND FINALLY ICE.                                                               SCHULTZ_MIC.82
<                                                                                  SCHULTZ_MIC.83
<       RSAT = RVSATL(P,T)                                                         SCHULTZ_MIC.84
<                                                                                  SCHULTZ_MIC.85
<       IF (RLIQ.EQ.0. .AND. RV.LT.RSAT) GO TO 10                                  SCHULTZ_MIC.86
---
> C Tuning knobs:                                                                  SCHULTZ_MIC.26
> C qcmin and qpmin are the minumum amounts of cloud matter                        SCHULTZ_MIC.27
> C content before conversion to rain and snow begin.                              SCHULTZ_MIC.28
> C v2p, c2p, etc. adjust the conversion rates.                                    SCHULTZ_MIC.29
>                                                                                  SCHULTZ_MIC.30
>       LOGICAL PFLAG                                                              SCHULTZ_MIC.31
>       REAL P, T, RHO, lapse, dx, DT, QCMIN, QPMIN                                SCHULTZ_MIC.32
>       REAL V2P, C2P, C2R, C2S, C2I, P2S                                          SCHULTZ_MIC.33
>       REAL R2I, I2R, S2R, R2V, P2V, S2V, I2V                                     SCHULTZ_MIC.34
>       REAL RV,  RC,  RR,  RP,  RS,  RI                                           SCHULTZ_MIC.35
>       REAL QV,  QC,  QR,  QP,  QS,  QI                                           SCHULTZ_MIC.36
>       REAL          TVR, TVP, TVS, TVI                                           SCHULTZ_MIC.37
>                                                                                  SCHULTZ_MIC.38
>       REAL RVSATL, RVSATI, RSAT                                                  SCHULTZ_MIC.39
>       REAL RLIQ, RICE, RTOT0, RTOT1, TIL0, TIL1, T1, X                           SCHULTZ_MIC.40
>       REAL RP_NUC, CHANGE, MAXMELT, EFF, RATE                                    SCHULTZ_MIC.41
>       REAL NEED, NEEDR, NEEDS, NEEDI, RATIO                                      SCHULTZ_MIC.42
>       REAL LVL, LVI, LLI                                                         SCHULTZ_MIC.43
>       REAL CP, CPINV, AKLV, AKIV                                                 SCHULTZ_MIC.44
>       Real rh, rvrc, prev, frac                                                  SCHULTZ_MIC.45
>       INTEGER I                                                                  SCHULTZ_MIC.46
>                                                                                  SCHULTZ_MIC.47
>       PARAMETER(QCMIN = .0005)  ! threshold for rain autocon (kg/m**3)           SCHULTZ_MIC.48
>       PARAMETER(QPMIN = .0001)  ! threshold for snow autocon (kg/m**3)           SCHULTZ_MIC.49
>       PARAMETER(V2P   = 25.0)   ! diffusional crystal growth                     SCHULTZ_MIC.50
>       PARAMETER(C2P   = 16.7E-6)! cloud liquid freezing at t<253                 SCHULTZ_MIC.51
>       PARAMETER(C2R   = 33.0)   ! warm rainmaking                                SCHULTZ_MIC.52
>       PARAMETER(C2S   = 33.3)   ! riming of snow                                 SCHULTZ_MIC.53
>       PARAMETER(C2I   = 16.7)   ! riming of ice                                  SCHULTZ_MIC.54
>       PARAMETER(P2S   = 5.0)    ! aggregation                                    SCHULTZ_MIC.55
>       PARAMETER(R2I   = 8.33E-6)! freezing rain                                  SCHULTZ_MIC.56
>       PARAMETER(S2R   = 8.33E-6)! melting snow                                   SCHULTZ_MIC.57
>       PARAMETER(I2R   = 1.67E-6)! melting ice                                    SCHULTZ_MIC.58
>       PARAMETER(R2V   = .001)   ! rain evaporation (must be <= 1/dt)             SCHULTZ_MIC.59
>       PARAMETER(P2V   = .004)   ! cloud ice evaporation (must be <= 1/dt)        SCHULTZ_MIC.60
>       PARAMETER(S2V   = .002)   ! snow evaporation (must be <= 1/dt)             SCHULTZ_MIC.61
>       PARAMETER(I2V   = .001)   ! graupel evaporation (must be <= 1/dt)          SCHULTZ_MIC.62
>                                                                                  SCHULTZ_MIC.63
>       PARAMETER(CP=1004., CPINV=1.0/CP, AKLV=2.5E6/CP, AKIV=2.834E6/CP)          SCHULTZ_MIC.64
>       PARAMETER(LLI=0.334E6)                                                     SCHULTZ_MIC.65
>                                                                                  SCHULTZ_MIC.66
> C Initialize the terminal velocities.                                            SCHULTZ_MIC.67
>       TVP = 0.                                                                   SCHULTZ_MIC.68
>       TVR = 0.                                                                   SCHULTZ_MIC.69
>       TVS = 0.                                                                   SCHULTZ_MIC.70
>       TVI = 0.                                                                   SCHULTZ_MIC.71
>                                                                                  SCHULTZ_MIC.72
> C Nothing in this routine can change the quantities "til", which                 SCHULTZ_MIC.73
> C is the temperature with corrections for latent heating by ice                  SCHULTZ_MIC.74
> C and liquid, and "rtot".  "til" is similar to theta-il of Tripoli               SCHULTZ_MIC.75
> C and Cotton (1981 MWR).  These are checked at the end.                          SCHULTZ_MIC.76
>                                                                                  SCHULTZ_MIC.77
>       RLIQ = RC + RR                                                             SCHULTZ_MIC.78
>       RICE = RP + RS + RI                                                        SCHULTZ_MIC.79
>       RTOT0 = RV + RLIQ + RICE                                                   SCHULTZ_MIC.80
>       TIL0 = T  - (AKLV*RLIQ+AKIV*RICE)                                          SCHULTZ_MIC.81
>                                                                                  SCHULTZ_MIC.82
> C The value "t1" returned from SatAdjL is the temperature of the                 SCHULTZ_MIC.83
> C updated parcel *if* all vapor over the rsat value condenses.                   SCHULTZ_MIC.84
> C The new diagnostic for cloud liquid allows for condensation                    SCHULTZ_MIC.85
> C to occur when rv < rsat, so "t1" is no longer used.                            SCHULTZ_MIC.86
88,140c88,140
<       CALL SATADJL (RV, P, T, RSAT, T1)                                          SCHULTZ_MIC.88
<       RC = RC + (RV-RSAT)                                                        SCHULTZ_MIC.89
<       IF (RC.GT.0.) THEN                                                         SCHULTZ_MIC.90
<          RV = RSAT                                                               SCHULTZ_MIC.91
<          T = T1                                                                  SCHULTZ_MIC.92
<       ELSE                      ! EVAPORATION OF CLOUD LIQUID, THEN RAIN         SCHULTZ_MIC.93
<          RV = RSAT + RC                                                          SCHULTZ_MIC.94
<          RC = 0.                                                                 SCHULTZ_MIC.95
<          IF (RR.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.96
<             RATE = R2V * (RSAT-RV)                                               SCHULTZ_MIC.97
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.98
< CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.99
<             IF (CHANGE.GT.RR) THEN                                               SCHULTZ_MIC.100
<                RV = RV + RR                                                      SCHULTZ_MIC.101
<                RR = 0.                                                           SCHULTZ_MIC.102
<             ELSE                                                                 SCHULTZ_MIC.103
<                RV = RV + CHANGE                                                  SCHULTZ_MIC.104
<                RR = RR - CHANGE                                                  SCHULTZ_MIC.105
<             ENDIF                                                                SCHULTZ_MIC.106
<          ENDIF                                                                   SCHULTZ_MIC.107
<          X = RR - RLIQ                                                           SCHULTZ_MIC.108
<          T = T + X*AKLV                                                          SCHULTZ_MIC.109
<       ENDIF                                                                      SCHULTZ_MIC.110
<                                                                                  SCHULTZ_MIC.111
<       RLIQ = RC + RR                                                             SCHULTZ_MIC.112
<  10   CONTINUE                                                                   SCHULTZ_MIC.113
<                                                                                  SCHULTZ_MIC.114
< C ICE GROWTH AND EVAPORATION.  ICE NUCLEATION IS MORE A FUNCTION OF              SCHULTZ_MIC.115
< C SUPERSATURATION THAN TEMPERATURE (THE SAME IS TRUE OF DIFFUSIONAL ICE          SCHULTZ_MIC.116
< C CRYSTAL GROWTH).  IN THE PRESENCE OF CLOUD WATER, ICE SUPERSATURATION          SCHULTZ_MIC.117
< C IS GREATEST AT -12C, AND ACTUALLY DECREASES AT VERY COLD TEMPERATURES.         SCHULTZ_MIC.118
<                                                                                  SCHULTZ_MIC.119
< C ICE NUCLEATION GENERATES ICE MASS MUCH SLOWER THAN DIFFUSIONAL GROWTH,         SCHULTZ_MIC.120
< C SO WE DON'T COMPUTE THAT FUNCTION IT IF THERE'S ANY CLOUD ICE PRESENT.         SCHULTZ_MIC.121
< C ALSO, NO NUCLEATION IN THE ABSENCE OF CLOUD WATER.                             SCHULTZ_MIC.122
<                                                                                  SCHULTZ_MIC.123
< C THE DIFFUSION FROM VAPOR TO PRISTINE CRYSTALS IS PROPORTIONAL TO THE           SCHULTZ_MIC.124
< C VAPOR EXCESS AND IS A FUNCTION OF THE CRYSTAL MASS ALREADY THERE.              SCHULTZ_MIC.125
< C IN THE PRESENCE OF CLOUD WATER, THE EXCESS IS .17 G/KG AT 1000 MB              SCHULTZ_MIC.126
< C AND .85 G/KG AT 200 MB.  THIS IS A SUPERSATURATION OF 12.4% AT -12 C,          SCHULTZ_MIC.127
< C THE TEMPERATURE AT WHICH THE DIFFERENCE IS GREATEST.                           SCHULTZ_MIC.128
<                                                                                  SCHULTZ_MIC.129
< C DIFFUSIONAL GROWTH OF SNOW IS NOT ALLOWED AT THIS TIME.  THE WATER             SCHULTZ_MIC.130
< C MASS WILL GET THERE ANYWAY VIA CRYSTAL GROWTH AND COLLECTION.                  SCHULTZ_MIC.131
<                                                                                  SCHULTZ_MIC.132
< C [IF THE VAPOR TRANSFER SHOULD BE INDEPENDENT OF PRESSURE, THE EQUATION         SCHULTZ_MIC.133
< C SHOULD BE RATE = V2P * (RHO*(RV-RSAT)) * (RHO*RP)]                             SCHULTZ_MIC.134
<                                                                                  SCHULTZ_MIC.135
<       RSAT = RVSATI(P,T)                                                         SCHULTZ_MIC.136
<       IF (RICE.EQ.0. .AND. RV.LT.RSAT) GO TO 20                                  SCHULTZ_MIC.137
<                                                                                  SCHULTZ_MIC.138
<       CALL SATADJI (RV, P, T, RSAT, T1)                                          SCHULTZ_MIC.139
<       IF (RV.GT.RSAT) THEN      ! ICE GROWTH                                     SCHULTZ_MIC.140
---
>       RSAT = RVSATL(P,T)                                                         SCHULTZ_MIC.88
>       CALL SATADJL (RV, P, T, RSAT, T1)                                          SCHULTZ_MIC.89
>                                                                                  SCHULTZ_MIC.90
> C We allow for cloud liquid to exist in subsaturated grid boxes;                 SCHULTZ_MIC.91
> C we no longer require the grid box to be saturated before cloud                 SCHULTZ_MIC.92
> C liquid begins to form.  The purpose is to include the effects                  SCHULTZ_MIC.93
> C of small, subgrid-scale cumuli in mixing, latent heating, and                  SCHULTZ_MIC.94
> C (perhaps eventually) shading.                                                  SCHULTZ_MIC.95
>                                                                                  SCHULTZ_MIC.96
> C Diagnose cloud liquid, and then compute temp change from rc                    SCHULTZ_MIC.97
> C change.  These changes are assumed instantaneous.  Note the                    SCHULTZ_MIC.98
> C slightly odd use of "rh":  it includes both vapor and cloud                    SCHULTZ_MIC.99
> C liquid.  The value "frac" coming back from Cu_fraction is the                  SCHULTZ_MIC.100
> C fraction of the grid box occupied by shallow cumuli.  It isn't                 SCHULTZ_MIC.101
> C used outside that subroutine, but it could be useful for                       SCHULTZ_MIC.102
> C radiative transfer.                                                            SCHULTZ_MIC.103
>                                                                                  SCHULTZ_MIC.104
>       rvrc = rv + rc                                                             SCHULTZ_MIC.105
>       rh = rvrc / rsat                                                           SCHULTZ_MIC.106
>       prev = rc                                                                  SCHULTZ_MIC.107
>       Call Cu_fraction (dx, lapse, rsat, rh, rc, frac)                           SCHULTZ_MIC.108
>       rv = rvrc - rc                                                             SCHULTZ_MIC.109
>       t = t + (rc-prev)*aklv                                                     SCHULTZ_MIC.110
>       rliq = rc + rr                                                             SCHULTZ_MIC.111
>                                                                                  SCHULTZ_MIC.112
> C The evaporation process eats up liquid before ice, and                         SCHULTZ_MIC.113
> C small particles before large, so the order is rain, pristine                   SCHULTZ_MIC.114
> C crystals, snow, and finally ice.   The new diagnostic for cloud                SCHULTZ_MIC.115
> C liquid allows for nonzero cloud liquid when the gridpoint is                   SCHULTZ_MIC.116
> C subsaturated, but it doesn't make sense to evaporate anything                  SCHULTZ_MIC.117
> C if there is cloud liquid present, so we deny evaporation of                    SCHULTZ_MIC.118
> C in that case.                                                                  SCHULTZ_MIC.119
>                                                                                  SCHULTZ_MIC.120
>       If (rc .gt. 0.) go to 10                                                   SCHULTZ_MIC.121
>                                                                                  SCHULTZ_MIC.122
> C Evaporation of rain as in Dudhia and Moncrieff (JAS 89).                       SCHULTZ_MIC.123
> C No condensational growth of rain.                                              SCHULTZ_MIC.124
>                                                                                  SCHULTZ_MIC.125
>       IF (RR.GT.0. .AND. RV.LT.RSAT) THEN                                        SCHULTZ_MIC.126
>          prev = rr                                                               SCHULTZ_MIC.127
>          RATE = R2V * (RSAT-RV)                                                  SCHULTZ_MIC.128
>          CHANGE = RATE * DT                                                      SCHULTZ_MIC.129
> CC         IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                             SCHULTZ_MIC.130
>          IF (CHANGE.GT.RR) THEN                                                  SCHULTZ_MIC.131
>             RV = RV + RR                                                         SCHULTZ_MIC.132
>             RR = 0.                                                              SCHULTZ_MIC.133
>          ELSE                                                                    SCHULTZ_MIC.134
>             RV = RV + CHANGE                                                     SCHULTZ_MIC.135
>             RR = RR - CHANGE                                                     SCHULTZ_MIC.136
>          ENDIF                                                                   SCHULTZ_MIC.137
>          t = t + (rr-prev)*aklv                                                  SCHULTZ_MIC.138
>          RLIQ = RC + RR                                                          SCHULTZ_MIC.139
>       ENDIF                                                                      SCHULTZ_MIC.140
142,157c142,157
<          IF (RC.GT.0. .AND. RP.LT.1E-6) THEN                                     SCHULTZ_MIC.142
<             CALL NUCLEATE_PRISTINE (RV, RSAT, T, RHO, RP_NUC)                    SCHULTZ_MIC.143
<             IF (RP_NUC.GT.RP) THEN                                               SCHULTZ_MIC.144
<                RV = RV + RP                                                      SCHULTZ_MIC.145
<                RP = RP_NUC                                                       SCHULTZ_MIC.146
<                RV = RV - RP_NUC                                                  SCHULTZ_MIC.147
<             ENDIF                                                                SCHULTZ_MIC.148
<          ENDIF                                                                   SCHULTZ_MIC.149
<                                                                                  SCHULTZ_MIC.150
<          IF (RP.GT.0. .AND. RV.GT.RSAT) THEN                                     SCHULTZ_MIC.151
<             RATE = V2P * (RV-RSAT) * RP*RHO                                      SCHULTZ_MIC.152
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.153
<               IF (CHANGE.GT.(RV-RSAT)) CHANGE=(RV-RSAT)                          SCHULTZ_MIC.154
<             RP = RP + CHANGE                                                     SCHULTZ_MIC.155
<             RV = RV - CHANGE                                                     SCHULTZ_MIC.156
<          ENDIF                                                                   SCHULTZ_MIC.157
---
> 10    Continue                                                                   SCHULTZ_MIC.142
>                                                                                  SCHULTZ_MIC.143
> C Ice growth and evaporation.  Ice nucleation is more a function of              SCHULTZ_MIC.144
> C supersaturation than temperature (the same is true of diffusional ice          SCHULTZ_MIC.145
> C crystal growth).  In the presence of cloud water, ice supersaturation          SCHULTZ_MIC.146
> C is greatest at -12C, and actually decreases at very cold temperatures.         SCHULTZ_MIC.147
>                                                                                  SCHULTZ_MIC.148
> C Ice nucleation generates ice mass much slower than diffusional growth,         SCHULTZ_MIC.149
> C so we don't compute that function it if there's any cloud ice present.         SCHULTZ_MIC.150
> C Also, no nucleation in the absence of cloud water.                             SCHULTZ_MIC.151
>                                                                                  SCHULTZ_MIC.152
> C The diffusion from vapor to pristine crystals is proportional to the           SCHULTZ_MIC.153
> C vapor excess and is a function of the crystal mass already there.              SCHULTZ_MIC.154
> C In the presence of cloud water, the excess is .17 g/kg at 1000 mb              SCHULTZ_MIC.155
> C and .85 g/kg at 200 mb.  This is a supersaturation of 12.4% at -12 C,          SCHULTZ_MIC.156
> C the temperature at which the difference is greatest.                           SCHULTZ_MIC.157
159,187c159,187
<       ELSE                      ! ICE EVAPORATION                                SCHULTZ_MIC.159
<                                                                                  SCHULTZ_MIC.160
< C PRISTINE CRYSTALS.  MIGHT MAKE THIS INSTANTANEOUS.                             SCHULTZ_MIC.161
<          IF (RP.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.162
<             RATE = P2V * (RSAT-RV)                                               SCHULTZ_MIC.163
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.164
< CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.165
<             IF (CHANGE.GT.RP) THEN                                               SCHULTZ_MIC.166
<                RV = RV + RP                                                      SCHULTZ_MIC.167
<                RP = 0.                                                           SCHULTZ_MIC.168
<             ELSE                                                                 SCHULTZ_MIC.169
<                RV = RV + CHANGE                                                  SCHULTZ_MIC.170
<                RP = RP - CHANGE                                                  SCHULTZ_MIC.171
<             ENDIF                                                                SCHULTZ_MIC.172
<          ENDIF                                                                   SCHULTZ_MIC.173
<                                                                                  SCHULTZ_MIC.174
< C THEN SNOW.                                                                     SCHULTZ_MIC.175
<          IF (RS.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.176
<             RATE = S2V * (RSAT-RV)                                               SCHULTZ_MIC.177
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.178
< CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.179
<             IF (CHANGE.GT.RS) THEN                                               SCHULTZ_MIC.180
<                RV = RV + RS                                                      SCHULTZ_MIC.181
<                RS = 0.                                                           SCHULTZ_MIC.182
<             ELSE                                                                 SCHULTZ_MIC.183
<                RV = RV + CHANGE                                                  SCHULTZ_MIC.184
<                RS = RS - CHANGE                                                  SCHULTZ_MIC.185
<             ENDIF                                                                SCHULTZ_MIC.186
<          ENDIF                                                                   SCHULTZ_MIC.187
---
> C Diffusional growth of snow is not allowed at this time.  The water             SCHULTZ_MIC.159
> C mass will get there anyway via crystal growth and collection.                  SCHULTZ_MIC.160
>                                                                                  SCHULTZ_MIC.161
>       RSAT = RVSATI(P,T)                                                         SCHULTZ_MIC.162
>       IF (RICE.EQ.0. .AND. RV.LT.RSAT) GO TO 20                                  SCHULTZ_MIC.163
>                                                                                  SCHULTZ_MIC.164
>       CALL SATADJI (RV, P, T, RSAT, T1)                                          SCHULTZ_MIC.165
>       IF (RV.GT.RSAT) THEN      ! ICE GROWTH                                     SCHULTZ_MIC.166
>                                                                                  SCHULTZ_MIC.167
>          IF (RC.GT.0. .AND. RP.LT.1E-6) THEN                                     SCHULTZ_MIC.168
>             CALL NUCLEATE_PRISTINE (RV, RSAT, T, RHO, RP_NUC)                    SCHULTZ_MIC.169
>             IF (RP_NUC.GT.RP) THEN                                               SCHULTZ_MIC.170
>                RV = RV + RP                                                      SCHULTZ_MIC.171
>                RP = RP_NUC                                                       SCHULTZ_MIC.172
>                RV = RV - RP_NUC                                                  SCHULTZ_MIC.173
>             ENDIF                                                                SCHULTZ_MIC.174
>          ENDIF                                                                   SCHULTZ_MIC.175
>                                                                                  SCHULTZ_MIC.176
>          IF (RP.GT.0. .AND. RV.GT.RSAT) THEN                                     SCHULTZ_MIC.177
>             RATE = V2P * (RV-RSAT) * RP*RHO                                      SCHULTZ_MIC.178
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.179
>               IF (CHANGE.GT.(RV-RSAT)) CHANGE=(RV-RSAT)                          SCHULTZ_MIC.180
>             RP = RP + CHANGE                                                     SCHULTZ_MIC.181
>             RV = RV - CHANGE                                                     SCHULTZ_MIC.182
>          ENDIF                                                                   SCHULTZ_MIC.183
>                                                                                  SCHULTZ_MIC.184
>       ELSE                      ! sublimation                                    SCHULTZ_MIC.185
>                                                                                  SCHULTZ_MIC.186
>          If (rc.gt.0) go to 20  ! see comment above                              SCHULTZ_MIC.187
189,233c189,233
< C AND FINALLY ICE.  IT MIGHT BE ARGUED THAT GRAUPEL AND HAIL CAN BE              SCHULTZ_MIC.189
< C WATER-COATED AND THUS EVAPORATE WRT LIQUID SATURATION (I.E., FASTER).          SCHULTZ_MIC.190
<          IF (RI.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.191
<             RATE = I2V * (RSAT-RV)                                               SCHULTZ_MIC.192
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.193
< CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.194
<             IF (CHANGE.GT.RI) THEN                                               SCHULTZ_MIC.195
<                RV = RV + RI                                                      SCHULTZ_MIC.196
<                RI = 0.                                                           SCHULTZ_MIC.197
<             ELSE                                                                 SCHULTZ_MIC.198
<                RV = RV + CHANGE                                                  SCHULTZ_MIC.199
<                RI = RI - CHANGE                                                  SCHULTZ_MIC.200
<             ENDIF                                                                SCHULTZ_MIC.201
<          ENDIF                                                                   SCHULTZ_MIC.202
<                                                                                  SCHULTZ_MIC.203
<       ENDIF                                                                      SCHULTZ_MIC.204
<                                                                                  SCHULTZ_MIC.205
<       X = (RP + RS + RI) - RICE                                                  SCHULTZ_MIC.206
<       T = T + X*AKIV                                                             SCHULTZ_MIC.207
<       RICE = RP + RS + RI                                                        SCHULTZ_MIC.208
<  20   CONTINUE                                                                   SCHULTZ_MIC.209
<                                                                                  SCHULTZ_MIC.210
< C MELTING AND FREEZING.                                                          SCHULTZ_MIC.211
< C MELTING FIRST.  CLOUD ICE MELTS IMMEDIATELY.                                   SCHULTZ_MIC.212
< C CLOUD ICE MELTS INTO CLOUD LIQUID.  SNOW MELTS INTO RAIN.  ICE ALSO ME         SCHULTZ_MIC.213
< C INTO RAIN, BUT NOT IMMEDIATELY.  IN ALL CASES, THE AMOUNT OF MELTING I         SCHULTZ_MIC.214
< C LIMITED TO THE AMOUNT IT TAKES TO COOL THE PARCEL TO THE FREEZING POIN         SCHULTZ_MIC.215
< C IT WORKS OUT TO ABOUT 3 G/KG PER CENTIGRADE DEGREE.  START BY CALCULAT         SCHULTZ_MIC.216
< C THE MAXIMUM AMOUNT OF MELTING POSSIBLE IN THIS TIME STEP.                      SCHULTZ_MIC.217
<                                                                                  SCHULTZ_MIC.218
<       IF (T.GT.273.1) THEN                                                       SCHULTZ_MIC.219
<                                                                                  SCHULTZ_MIC.220
<          MAXMELT = (T-273.1) * CP/LLI                                            SCHULTZ_MIC.221
<                                                                                  SCHULTZ_MIC.222
<          IF (RP.GT.0.) THEN                                                      SCHULTZ_MIC.223
<             IF (RP.GT.MAXMELT) THEN                                              SCHULTZ_MIC.224
<                RC = RC + MAXMELT                                                 SCHULTZ_MIC.225
<                RP = RP - MAXMELT                                                 SCHULTZ_MIC.226
<                GO TO 30                                                          SCHULTZ_MIC.227
<             ELSE                                                                 SCHULTZ_MIC.228
<                MAXMELT = MAXMELT - RP                                            SCHULTZ_MIC.229
<                RC = RC + RP                                                      SCHULTZ_MIC.230
<                RP = 0.                                                           SCHULTZ_MIC.231
<             ENDIF                                                                SCHULTZ_MIC.232
<          ENDIF                                                                   SCHULTZ_MIC.233
---
> C Pristine crystals.                                                             SCHULTZ_MIC.189
>          IF (RP.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.190
>             RATE = P2V * (RSAT-RV)                                               SCHULTZ_MIC.191
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.192
> CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.193
>             IF (CHANGE.GT.RP) THEN                                               SCHULTZ_MIC.194
>                RV = RV + RP                                                      SCHULTZ_MIC.195
>                RP = 0.                                                           SCHULTZ_MIC.196
>             ELSE                                                                 SCHULTZ_MIC.197
>                RV = RV + CHANGE                                                  SCHULTZ_MIC.198
>                RP = RP - CHANGE                                                  SCHULTZ_MIC.199
>             ENDIF                                                                SCHULTZ_MIC.200
>          ENDIF                                                                   SCHULTZ_MIC.201
>                                                                                  SCHULTZ_MIC.202
> C Then snow.                                                                     SCHULTZ_MIC.203
>          IF (RS.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.204
>             RATE = S2V * (RSAT-RV)                                               SCHULTZ_MIC.205
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.206
> CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.207
>             IF (CHANGE.GT.RS) THEN                                               SCHULTZ_MIC.208
>                RV = RV + RS                                                      SCHULTZ_MIC.209
>                RS = 0.                                                           SCHULTZ_MIC.210
>             ELSE                                                                 SCHULTZ_MIC.211
>                RV = RV + CHANGE                                                  SCHULTZ_MIC.212
>                RS = RS - CHANGE                                                  SCHULTZ_MIC.213
>             ENDIF                                                                SCHULTZ_MIC.214
>          ENDIF                                                                   SCHULTZ_MIC.215
>                                                                                  SCHULTZ_MIC.216
> C And finally ice.  It might be argued that graupel and hail can be              SCHULTZ_MIC.217
> C water-coated and thus evaporate wrt liquid saturation (i.e., faster).          SCHULTZ_MIC.218
>                                                                                  SCHULTZ_MIC.219
>          IF (RI.GT.0. .AND. RV.LT.RSAT) THEN                                     SCHULTZ_MIC.220
>             RATE = I2V * (RSAT-RV)                                               SCHULTZ_MIC.221
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.222
> CC            IF (CHANGE.GT.(RSAT-RV)) CHANGE=(RSAT-RV)                          SCHULTZ_MIC.223
>             IF (CHANGE.GT.RI) THEN                                               SCHULTZ_MIC.224
>                RV = RV + RI                                                      SCHULTZ_MIC.225
>                RI = 0.                                                           SCHULTZ_MIC.226
>             ELSE                                                                 SCHULTZ_MIC.227
>                RV = RV + CHANGE                                                  SCHULTZ_MIC.228
>                RI = RI - CHANGE                                                  SCHULTZ_MIC.229
>             ENDIF                                                                SCHULTZ_MIC.230
>          ENDIF                                                                   SCHULTZ_MIC.231
>                                                                                  SCHULTZ_MIC.232
>       ENDIF                                                                      SCHULTZ_MIC.233
235,263c235,263
<          IF (RS.GT.0.) THEN                                                      SCHULTZ_MIC.235
<             RATE = S2R * (T-273.1)                                               SCHULTZ_MIC.236
<             CHANGE = RATE*DT                                                     SCHULTZ_MIC.237
<             IF (CHANGE.GT.MAXMELT) CHANGE=MAXMELT                                SCHULTZ_MIC.238
<             IF (CHANGE.LT.RS) THEN                                               SCHULTZ_MIC.239
<                RR = RR + CHANGE                                                  SCHULTZ_MIC.240
<                RS = RS - CHANGE                                                  SCHULTZ_MIC.241
<                MAXMELT = MAXMELT - CHANGE                                        SCHULTZ_MIC.242
<             ELSE                                                                 SCHULTZ_MIC.243
<                RR = RR + RS                                                      SCHULTZ_MIC.244
<                MAXMELT = MAXMELT - RS                                            SCHULTZ_MIC.245
<                RS = 0.                                                           SCHULTZ_MIC.246
<             ENDIF                                                                SCHULTZ_MIC.247
<          ENDIF                                                                   SCHULTZ_MIC.248
<                                                                                  SCHULTZ_MIC.249
<          IF (RI.GT.0.) THEN                                                      SCHULTZ_MIC.250
<             RATE = I2R * (T-273.1)                                               SCHULTZ_MIC.251
<             CHANGE = RATE*DT                                                     SCHULTZ_MIC.252
<             IF (CHANGE.GT.MAXMELT) CHANGE=MAXMELT                                SCHULTZ_MIC.253
<             IF (CHANGE.LT.RI) THEN                                               SCHULTZ_MIC.254
<                RR = RR + CHANGE                                                  SCHULTZ_MIC.255
<                RI = RI - CHANGE                                                  SCHULTZ_MIC.256
<             ELSE                                                                 SCHULTZ_MIC.257
<                RR = RR + RI                                                      SCHULTZ_MIC.258
<                RI = 0.                                                           SCHULTZ_MIC.259
<             ENDIF                                                                SCHULTZ_MIC.260
<          ENDIF                                                                   SCHULTZ_MIC.261
<                                                                                  SCHULTZ_MIC.262
<  30      CONTINUE                                                                SCHULTZ_MIC.263
---
>       X = (RP + RS + RI) - RICE                                                  SCHULTZ_MIC.235
>       T = T + X*AKIV                                                             SCHULTZ_MIC.236
>       RICE = RP + RS + RI                                                        SCHULTZ_MIC.237
>                                                                                  SCHULTZ_MIC.238
> 20    CONTINUE                                                                   SCHULTZ_MIC.239
>                                                                                  SCHULTZ_MIC.240
> C Melting and freezing.                                                          SCHULTZ_MIC.241
> C Melting first.  Cloud ice melts immediately.  Cloud ice                        SCHULTZ_MIC.242
> C melts into cloud liquid.  Snow and ice melt into rain.                         SCHULTZ_MIC.243
> C The amount of melting is limited to the amount it takes                        SCHULTZ_MIC.244
> C to cool the parcel to the freezing point.  It works out                        SCHULTZ_MIC.245
> C to about 3 g/kg per centigrade degree.  Start by calculating                   SCHULTZ_MIC.246
> C the maximum amount of melting possible in this time step.                      SCHULTZ_MIC.247
>                                                                                  SCHULTZ_MIC.248
>       IF (T.GT.273.1) THEN                                                       SCHULTZ_MIC.249
>                                                                                  SCHULTZ_MIC.250
>          MAXMELT = (T-273.1) * CP/LLI                                            SCHULTZ_MIC.251
>                                                                                  SCHULTZ_MIC.252
>          IF (RP.GT.0.) THEN                                                      SCHULTZ_MIC.253
>             IF (RP.GT.MAXMELT) THEN                                              SCHULTZ_MIC.254
>                RC = RC + MAXMELT                                                 SCHULTZ_MIC.255
>                RP = RP - MAXMELT                                                 SCHULTZ_MIC.256
>                GO TO 30                                                          SCHULTZ_MIC.257
>             ELSE                                                                 SCHULTZ_MIC.258
>                MAXMELT = MAXMELT - RP                                            SCHULTZ_MIC.259
>                RC = RC + RP                                                      SCHULTZ_MIC.260
>                RP = 0.                                                           SCHULTZ_MIC.261
>             ENDIF                                                                SCHULTZ_MIC.262
>          ENDIF                                                                   SCHULTZ_MIC.263
265,340c265,340
< C NOW FREEZING.  FIRST THE CLOUD LIQUID, THEN THE RAIN.                          SCHULTZ_MIC.265
<       ELSE                                                                       SCHULTZ_MIC.266
<                                                                                  SCHULTZ_MIC.267
< C CLOUD WATER STAYS SUPERCOOLED WELL BELOW FREEZING, BUT HOW MUCH?  THIS         SCHULTZ_MIC.268
< C JUST FREEZING BECAUSE IT'S COLD.  THERE IS VERY LITTLE CLOUD WATER BEL         SCHULTZ_MIC.269
< C -25C, AND ALMOST NONE OBSERVED BELOW -40C.  RAMP PARABOLICALLY FROM            SCHULTZ_MIC.270
< C -20 TO -40.                                                                    SCHULTZ_MIC.271
<          IF (RC.GT.0. .AND. T.LT.253.) THEN                                      SCHULTZ_MIC.272
<             RATE = C2P * ((253.-T)/20.)**2                                       SCHULTZ_MIC.273
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.274
<             IF (CHANGE.GT.RC) THEN                                               SCHULTZ_MIC.275
<                RP = RP + RC                                                      SCHULTZ_MIC.276
<                RC = 0.                                                           SCHULTZ_MIC.277
<             ELSE                                                                 SCHULTZ_MIC.278
<                RP = RP + CHANGE                                                  SCHULTZ_MIC.279
<                RC = RC - CHANGE                                                  SCHULTZ_MIC.280
<             ENDIF                                                                SCHULTZ_MIC.281
<          ENDIF                                                                   SCHULTZ_MIC.282
<                                                                                  SCHULTZ_MIC.283
< C RAIN FREEZING INTO ICE; PARABOLIC FUNCTION SIMILAR TO C2P.  BASED LOOS         SCHULTZ_MIC.284
< C ON FIG.1 FROM COTTON (MWR 72B).                                                SCHULTZ_MIC.285
<          IF (RR.GT.0. .AND. T.LT.267.) THEN                                      SCHULTZ_MIC.286
<             RATE = R2I * ((267.-T)/14.)**2                                       SCHULTZ_MIC.287
<             CHANGE = RATE * DT                                                   SCHULTZ_MIC.288
<             IF (CHANGE.GT.RR) THEN                                               SCHULTZ_MIC.289
<                RI = RI + RR                                                      SCHULTZ_MIC.290
<                RR = 0.                                                           SCHULTZ_MIC.291
<             ELSE                                                                 SCHULTZ_MIC.292
<                RI = RI + CHANGE                                                  SCHULTZ_MIC.293
<                RR = RR - CHANGE                                                  SCHULTZ_MIC.294
<             ENDIF                                                                SCHULTZ_MIC.295
<          ENDIF                                                                   SCHULTZ_MIC.296
<                                                                                  SCHULTZ_MIC.297
<       ENDIF                                                                      SCHULTZ_MIC.298
<                                                                                  SCHULTZ_MIC.299
< C TEMPERATURE AFTER FREEZING OR MELTING.                                         SCHULTZ_MIC.300
<       X = (RC + RR) - RLIQ                                                       SCHULTZ_MIC.301
<       T = T - X*LLI*CPINV                                                        SCHULTZ_MIC.302
< C THIS SHOULD GIVE THE SAME ANSWER.                                              SCHULTZ_MIC.303
< C       X = (RP + RS + RI) - RICE                                                SCHULTZ_MIC.304
< C       T = T + X*LLI/CP                                                         SCHULTZ_MIC.305
<                                                                                  SCHULTZ_MIC.306
<       RLIQ = RC + RR                                                             SCHULTZ_MIC.307
<       RICE = RP + RS + RI                                                        SCHULTZ_MIC.308
<                                                                                  SCHULTZ_MIC.309
< C COLLECTION.  THESE PROCESSES ARE DETERMINED BY SPACING BETWEEN PARTICL         SCHULTZ_MIC.310
< C REGARDLESS OF HOW MUCH GAS IS ALSO IN THE VOLUME.  SO WE'LL FIRST CONV         SCHULTZ_MIC.311
< C TO SPECIFIC CONTENTS, AND THEN LATER BACK TO MIXING RATIOS.                    SCHULTZ_MIC.312
<       QC = RC * RHO                                                              SCHULTZ_MIC.313
<       QP = RP * RHO                                                              SCHULTZ_MIC.314
<       QR = RR * RHO                                                              SCHULTZ_MIC.315
<       QS = RS * RHO                                                              SCHULTZ_MIC.316
<       QI = RI * RHO                                                              SCHULTZ_MIC.317
<                                                                                  SCHULTZ_MIC.318
< C AUTOCONVERSION.  AS SOON AS YOU BUILD UP ENOUGH CLOUD MATTER, IT START         SCHULTZ_MIC.319
< C CONVERTING TO RAIN OR SNOW.  THIS "NUCLEATES" THE COLLECTION PROCESS,          SCHULTZ_MIC.320
< C WHICH IS NONLINEAR.  THE NUCLEATED AMOUNT DETERMINES HOW LONG BEFORE           SCHULTZ_MIC.321
< C RAPID COLLECTION OCCURS.  IF SOME PRECIPITATE IS ALREADY PRESENT, THE          SCHULTZ_MIC.322
< C AUTOCONV PROCEDURE JUST MAKES SURE THERE'S ENOUGH.                             SCHULTZ_MIC.323
<       IF (QC.GT.QCMIN) THEN                                                      SCHULTZ_MIC.324
<          CHANGE = QC - QCMIN                                                     SCHULTZ_MIC.325
<          IF (CHANGE.GT.QR) THEN                                                  SCHULTZ_MIC.326
<             CHANGE = CHANGE - QR                                                 SCHULTZ_MIC.327
<             QR = QR + CHANGE                                                     SCHULTZ_MIC.328
<             QC = QC - CHANGE                                                     SCHULTZ_MIC.329
<          ENDIF                                                                   SCHULTZ_MIC.330
<       ENDIF                                                                      SCHULTZ_MIC.331
<                                                                                  SCHULTZ_MIC.332
<       IF (QP.GT.QPMIN) THEN                                                      SCHULTZ_MIC.333
<          CHANGE = QP - QPMIN                                                     SCHULTZ_MIC.334
<          IF (CHANGE.GT.QS) THEN                                                  SCHULTZ_MIC.335
<             CHANGE = CHANGE - QS                                                 SCHULTZ_MIC.336
<             QS = QS + CHANGE                                                     SCHULTZ_MIC.337
<             QP = QP - CHANGE                                                     SCHULTZ_MIC.338
<          ENDIF                                                                   SCHULTZ_MIC.339
<       ENDIF                                                                      SCHULTZ_MIC.340
---
>          IF (RS.GT.0.) THEN                                                      SCHULTZ_MIC.265
>             RATE = S2R * (T-273.1)                                               SCHULTZ_MIC.266
>             CHANGE = RATE*DT                                                     SCHULTZ_MIC.267
>             IF (CHANGE.GT.MAXMELT) CHANGE=MAXMELT                                SCHULTZ_MIC.268
>             IF (CHANGE.LT.RS) THEN                                               SCHULTZ_MIC.269
>                RR = RR + CHANGE                                                  SCHULTZ_MIC.270
>                RS = RS - CHANGE                                                  SCHULTZ_MIC.271
>                MAXMELT = MAXMELT - CHANGE                                        SCHULTZ_MIC.272
>             ELSE                                                                 SCHULTZ_MIC.273
>                RR = RR + RS                                                      SCHULTZ_MIC.274
>                MAXMELT = MAXMELT - RS                                            SCHULTZ_MIC.275
>                RS = 0.                                                           SCHULTZ_MIC.276
>             ENDIF                                                                SCHULTZ_MIC.277
>          ENDIF                                                                   SCHULTZ_MIC.278
>                                                                                  SCHULTZ_MIC.279
>          IF (RI.GT.0.) THEN                                                      SCHULTZ_MIC.280
>             RATE = I2R * (T-273.1)                                               SCHULTZ_MIC.281
>             CHANGE = RATE*DT                                                     SCHULTZ_MIC.282
>             IF (CHANGE.GT.MAXMELT) CHANGE=MAXMELT                                SCHULTZ_MIC.283
>             IF (CHANGE.LT.RI) THEN                                               SCHULTZ_MIC.284
>                RR = RR + CHANGE                                                  SCHULTZ_MIC.285
>                RI = RI - CHANGE                                                  SCHULTZ_MIC.286
>             ELSE                                                                 SCHULTZ_MIC.287
>                RR = RR + RI                                                      SCHULTZ_MIC.288
>                RI = 0.                                                           SCHULTZ_MIC.289
>             ENDIF                                                                SCHULTZ_MIC.290
>          ENDIF                                                                   SCHULTZ_MIC.291
>                                                                                  SCHULTZ_MIC.292
>  30      CONTINUE                                                                SCHULTZ_MIC.293
>                                                                                  SCHULTZ_MIC.294
>       ELSE                                                                       SCHULTZ_MIC.295
>                                                                                  SCHULTZ_MIC.296
> C Now freezing.  First the cloud liquid, then the rain.                          SCHULTZ_MIC.297
> C Cloud water stays supercooled well below freezing, but how much?               SCHULTZ_MIC.298
> C This is just freezing because it's cold.  There is very little                 SCHULTZ_MIC.299
> C cloud water below -25C, and almost none observed below -40C.                   SCHULTZ_MIC.300
> C Ramp parabolically from -20 to -40.                                            SCHULTZ_MIC.301
>                                                                                  SCHULTZ_MIC.302
>          IF (RC.GT.0. .AND. T.LT.253.) THEN                                      SCHULTZ_MIC.303
>             RATE = C2P * ((253.-T)/20.)**2                                       SCHULTZ_MIC.304
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.305
>             IF (CHANGE.GT.RC) THEN                                               SCHULTZ_MIC.306
>                RP = RP + RC                                                      SCHULTZ_MIC.307
>                RC = 0.                                                           SCHULTZ_MIC.308
>             ELSE                                                                 SCHULTZ_MIC.309
>                RP = RP + CHANGE                                                  SCHULTZ_MIC.310
>                RC = RC - CHANGE                                                  SCHULTZ_MIC.311
>             ENDIF                                                                SCHULTZ_MIC.312
>          ENDIF                                                                   SCHULTZ_MIC.313
>                                                                                  SCHULTZ_MIC.314
> C Rain freezing into ice; parabolic function similar to c2p.                     SCHULTZ_MIC.315
> C Based loosely on Fig.1 from Cotton (MWR 72B).                                  SCHULTZ_MIC.316
>                                                                                  SCHULTZ_MIC.317
>          IF (RR.GT.0. .AND. T.LT.267.) THEN                                      SCHULTZ_MIC.318
>             RATE = R2I * ((267.-T)/14.)**2                                       SCHULTZ_MIC.319
>             CHANGE = RATE * DT                                                   SCHULTZ_MIC.320
>             IF (CHANGE.GT.RR) THEN                                               SCHULTZ_MIC.321
>                RI = RI + RR                                                      SCHULTZ_MIC.322
>                RR = 0.                                                           SCHULTZ_MIC.323
>             ELSE                                                                 SCHULTZ_MIC.324
>                RI = RI + CHANGE                                                  SCHULTZ_MIC.325
>                RR = RR - CHANGE                                                  SCHULTZ_MIC.326
>             ENDIF                                                                SCHULTZ_MIC.327
>          ENDIF                                                                   SCHULTZ_MIC.328
>                                                                                  SCHULTZ_MIC.329
>       ENDIF                                                                      SCHULTZ_MIC.330
>                                                                                  SCHULTZ_MIC.331
> C Temperature after freezing or melting.                                         SCHULTZ_MIC.332
>       X = (RC + RR) - RLIQ                                                       SCHULTZ_MIC.333
>       T = T - X*LLI*CPINV                                                        SCHULTZ_MIC.334
> C This should give the same answer.                                              SCHULTZ_MIC.335
> C     X = (RP + RS + RI) - RICE                                                  SCHULTZ_MIC.336
> C     T = T + X*LLI/CP                                                           SCHULTZ_MIC.337
>                                                                                  SCHULTZ_MIC.338
>       RLIQ = RC + RR                                                             SCHULTZ_MIC.339
>       RICE = RP + RS + RI                                                        SCHULTZ_MIC.340
342,396c342,396
< C THERE CAN BE A THREE-WAY COMPETITION FOR CLOUD WATER AMONG THE RAIN,           SCHULTZ_MIC.342
< C SNOW, AND ICE, SO WE DISTRIBUTE IT INTO THE THREE CATEGORIES.  THE             SCHULTZ_MIC.343
< C "NEED" VARIABLES ARE THE AMOUNT OF CLOUD WATER THAT PROCESS WOULD USE          SCHULTZ_MIC.344
< C UP IN A TIME STEP IF IT DIDN'T HAVE TO COMPETE.  THE COLLECTION FORMUL         SCHULTZ_MIC.345
< C FOR RAIN IS VERY NEARLY THE SAME AS SOONG AND OGURA (1973); THE OTHER          SCHULTZ_MIC.346
< C FUNCTIONS ARE BASED ON THAT.                                                   SCHULTZ_MIC.347
<       IF (QC.GT.0.) THEN                                                         SCHULTZ_MIC.348
<          RATE = C2R * QC * QR                                                    SCHULTZ_MIC.349
<          NEEDR = RATE*DT                                                         SCHULTZ_MIC.350
<          RATE = C2S * QC * QS                                                    SCHULTZ_MIC.351
<          NEEDS = RATE*DT                                                         SCHULTZ_MIC.352
<          RATE = C2I * QC * QI                                                    SCHULTZ_MIC.353
<          NEEDI = RATE*DT                                                         SCHULTZ_MIC.354
<          NEED = NEEDR + NEEDS + NEEDI                                            SCHULTZ_MIC.355
<          IF (NEED .GT. QC) THEN                                                  SCHULTZ_MIC.356
<             NEEDR = NEEDR * QC / NEED                                            SCHULTZ_MIC.357
<             NEEDS = NEEDS * QC / NEED                                            SCHULTZ_MIC.358
<             NEEDI = NEEDI * QC / NEED                                            SCHULTZ_MIC.359
<          ENDIF                                                                   SCHULTZ_MIC.360
<                                                                                  SCHULTZ_MIC.361
< C THE RIMING PROCESS NUCLEATES A LITTLE CLOUD ICE.  UNTIL A BETTER               SCHULTZ_MIC.362
< C NUMBER COMES ALONG WE'LL SAY 1% OF THE COLLECTED LIQUID, BOTH FOR              SCHULTZ_MIC.363
< C SNOW AND GRAUPEL.                                                              SCHULTZ_MIC.364
< C        QP = QP + .01*NEEDS                                                     SCHULTZ_MIC.365
< C        NEEDS = NEEDS - .01*NEEDS                                               SCHULTZ_MIC.366
< C        QP = QP + .01*NEEDI                                                     SCHULTZ_MIC.367
< C        NEEDI = NEEDI - .01*NEEDI                                               SCHULTZ_MIC.368
<                                                                                  SCHULTZ_MIC.369
< C FOR SIMPLICITY (I.E., UNTIL A BETTER WAY TO DO IT COMES ALONG), WE             SCHULTZ_MIC.370
< C ASSUME THAT THE RESULT OF SNOW RIMING IS TO CONVERT THE CLOUD WATER,           SCHULTZ_MIC.371
< C BUT NOT THE SNOW, TO THE GRAUPEL CATEGORY.                                     SCHULTZ_MIC.372
<          QR = QR + NEEDR                                                         SCHULTZ_MIC.373
<          QI = QI + NEEDI + NEEDS                                                 SCHULTZ_MIC.374
<          QC = QC - NEEDR - NEEDS - NEEDI                                         SCHULTZ_MIC.375
<                                                                                  SCHULTZ_MIC.376
<       ENDIF                                                                      SCHULTZ_MIC.377
<                                                                                  SCHULTZ_MIC.378
< C UNLIKE THE COLLECTION OF CLOUD WATER, WHICH CAN BE COMPLETE, WE DON'T          SCHULTZ_MIC.379
< C WANT TO ZERO OUT THE PRISTINE CRYSTALS.  FOR ONE THING, SOME ARE SO            SCHULTZ_MIC.380
< C TINY THEY WON'T GET COLLECTED, BUT ALSO, WE WANT TO BE ABLE TO PRODUCE         SCHULTZ_MIC.381
< C MORE CONDENSATE IF IT STILL SUPERSATURATED WRT ICE, WHICH WON'T HAPPEN         SCHULTZ_MIC.382
< C IF THERE'S ZERO CLOUD ICE.  WE'LL LEAVE BEHIND THE EQUIVALENT OF 100 P         SCHULTZ_MIC.383
< C LITER.  AT 1E-11 KG PER CRYSTAL AND 1000 LITERS PER M**3, THAT WOULD B         SCHULTZ_MIC.384
< C 1E-6 KG/M**3 (1 MG/M**3).  THE TEMPERATURE-DEPENDENT EFFICIENCY FOLLOW         SCHULTZ_MIC.385
< C LIN ET AL (JCAM 83).                                                           SCHULTZ_MIC.386
<       IF (QP.GT.0. .AND. QS.GT.0.) THEN                                          SCHULTZ_MIC.387
<          EFF = 1. - (273.1-T)/50.                                                SCHULTZ_MIC.388
<          RATE = P2S * EFF * QP * QS                                              SCHULTZ_MIC.389
<          CHANGE = RATE * DT                                                      SCHULTZ_MIC.390
<          IF (CHANGE.GT.QP) THEN                                                  SCHULTZ_MIC.391
<             QS = QS + QP - 1E-6                                                  SCHULTZ_MIC.392
<             QP = 1E-6                                                            SCHULTZ_MIC.393
<          ELSE                                                                    SCHULTZ_MIC.394
<             QS = QS + CHANGE                                                     SCHULTZ_MIC.395
<             QP = QP - CHANGE                                                     SCHULTZ_MIC.396
---
> C Collection.  These processes are determined by spacing between                 SCHULTZ_MIC.342
> C particles, regardless of how much gas is also in the volume.                   SCHULTZ_MIC.343
> C So we'll first convert mixing ratios to specific contents, and                 SCHULTZ_MIC.344
> C then later back to mixing ratios.                                              SCHULTZ_MIC.345
>                                                                                  SCHULTZ_MIC.346
>       QC = RC * RHO                                                              SCHULTZ_MIC.347
>       QP = RP * RHO                                                              SCHULTZ_MIC.348
>       QR = RR * RHO                                                              SCHULTZ_MIC.349
>       QS = RS * RHO                                                              SCHULTZ_MIC.350
>       QI = RI * RHO                                                              SCHULTZ_MIC.351
>                                                                                  SCHULTZ_MIC.352
> C Autoconversion.  As soon as you build up enough cloud matter,                  SCHULTZ_MIC.353
> C it starts converting to rain or snow.  This "nucleates" the                    SCHULTZ_MIC.354
> C collection process, which is nonlinear.  The nucleated amount                  SCHULTZ_MIC.355
> C determines how long before rapid collection occurs.  If some                   SCHULTZ_MIC.356
> C precipitate is already present, the autoconv procedure just                    SCHULTZ_MIC.357
> C makes sure there's enough.                                                     SCHULTZ_MIC.358
>                                                                                  SCHULTZ_MIC.359
>       IF (QC.GT.QCMIN) THEN                                                      SCHULTZ_MIC.360
>          CHANGE = QC - QCMIN                                                     SCHULTZ_MIC.361
>          IF (CHANGE.GT.QR) THEN                                                  SCHULTZ_MIC.362
>             CHANGE = CHANGE - QR                                                 SCHULTZ_MIC.363
>             QR = QR + CHANGE                                                     SCHULTZ_MIC.364
>             QC = QC - CHANGE                                                     SCHULTZ_MIC.365
>          ENDIF                                                                   SCHULTZ_MIC.366
>       ENDIF                                                                      SCHULTZ_MIC.367
>                                                                                  SCHULTZ_MIC.368
>       IF (QP.GT.QPMIN) THEN                                                      SCHULTZ_MIC.369
>          CHANGE = QP - QPMIN                                                     SCHULTZ_MIC.370
>          IF (CHANGE.GT.QS) THEN                                                  SCHULTZ_MIC.371
>             CHANGE = CHANGE - QS                                                 SCHULTZ_MIC.372
>             QS = QS + CHANGE                                                     SCHULTZ_MIC.373
>             QP = QP - CHANGE                                                     SCHULTZ_MIC.374
>          ENDIF                                                                   SCHULTZ_MIC.375
>       ENDIF                                                                      SCHULTZ_MIC.376
>                                                                                  SCHULTZ_MIC.377
> C There can be a three-way competition for cloud water among the                 SCHULTZ_MIC.378
> C rain, snow, and ice, so we distribute it among the three                       SCHULTZ_MIC.379
> C categories.  The "need" variables are the amount of cloud water                SCHULTZ_MIC.380
> C that species would in a time step if it didn't have to compete.                SCHULTZ_MIC.381
> C The collection formula for rain is very nearly the same as                     SCHULTZ_MIC.382
> C Soong and Ogura (1973); the other functions are based on that.                 SCHULTZ_MIC.383
>                                                                                  SCHULTZ_MIC.384
>       IF (QC.GT.0.) THEN                                                         SCHULTZ_MIC.385
>          RATE = C2R * QC * QR                                                    SCHULTZ_MIC.386
>          NEEDR = RATE*DT                                                         SCHULTZ_MIC.387
>          RATE = C2S * QC * QS                                                    SCHULTZ_MIC.388
>          NEEDS = RATE*DT                                                         SCHULTZ_MIC.389
>          RATE = C2I * QC * QI                                                    SCHULTZ_MIC.390
>          NEEDI = RATE*DT                                                         SCHULTZ_MIC.391
>          NEED = NEEDR + NEEDS + NEEDI                                            SCHULTZ_MIC.392
>          IF (NEED .GT. QC) THEN                                                  SCHULTZ_MIC.393
>             NEEDR = NEEDR * QC / NEED                                            SCHULTZ_MIC.394
>             NEEDS = NEEDS * QC / NEED                                            SCHULTZ_MIC.395
>             NEEDI = NEEDI * QC / NEED                                            SCHULTZ_MIC.396
398,405c398,405
<       ENDIF                                                                      SCHULTZ_MIC.398
<                                                                                  SCHULTZ_MIC.399
< C CONVERT BACK TO MIXING RATIOS.                                                 SCHULTZ_MIC.400
<       RC = QC / RHO                                                              SCHULTZ_MIC.401
<       RP = QP / RHO                                                              SCHULTZ_MIC.402
<       RR = QR / RHO                                                              SCHULTZ_MIC.403
<       RS = QS / RHO                                                              SCHULTZ_MIC.404
<       RI = QI / RHO                                                              SCHULTZ_MIC.405
---
>                                                                                  SCHULTZ_MIC.398
> C The riming process nucleates a little cloud ice.  Until a better               SCHULTZ_MIC.399
> C number comes along we'll say 1% of the collected liquid, both for              SCHULTZ_MIC.400
> C snow and graupel.                                                              SCHULTZ_MIC.401
> C        QP = QP + .01*NEEDS                                                     SCHULTZ_MIC.402
> C        NEEDS = NEEDS - .01*NEEDS                                               SCHULTZ_MIC.403
> C        QP = QP + .01*NEEDI                                                     SCHULTZ_MIC.404
> C        NEEDI = NEEDI - .01*NEEDI                                               SCHULTZ_MIC.405
407,443c407,443
< C CALCULATE TEMPERATURE AFTER PHASE CHANGES RESULTING FROM COLLECTION.           SCHULTZ_MIC.407
<       X = (RC + RR) - RLIQ                                                       SCHULTZ_MIC.408
<       T = T - X*LLI*CPINV                                                        SCHULTZ_MIC.409
<       RLIQ = RC + RR                                                             SCHULTZ_MIC.410
<       RICE = RP + RS + RI                                                        SCHULTZ_MIC.411
<                                                                                  SCHULTZ_MIC.412
< C NOW COMES THE FINAL SATURATION ADJUSTMENT, IF NECESSARY.                       SCHULTZ_MIC.413
<       RSAT = RVSATL(P,T)                                                         SCHULTZ_MIC.414
<       IF (RC.EQ.0. .AND. RV.LT.RSAT) GO TO 40                                    SCHULTZ_MIC.415
<                                                                                  SCHULTZ_MIC.416
<       CALL SATADJL (RV, P, T, RSAT, T1)                                          SCHULTZ_MIC.417
<       RC = RC + (RV-RSAT)                                                        SCHULTZ_MIC.418
<                                                                                  SCHULTZ_MIC.419
<       IF (RC.GT.0.) THEN                                                         SCHULTZ_MIC.420
<          RV = RSAT                                                               SCHULTZ_MIC.421
<       ELSE                                                                       SCHULTZ_MIC.422
<          RV = RSAT + RC                                                          SCHULTZ_MIC.423
<          RC = 0.                                                                 SCHULTZ_MIC.424
<       ENDIF                                                                      SCHULTZ_MIC.425
<                                                                                  SCHULTZ_MIC.426
<       X = RC + RR - RLIQ                                                         SCHULTZ_MIC.427
<       T = T + X*AKLV                                                             SCHULTZ_MIC.428
<       RLIQ = RC + RR                                                             SCHULTZ_MIC.429
<  40   CONTINUE                                                                   SCHULTZ_MIC.430
<                                                                                  SCHULTZ_MIC.431
< C CONSERVATION CHECKS.                                                           SCHULTZ_MIC.432
<       RTOT1 = RV + RLIQ + RICE                                                   SCHULTZ_MIC.433
<                                                                                  SCHULTZ_MIC.434
<       IF (ABS(RTOT0-RTOT1).GT..000001) THEN                                      SCHULTZ_MIC.435
<          WRITE(*,*) 'RTOT CHECK', RTOT0, RTOT1                                   SCHULTZ_MIC.436
< C         WRITE(NNT_STR,*) MYID, RVO, RCO, RRO, RPO, RSO, RIO                    SCHULTZ_MIC.437
< C         CALL NNT_PUTS_ASYNC(NNT_STDOUT,NNT_STR,ISTAT)                          SCHULTZ_MIC.438
<                                                                                  SCHULTZ_MIC.439
<          WRITE(*,*) RV, RC, RR, RP, RS, RI                                       SCHULTZ_MIC.440
<          STOP                                                                    SCHULTZ_MIC.441
<       ENDIF                                                                      SCHULTZ_MIC.442
<                                                                                  SCHULTZ_MIC.443
---
> C We assume that the result of snow riming is to convert the cloud               SCHULTZ_MIC.407
> C water, but not the snow, to the graupel category.                              SCHULTZ_MIC.408
>                                                                                  SCHULTZ_MIC.409
>          QR = QR + NEEDR                                                         SCHULTZ_MIC.410
>          QI = QI + NEEDI + NEEDS                                                 SCHULTZ_MIC.411
>          QC = QC - NEEDR - NEEDS - NEEDI                                         SCHULTZ_MIC.412
>                                                                                  SCHULTZ_MIC.413
>       ENDIF                                                                      SCHULTZ_MIC.414
>                                                                                  SCHULTZ_MIC.415
> C Unlike the collection of cloud water, which can be complete, we                SCHULTZ_MIC.416
> C don't want to zero out the pristine crystals.  For one thing, some             SCHULTZ_MIC.417
> C are so tiny they won't get collected, but also, we want to be able             SCHULTZ_MIC.418
> C to produce more condensate if it still supersaturated wrt ice,                 SCHULTZ_MIC.419
> C which won't happen if there's zero cloud ice.  We'll leave behind              SCHULTZ_MIC.420
> C the equivalent of 100 per liter.  At 1E-11 kg per crystal and                  SCHULTZ_MIC.421
> C 1000 liters per m**3, that would be 1E-6 kg/m**3 (1 mg/m**3).                  SCHULTZ_MIC.422
> C The temperature-dependent efficiency follows Lin et al (JCAM 83).              SCHULTZ_MIC.423
>                                                                                  SCHULTZ_MIC.424
>       IF (QP.GT.0. .AND. QS.GT.0.) THEN                                          SCHULTZ_MIC.425
>          EFF = 1. - (273.1-T)/50.                                                SCHULTZ_MIC.426
>          RATE = P2S * EFF * QP * QS                                              SCHULTZ_MIC.427
>          CHANGE = RATE * DT                                                      SCHULTZ_MIC.428
>          IF (CHANGE.GT.QP) THEN                                                  SCHULTZ_MIC.429
>             QS = QS + QP - 1E-6                                                  SCHULTZ_MIC.430
>             QP = 1E-6                                                            SCHULTZ_MIC.431
>          ELSE                                                                    SCHULTZ_MIC.432
>             QS = QS + CHANGE                                                     SCHULTZ_MIC.433
>             QP = QP - CHANGE                                                     SCHULTZ_MIC.434
>          ENDIF                                                                   SCHULTZ_MIC.435
>       ENDIF                                                                      SCHULTZ_MIC.436
>                                                                                  SCHULTZ_MIC.437
> C Convert back to mixing ratios.                                                 SCHULTZ_MIC.438
>       RC = QC / RHO                                                              SCHULTZ_MIC.439
>       RP = QP / RHO                                                              SCHULTZ_MIC.440
>       RR = QR / RHO                                                              SCHULTZ_MIC.441
>       RS = QS / RHO                                                              SCHULTZ_MIC.442
>       RI = QI / RHO                                                              SCHULTZ_MIC.443
445,532c445,532
<       TIL1 = T - (AKLV*RLIQ+AKIV*RICE)                                           SCHULTZ_MIC.445
<                                                                                  SCHULTZ_MIC.446
<       IF (ABS(TIL1-TIL0).GT..001) THEN                                           SCHULTZ_MIC.447
<          WRITE(*,*) 'TIL CHECK', TIL0, TIL1                                      SCHULTZ_MIC.448
<          STOP                                                                    SCHULTZ_MIC.449
<       ENDIF                                                                      SCHULTZ_MIC.450
<                                                                                  SCHULTZ_MIC.451
<                                                                                  SCHULTZ_MIC.452
< C THESE TERMINAL VELOCITY FORMULATIONS ARE SIMILAR IN FORM TO OGURA AND          SCHULTZ_MIC.453
< C TAKAHASHI (1971).  THE CURVES FOR RAIN AND SNOW WERE TWEAKED UNTIL THE         SCHULTZ_MIC.454
< C MATCHED THE CURVES ON PAGE 241 OF PIELKE'S BOOK (THEY ARE VERY, VERY           SCHULTZ_MIC.455
< C CLOSE).  THE CURVE FOR ICE IS BASED ON THE CURVE FOR RAIN; THE ONLY            SCHULTZ_MIC.456
< C DIFFERENCE IS IN THE EXPONENT.  THE EFFECT IS THAT SMALL VALUES OF             SCHULTZ_MIC.457
< C ICE, PRESUMED TO BE HEAVILY-RIMED SNOW, FALL SLOWER THAN RAIN OF THE           SCHULTZ_MIC.458
< C SAME CONCENTRATION, BUT HIGHER VALUES, PRESUMED TO BE BIG GRAUPEL OR           SCHULTZ_MIC.459
< C HAIL, FALL FASTER THAN RAIN.  THE TRANSITION IS AT 1 G/KG.                     SCHULTZ_MIC.460
< C THE TERMINAL VELOCITY FOR PRISTINE CRYSTALS DOES NOT HAVE A DEPENDENCY         SCHULTZ_MIC.461
< C ON MIXING RATIO LIKE THE OTHERS, BECAUSE THE OTHERS INCORPORATE THE            SCHULTZ_MIC.462
< C ASSUMPTION THAT HIGHER MIXING RATIOS IMPLY BIGGER PARTICLES, WHICH FAL         SCHULTZ_MIC.463
< C FASTER, BUT THAT'S NOT THE CASE FOR PRISTINE CRYSTALS.                         SCHULTZ_MIC.464
<       IF (RP.GT.0.) TVP = -0.5 * SQRT(1./RHO)                                    SCHULTZ_MIC.465
<       IF (RR.GT.0.) TVR = -5.5 * (RR/.001)**.125 * SQRT(1./RHO)                  SCHULTZ_MIC.466
<       IF (RS.GT.0.) TVS = -2.0 * (RS/.001)**.100 * SQRT(1./RHO)                  SCHULTZ_MIC.467
<       IF (RI.GT.0.) TVI = -5.5 * (RI/.001)**.333 * SQRT(1./RHO)                  SCHULTZ_MIC.468
<                                                                                  SCHULTZ_MIC.469
<       RETURN                                                                     SCHULTZ_MIC.470
<       END                                                                        SCHULTZ_MIC.471
<                                                                                  SCHULTZ_MIC.472
< C                                                                                SCHULTZ_MIC.473
< C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.474
< C                                                                                SCHULTZ_MIC.475
< C THIS IS BASICALLY THE WET-BULB TEMPERATURE PROBLEM, WHERE CONDENSING           SCHULTZ_MIC.476
< C OR EVAPORATING WATER CHANGES THE PARCEL TEMPERATURE AND THUS THE               SCHULTZ_MIC.477
< C SATURATION VAPOR MIXING RATIO.  THE PROCEDURE CONVERGES VERY RAPIDLY           SCHULTZ_MIC.478
< C TO VERY SMALL ERROR.  THE NEWTON-RAPHSON ITERATION TECHNIQUE WAS               SCHULTZ_MIC.479
< C DEVELOPED BY SANDY MACDONALD AND SHAN SUN.                                     SCHULTZ_MIC.480
<                                                                                  SCHULTZ_MIC.481
<       SUBROUTINE SATADJL (RV, P, T, RSAT, T1)                                    SCHULTZ_MIC.482
<       REAL RV, P, T, RSAT, T1                                                    SCHULTZ_MIC.483
<       REAL RVSATL                                                                SCHULTZ_MIC.484
<       REAL DR, ERR_NUM, ERR_DEN                                                  SCHULTZ_MIC.485
<       REAL CP, CPINV, AKLV, AKIV                                                 SCHULTZ_MIC.486
<       INTEGER I                                                                  SCHULTZ_MIC.487
<       PARAMETER(CP=1004., CPINV=1.0/CP, AKLV=2.5E6/CP, AKIV=2.834E6/CP)          SCHULTZ_MIC.488
<                                                                                  SCHULTZ_MIC.489
<       T1 = T                                                                     SCHULTZ_MIC.490
<       DR = RV - RSAT                                                             SCHULTZ_MIC.491
<       DO I = 1, 5                                                                SCHULTZ_MIC.492
<          ERR_NUM = T1 - T - AKLV * DR                                            SCHULTZ_MIC.493
<          ERR_DEN = 1. + AKLV*RSAT*4103.56/((T1-35.9)*(T1-35.9))                  SCHULTZ_MIC.494
<          T1 = T1 - ERR_NUM/ERR_DEN                                               SCHULTZ_MIC.495
<          RSAT = RVSATL(P,T1)                                                     SCHULTZ_MIC.496
<          DR = RV - RSAT                                                          SCHULTZ_MIC.497
<       ENDDO                                                                      SCHULTZ_MIC.498
<                                                                                  SCHULTZ_MIC.499
<       RETURN                                                                     SCHULTZ_MIC.500
<       END                                                                        SCHULTZ_MIC.501
< C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.502
<       SUBROUTINE SATADJI (RV, P, T, RSAT, T1)                                    SCHULTZ_MIC.503
<       REAL RV, P, T, RSAT, T1                                                    SCHULTZ_MIC.504
<       REAL RVSATI                                                                SCHULTZ_MIC.505
<       REAL DR, ERR_NUM, ERR_DEN                                                  SCHULTZ_MIC.506
<       REAL CP, CPINV, AKLV, AKIV                                                 SCHULTZ_MIC.507
<       INTEGER I                                                                  SCHULTZ_MIC.508
<       PARAMETER(CP=1004., CPINV=1.0/CP, AKLV=2.5E6/CP, AKIV=2.834E6/CP)          SCHULTZ_MIC.509
<                                                                                  SCHULTZ_MIC.510
<       T1 = T                                                                     SCHULTZ_MIC.511
<       DR = RV - RSAT                                                             SCHULTZ_MIC.512
<       DO I = 1, 5                                                                SCHULTZ_MIC.513
<          ERR_NUM = T1 - T - AKIV * DR                                            SCHULTZ_MIC.514
<          ERR_DEN = 1. + AKIV*RSAT*5812.26/((T1-7.7)*(T1-7.7))                    SCHULTZ_MIC.515
<          T1 = T1 - ERR_NUM/ERR_DEN                                               SCHULTZ_MIC.516
<          RSAT = RVSATI(P,T1)                                                     SCHULTZ_MIC.517
<          DR = RV - RSAT                                                          SCHULTZ_MIC.518
<       ENDDO                                                                      SCHULTZ_MIC.519
<                                                                                  SCHULTZ_MIC.520
<       RETURN                                                                     SCHULTZ_MIC.521
<       END                                                                        SCHULTZ_MIC.522
< C                                                                                SCHULTZ_MIC.523
< C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.524
< C                                                                                SCHULTZ_MIC.525
< C FOLLOWING MEYERS ET AL. (JAM 91).  THE ORIGINAL EXPRESSION GAVE THE NU         SCHULTZ_MIC.526
< C OF CRYSTALS PER LITER.  THE FACTOR 1E3 CONVERTS TO CUBIC METERS.  PMAS         SCHULTZ_MIC.527
< C (THIS IS THE VARIABLE'S NAME IN RAMS) IS THE AVERAGE MASS OF NUCLEATED         SCHULTZ_MIC.528
< C PRISTINE CRYSTALS.  DIVIDING BY RHO CONVERTS FROM SPECIFIC CONTENT             SCHULTZ_MIC.529
< C (KGP/M**3) TO MIXING RATIO (KGP/KG).  THE AMOUNT OF CLOUD ICE NUCLEATE         SCHULTZ_MIC.530
< C IS ARBITRARILY LIMITED TO HALF THE VAPOR EXCESS, BUT THIS SHOULD NEVER         SCHULTZ_MIC.531
< C HAPPEN.                                                                        SCHULTZ_MIC.532
---
> C Calculate temperature after phase changes resulting from collection.           SCHULTZ_MIC.445
>       X = (RC + RR) - RLIQ                                                       SCHULTZ_MIC.446
>       T = T - X*LLI*CPINV                                                        SCHULTZ_MIC.447
>       RLIQ = RC + RR                                                             SCHULTZ_MIC.448
>       RICE = RP + RS + RI                                                        SCHULTZ_MIC.449
>                                                                                  SCHULTZ_MIC.450
> C Conservation checks.                                                           SCHULTZ_MIC.451
>       RTOT1 = RV + RLIQ + RICE                                                   SCHULTZ_MIC.452
>       IF (ABS(RTOT0-RTOT1).GT..000001) THEN                                      SCHULTZ_MIC.453
>          WRITE(*,*) 'RTOT CHECK', RTOT0, RTOT1                                   SCHULTZ_MIC.454
>          WRITE(*,*) RV, RC, RR, RP, RS, RI                                       SCHULTZ_MIC.455
>       ENDIF                                                                      SCHULTZ_MIC.456
>                                                                                  SCHULTZ_MIC.457
>       TIL1 = T - (AKLV*RLIQ+AKIV*RICE)                                           SCHULTZ_MIC.458
>       IF (ABS(TIL1-TIL0).GT..001) THEN                                           SCHULTZ_MIC.459
>          WRITE(*,*) 'TIL CHECK', TIL0, TIL1                                      SCHULTZ_MIC.460
>       ENDIF                                                                      SCHULTZ_MIC.461
>                                                                                  SCHULTZ_MIC.462
> C These terminal velocity formulations are similar in form to                    SCHULTZ_MIC.463
> C Ogura and Takahashi (1971).  The curves for rain and snow were                 SCHULTZ_MIC.464
> C tweaked until they matched the curves on page 241 of Pielke's                  SCHULTZ_MIC.465
> C book (they are very, very close).  The curve for ice is based                  SCHULTZ_MIC.466
> C on the curve for rain; the only difference is in the exponent.                 SCHULTZ_MIC.467
> C The effect is that small values of ice, presumed to be                         SCHULTZ_MIC.468
> C heavily-rimed snow, fall slower than rain of the same                          SCHULTZ_MIC.469
> C concentration, but higher values, presumed to be big graupel                   SCHULTZ_MIC.470
> C or hail, fall faster than rain.  The transition is at 1 g/kg.                  SCHULTZ_MIC.471
> C The terminal velocity for pristine crystals does not have a                    SCHULTZ_MIC.472
> C dependency on mixing ratio like the others, because the others                 SCHULTZ_MIC.473
> C incorporate the assumption that higher mixing ratios imply                     SCHULTZ_MIC.474
> C bigger particles, which fall faster, but that's not the case                   SCHULTZ_MIC.475
> C for pristine crystals.                                                         SCHULTZ_MIC.476
>                                                                                  SCHULTZ_MIC.477
>       IF (RP.GT.0.) TVP = -0.5 * SQRT(1./RHO)                                    SCHULTZ_MIC.478
>       IF (RR.GT.0.) TVR = -5.5 * (RR/.001)**.125 * SQRT(1./RHO)                  SCHULTZ_MIC.479
>       IF (RS.GT.0.) TVS = -2.0 * (RS/.001)**.100 * SQRT(1./RHO)                  SCHULTZ_MIC.480
>       IF (RI.GT.0.) TVI = -5.5 * (RI/.001)**.333 * SQRT(1./RHO)                  SCHULTZ_MIC.481
>                                                                                  SCHULTZ_MIC.482
>       RETURN                                                                     SCHULTZ_MIC.483
>       END                                                                        SCHULTZ_MIC.484
>                                                                                  SCHULTZ_MIC.485
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.486
> C This is basically the wet-bulb temperature problem, where                      SCHULTZ_MIC.487
> C condensing or evaporating water changes the parcel temperature                 SCHULTZ_MIC.488
> C and thus the saturation vapor mixing ratio.  Asai (1965)                       SCHULTZ_MIC.489
>                                                                                  SCHULTZ_MIC.490
>       SUBROUTINE SATADJL (RV, P, T, RSAT, T1)                                    SCHULTZ_MIC.491
>       REAL RV, P, T, RSAT, T1                                                    SCHULTZ_MIC.492
>       Real cpm, factor                                                           SCHULTZ_MIC.493
>       Real Lvl, cp, Rvap                                                         SCHULTZ_MIC.494
>       Parameter (Lvl=2.500E6, cp=1004., Rvap=461.5)                              SCHULTZ_MIC.495
>                                                                                  SCHULTZ_MIC.496
>       cpm = cp*(1.+.81*rsat)                                                     SCHULTZ_MIC.497
>       factor = 1./(1.+(Lvl*Lvl*rsat/(cpm*Rvap*t*t)))                             SCHULTZ_MIC.498
>       rsat = rsat + factor*(rv-rsat)                                             SCHULTZ_MIC.499
>       t1 = t + (rv-rsat)*Lvl/cp                                                  SCHULTZ_MIC.500
>                                                                                  SCHULTZ_MIC.501
>       RETURN                                                                     SCHULTZ_MIC.502
>       END                                                                        SCHULTZ_MIC.503
>                                                                                  SCHULTZ_MIC.504
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.505
>       SUBROUTINE SATADJI (RV, P, T, RSAT, T1)                                    SCHULTZ_MIC.506
>       REAL RV, P, T, RSAT, T1                                                    SCHULTZ_MIC.507
>       Real cpm, factor                                                           SCHULTZ_MIC.508
>       Real Lvi, cp, Rvap                                                         SCHULTZ_MIC.509
>       Parameter (Lvi=2.834E6, cp=1004., Rvap=461.5)                              SCHULTZ_MIC.510
>                                                                                  SCHULTZ_MIC.511
>       cpm = cp*(1.+.81*rsat)                                                     SCHULTZ_MIC.512
>       factor = 1./(1.+(Lvi*Lvi*rsat/(cpm*Rvap*t*t)))                             SCHULTZ_MIC.513
>       rsat = rsat + factor*(rv-rsat)                                             SCHULTZ_MIC.514
>       t1 = t + (rv-rsat)*Lvi/cp                                                  SCHULTZ_MIC.515
>                                                                                  SCHULTZ_MIC.516
>       RETURN                                                                     SCHULTZ_MIC.517
>       END                                                                        SCHULTZ_MIC.518
>                                                                                  SCHULTZ_MIC.519
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.520
> C Following Meyers et al (JAM 91).  The original expression gave                 SCHULTZ_MIC.521
> C the number of crystals per liter.  The factor 1E3 converts to                  SCHULTZ_MIC.522
> C cubic meters.  PMAS (this is the variable's name in RAMS) is the               SCHULTZ_MIC.523
> C average mass of nucleated pristine crystals.  Dividing by rho                  SCHULTZ_MIC.524
> C converts from specific content (kgp/m**3) to mixing ratio (kgp/kg).            SCHULTZ_MIC.525
> C The amount of cloud ice nucleated is arbitrarily limited to half               SCHULTZ_MIC.526
> C the vapor excess, but this should never happen.                                SCHULTZ_MIC.527
>                                                                                  SCHULTZ_MIC.528
>       SUBROUTINE NUCLEATE_PRISTINE (RV, RSAT, T, RHO, RP_NUC)                    SCHULTZ_MIC.529
>       REAL RV, RSAT, T, RHO, RP_NUC                                              SCHULTZ_MIC.530
>       REAL PMAS                                                                  SCHULTZ_MIC.531
>       PARAMETER (PMAS=1.E-11)                                                    SCHULTZ_MIC.532
534,554c534,554
<       SUBROUTINE NUCLEATE_PRISTINE (RV, RSAT, T, RHO, RP_NUC)                    SCHULTZ_MIC.534
<       REAL RV, RSAT, T, RHO, RP_NUC                                              SCHULTZ_MIC.535
<       REAL PMAS                                                                  SCHULTZ_MIC.536
<       PARAMETER (PMAS=1.E-11)                                                    SCHULTZ_MIC.537
<                                                                                  SCHULTZ_MIC.538
<       RP_NUC = 0.                                                                SCHULTZ_MIC.539
<       IF (T.GT.268.) RETURN                                                      SCHULTZ_MIC.540
<                                                                                  SCHULTZ_MIC.541
<       RP_NUC = 1.E3 * EXP(-.639+12.96*(RV/RSAT-1.)) * PMAS / RHO                 SCHULTZ_MIC.542
<       IF (RP_NUC.GT.(RV-RSAT)/2.) RP_NUC = (RV-RSAT)/2.                          SCHULTZ_MIC.543
<                                                                                  SCHULTZ_MIC.544
<       RETURN                                                                     SCHULTZ_MIC.545
<       END                                                                        SCHULTZ_MIC.546
< C                                                                                SCHULTZ_MIC.547
< C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.548
< C                                                                                SCHULTZ_MIC.549
< C THESE FUNCTIONS COMPUTE THE SATURATION MIXING RATIOS OVER LIQUID AND I         SCHULTZ_MIC.550
< C SUBSTITUTED PAUL'S ORIGINAL FUNCTIONS WITH THOSE FROM FLATAU/WALKO/COT         SCHULTZ_MIC.551
< C JAM 1992.                                                                      SCHULTZ_MIC.552
<                                                                                  SCHULTZ_MIC.553
<       REAL FUNCTION RVSATL(P,T)                                                  SCHULTZ_MIC.554
---
>       RP_NUC = 0.                                                                SCHULTZ_MIC.534
>       IF (T.GT.268.) RETURN                                                      SCHULTZ_MIC.535
>                                                                                  SCHULTZ_MIC.536
>       RP_NUC = 1.E3 * EXP(-.639+12.96*(RV/RSAT-1.)) * PMAS / RHO                 SCHULTZ_MIC.537
>       IF (RP_NUC.GT.(RV-RSAT)/2.) RP_NUC = (RV-RSAT)/2.                          SCHULTZ_MIC.538
>                                                                                  SCHULTZ_MIC.539
>       RETURN                                                                     SCHULTZ_MIC.540
>       END                                                                        SCHULTZ_MIC.541
>                                                                                  SCHULTZ_MIC.542
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.543
> C These functions compute the saturation mixing ratios over liquid               SCHULTZ_MIC.544
> C and ice.                                                                       SCHULTZ_MIC.545
>                                                                                  SCHULTZ_MIC.546
>       REAL FUNCTION RVSATL(P,T)                                                  SCHULTZ_MIC.547
>                                                                                  SCHULTZ_MIC.548
>       REAL ESL,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8                                  SCHULTZ_MIC.549
>       PARAMETER (C0= .611583699E03,  C1= .444606896E02)                          SCHULTZ_MIC.550
>       PARAMETER (C2= .143177157E01,  C3= .264224321E-1)                          SCHULTZ_MIC.551
>       PARAMETER (C4= .299291081E-3,  C5= .203154182E-5)                          SCHULTZ_MIC.552
>       PARAMETER (C6= .702620698E-8,  C7= .379534310E-11)                         SCHULTZ_MIC.553
>       PARAMETER (C8=-.321582393E-13)                                             SCHULTZ_MIC.554
556,561c556,561
<       REAL ESL,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8                                  SCHULTZ_MIC.556
<       PARAMETER (C0= .611583699E03,  C1= .444606896E02)                          SCHULTZ_MIC.557
<       PARAMETER (C2= .143177157E01,  C3= .264224321E-1)                          SCHULTZ_MIC.558
<       PARAMETER (C4= .299291081E-3,  C5= .203154182E-5)                          SCHULTZ_MIC.559
<       PARAMETER (C6= .702620698E-8,  C7= .379534310E-11)                         SCHULTZ_MIC.560
<       PARAMETER (C8=-.321582393E-13)                                             SCHULTZ_MIC.561
---
>       X=MAX(-80.,T-273.16)                                                       SCHULTZ_MIC.556
>       ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))               SCHULTZ_MIC.557
>       RVSATL=.622*ESL/(P-ESL)                                                    SCHULTZ_MIC.558
>                                                                                  SCHULTZ_MIC.559
>       RETURN                                                                     SCHULTZ_MIC.560
>       END                                                                        SCHULTZ_MIC.561
563,585c563,585
<       X=MAX(-80.,T-273.16)                                                       SCHULTZ_MIC.563
<                                                                                  SCHULTZ_MIC.564
<       ESL=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))               SCHULTZ_MIC.565
< C     ESL = 611.2 * EXP(17.67*(T-273.15)/(T-29.65))  ! MM5 ESL FORMULA           SCHULTZ_MIC.566
<       RVSATL=.622*ESL/(P-ESL)                                                    SCHULTZ_MIC.567
< CC      RVSATL = (380./P) * EXP(17.3*(T-273.1)/(T-35.9))                         SCHULTZ_MIC.568
<                                                                                  SCHULTZ_MIC.569
<       RETURN                                                                     SCHULTZ_MIC.570
<       END                                                                        SCHULTZ_MIC.571
< C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.572
<       REAL FUNCTION RVSATI(P,T)                                                  SCHULTZ_MIC.573
<                                                                                  SCHULTZ_MIC.574
<       REAL ESI,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8                                  SCHULTZ_MIC.575
<       PARAMETER (C0= .609868993E03,  C1= .499320233E02)                          SCHULTZ_MIC.576
<       PARAMETER (C2= .184672631E01,  C3= .402737184E-1)                          SCHULTZ_MIC.577
<       PARAMETER (C4= .565392987E-3,  C5= .521693933E-5)                          SCHULTZ_MIC.578
<       PARAMETER (C6= .307839583E-7,  C7= .105785160E-9)                          SCHULTZ_MIC.579
<       PARAMETER (C8= .161444444E-12)                                             SCHULTZ_MIC.580
<                                                                                  SCHULTZ_MIC.581
<       X=MAX(-80.,T-273.16)                                                       SCHULTZ_MIC.582
<       ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))               SCHULTZ_MIC.583
<       RVSATI=.622*ESI/(P-ESI)                                                    SCHULTZ_MIC.584
< CC      RVSATI = (380./P) * EXP(21.9*(T-273.1)/(T-7.7))                          SCHULTZ_MIC.585
---
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.563
>       REAL FUNCTION RVSATI(P,T)                                                  SCHULTZ_MIC.564
>                                                                                  SCHULTZ_MIC.565
>       REAL ESI,X,T,P,C0,C1,C2,C3,C4,C5,C6,C7,C8                                  SCHULTZ_MIC.566
>       PARAMETER (C0= .609868993E03,  C1= .499320233E02)                          SCHULTZ_MIC.567
>       PARAMETER (C2= .184672631E01,  C3= .402737184E-1)                          SCHULTZ_MIC.568
>       PARAMETER (C4= .565392987E-3,  C5= .521693933E-5)                          SCHULTZ_MIC.569
>       PARAMETER (C6= .307839583E-7,  C7= .105785160E-9)                          SCHULTZ_MIC.570
>       PARAMETER (C8= .161444444E-12)                                             SCHULTZ_MIC.571
>                                                                                  SCHULTZ_MIC.572
>       X=MAX(-80.,T-273.16)                                                       SCHULTZ_MIC.573
>       ESI=C0+X*(C1+X*(C2+X*(C3+X*(C4+X*(C5+X*(C6+X*(C7+X*C8)))))))               SCHULTZ_MIC.574
>       RVSATI=.622*ESI/(P-ESI)                                                    SCHULTZ_MIC.575
>                                                                                  SCHULTZ_MIC.576
>       RETURN                                                                     SCHULTZ_MIC.577
>       END                                                                        SCHULTZ_MIC.578
>                                                                                  SCHULTZ_MIC.579
> C+---+-----------------------------------------------------------------+         SCHULTZ_MIC.580
>       Subroutine Cu_fraction (dx, lapse, rvsat, rh, rc, frac)                    SCHULTZ_MIC.581
>       Implicit none                                                              SCHULTZ_MIC.582
>                                                                                  SCHULTZ_MIC.583
> cThis routine uses dx,lapse,rvsat,rh as inputs only, their values                SCHULTZ_MIC.584
> care not changed herein.  The variables rc,frac are outputs only.                SCHULTZ_MIC.585
587,588c587,682
<       RETURN                                                                     SCHULTZ_MIC.587
<       END                                                                        SCHULTZ_MIC.588
---
>       Real dx, dxmin, dxmax                                                      SCHULTZ_MIC.587
>       Real lapse, lapsemin, lapsemax                                             SCHULTZ_MIC.588
>       Real rh, rh0, rhmin, rhmax, rhclear, rhcloud                               SCHULTZ_MIC.589
>       Real rc, rcmax, rccloud                                                    SCHULTZ_MIC.590
>       Real rvsat, frac, x                                                        SCHULTZ_MIC.591
>                                                                                  SCHULTZ_MIC.592
> cThese are the limits of grid increment and lapse rate for which this            SCHULTZ_MIC.593
> calgorithm is intended.                                                          SCHULTZ_MIC.594
>                                                                                  SCHULTZ_MIC.595
>       Parameter (dxmin=2.)       ! km                                            SCHULTZ_MIC.596
>       Parameter (dxmax=20.)      ! km                                            SCHULTZ_MIC.597
>       Parameter (lapsemin=-10.)  ! K/km                                          SCHULTZ_MIC.598
>       Parameter (lapsemax=-6.)   ! K/km                                          SCHULTZ_MIC.599
>                                                                                  SCHULTZ_MIC.600
> cGrid-volume average rh at which this routine begins to diagnose cloud           SCHULTZ_MIC.601
> cliquid at dx=dxmax and lapse=lapsemin.  Used to compute rhmin.                  SCHULTZ_MIC.602
>                                                                                  SCHULTZ_MIC.603
>       Parameter (rh0=.6)                                                         SCHULTZ_MIC.604
>                                                                                  SCHULTZ_MIC.605
> cMaximum cloud liquid mixing ratio in the cloudy part of the grid                SCHULTZ_MIC.606
> cvolume.  Used to compute rccloud and rhmax.  rc=rccloud at frac=1,              SCHULTZ_MIC.607
> cand rc=rccloud=rcmax at frac=1 and lapse=lapsemin.  No dependence               SCHULTZ_MIC.608
> con dx.                                                                          SCHULTZ_MIC.609
>                                                                                  SCHULTZ_MIC.610
>       Parameter (rcmax=1.)       ! g/kg                                          SCHULTZ_MIC.611
>                                                                                  SCHULTZ_MIC.612
> cInitialize return variables to clear-air conditions.                            SCHULTZ_MIC.613
>                                                                                  SCHULTZ_MIC.614
>       frac = 0.                                                                  SCHULTZ_MIC.615
>       rhclear = rh                                                               SCHULTZ_MIC.616
>       rc = 0.                                                                    SCHULTZ_MIC.617
>       rhcloud = 1.                                                               SCHULTZ_MIC.618
>                                                                                  SCHULTZ_MIC.619
> cHandle the trivial cases first and fastest.                                     SCHULTZ_MIC.620
>                                                                                  SCHULTZ_MIC.621
>       If (rh.lt.rh0) Return                                                      SCHULTZ_MIC.622
>       If (dx.lt.dxmin .OR. lapse.gt.lapsemax) then                               SCHULTZ_MIC.623
>         If (rh.ge.1.) then                                                       SCHULTZ_MIC.624
>           frac = 1.                                                              SCHULTZ_MIC.625
>           rc = rvsat * (rh-1.)                                                   SCHULTZ_MIC.626
>           rhclear = 1.                                                           SCHULTZ_MIC.627
>           rhcloud = 1. + rc/rvsat                                                SCHULTZ_MIC.628
>         End if                                                                   SCHULTZ_MIC.629
>         Return                                                                   SCHULTZ_MIC.630
>       End if                                                                     SCHULTZ_MIC.631
>                                                                                  SCHULTZ_MIC.632
> cThe basic procedure is to calculate the cloud fraction as an                    SCHULTZ_MIC.633
> cinterpolation of rh between the limits of rhmin, which is a function            SCHULTZ_MIC.634
> cof gridsize and static stability, and rhmax, which is the "rh" of               SCHULTZ_MIC.635
> cthe cloudy fraction of the gridbox.  (Likewise, rccloud is the mixing           SCHULTZ_MIC.636
> cratio of cloud liquid in the cloudy fraction of the gridbox.)                   SCHULTZ_MIC.637
> crhmin is constrained to be no higher than .99                                   SCHULTZ_MIC.638
>                                                                                  SCHULTZ_MIC.639
>       If (dx.lt.dxmax) then                                                      SCHULTZ_MIC.640
>         rhmin = rh0 + (.99-rh0)*((dxmax-dx)/(dxmax-dxmin))                       SCHULTZ_MIC.641
>       Else                                                                       SCHULTZ_MIC.642
>         rhmin = rh0                                                              SCHULTZ_MIC.643
>       End if                                                                     SCHULTZ_MIC.644
>                                                                                  SCHULTZ_MIC.645
>       x = lapse                                                                  SCHULTZ_MIC.646
>       if (lapse.lt.lapsemin) x = lapsemin                                        SCHULTZ_MIC.647
>       if (lapse.gt.lapsemax) x = lapsemax                                        SCHULTZ_MIC.648
>       rhmin = rhmin +                                                            SCHULTZ_MIC.649
>      +       (.99-rhmin)*(x-lapsemin)/(lapsemax-lapsemin)                        SCHULTZ_MIC.650
>       If (rh.lt.rhmin) Return                                                    SCHULTZ_MIC.651
>                                                                                  SCHULTZ_MIC.652
>       rccloud = rcmax * (1. - (x-lapsemin)/(lapsemax-lapsemin) )                 SCHULTZ_MIC.653
>       rhmax = (rccloud+rvsat)/rvsat                                              SCHULTZ_MIC.654
>       If (rh.gt.rhmax) then                                                      SCHULTZ_MIC.655
>         frac = 1.                                                                SCHULTZ_MIC.656
>         rc = rvsat * (rh-1.)                                                     SCHULTZ_MIC.657
>         rhclear = 1.                                                             SCHULTZ_MIC.658
>         rhcloud = rh                                                             SCHULTZ_MIC.659
>         Return                                                                   SCHULTZ_MIC.660
>       End if                                                                     SCHULTZ_MIC.661
>                                                                                  SCHULTZ_MIC.662
>       frac = (rh-rhmin)/(rhmax-rhmin)                                            SCHULTZ_MIC.663
>                                                                                  SCHULTZ_MIC.664
>       If (frac.lt..01) then                                                      SCHULTZ_MIC.665
>         frac = 0.                                                                SCHULTZ_MIC.666
>       Else if (frac.gt..99) then                                                 SCHULTZ_MIC.667
>         frac = 1.                                                                SCHULTZ_MIC.668
>         rc = rvsat * (rh-1.)                                                     SCHULTZ_MIC.669
>         if (rc.lt.0.) rc = 0.                                                    SCHULTZ_MIC.670
>         rhcloud = 1. + rc/rvsat                                                  SCHULTZ_MIC.671
>         rhclear = 1.                                                             SCHULTZ_MIC.672
>       Else                                                                       SCHULTZ_MIC.673
>         rc = rccloud * frac                                                      SCHULTZ_MIC.674
>         rhcloud = (rvsat+rccloud)/rvsat                                          SCHULTZ_MIC.675
>         rhclear = (rh - frac*rhcloud) / (1.-frac)                                SCHULTZ_MIC.676
>         If (abs(rhclear-rhmin).gt..00001) print*,                                SCHULTZ_MIC.677
>      +         'This shouldn''t happen:',  rhclear, rhmin                        SCHULTZ_MIC.678
>       End if                                                                     SCHULTZ_MIC.679
>                                                                                  SCHULTZ_MIC.680
>       Return                                                                     SCHULTZ_MIC.681
>       End                                                                        SCHULTZ_MIC.682
===================================================================
physics/explicit/simple/lexmoiss.F
diff -r3.7 -r3.9
46a47,48
> C ADD FLAG FOR MEYERS ICE NUCLEI CONC. EQ                                        23DEC04.3384
>       INTEGER MEYERS                                                             23DEC04.3385
50,51d51
< C ADD FLAG FOR MEYERS ICE NUCLEI CONC. EQ                                        19DEC02.1677
<       INTEGER MEYERS                                                             19DEC02.1678
===================================================================
physics/hzdiffu/simple/Makefile
diff -r3.0 -r3.1
9a10,13
> 	diffth.o \
> 	diffthd.o \
> 	diffmoi.o \
> 	diffintp.o \
13a18,21
> 	diffth.i \
> 	diffthd.i \
> 	diffmoi.i \
> 	diffintp.i \
17a26,29
> 	diffth.f \
> 	diffthd.f \
> 	diffmoi.f \
> 	diffintp.f \
43a56,59
> diffth.o: ../../../include/parame.incl
> diffthd.o: ../../../include/parame.incl
> diffmoi.o: ../../../include/parame.incl
> diffintp.o: ../../../include/parame.incl
===================================================================
physics/hzdiffu/simple/coef_diffu.F
diff -r3.0 -r3.2
2c2
<      &                      XKHZ,XKHMAX,C200,ILX,JLX,KL)                         COEF_DIFFU.2
---
>      &                      XKHZ,XKHMAX,C200,ILX,JLX,KL,IN)                      23DEC04.3386
61a62,97
>                                                                                  23DEC04.3387
>        IF (IN .GT. 1) THEN                                                       23DEC04.3388
> c  enhance momentum diffsion coefficient if two-grid interval                    23DEC04.3389
> c  noise develops along the lateral boundary of a nest                           23DEC04.3390
> c$doacross                                                                       23DEC04.3391
> c$& local(i,j,k)                                                                 23DEC04.3392
> c$omp parallel do default(shared)                                                23DEC04.3393
> c$omp&private(i,j,k)                                                             23DEC04.3394
>        DO K=1,KL                                                                 23DEC04.3395
>          DO I=3,ILX-1                                                            23DEC04.3396
>            j = 3                                                                 23DEC04.3397
>            XKD(I,J,K) = XKD(I,J,K)+3*C200*(abs(4*U(I,J,K)-U(I+1,J,K)-            23DEC04.3398
>      &     U(I-1,J,K)-U(I,J+1,K)-U(I,J-1,K))+abs(4*V(I,J,K)-V(I+1,J,K)-          23DEC04.3399
>      &     V(I-1,J,K)-V(I,J+1,K)-V(I,J-1,K)))                                    23DEC04.3400
>            if (XKD(I,J,K).gt.XKHMAX) XKD(I,J,K)=XKHMAX                           23DEC04.3401
>            j = jlx-1                                                             23DEC04.3402
>            XKD(I,J,K) = XKD(I,J,K)+3*C200*(abs(4*U(I,J,K)-U(I+1,J,K)-            23DEC04.3403
>      &     U(I-1,J,K)-U(I,J+1,K)-U(I,J-1,K))+abs(4*V(I,J,K)-V(I+1,J,K)-          23DEC04.3404
>      &     V(I-1,J,K)-V(I,J+1,K)-V(I,J-1,K)))                                    23DEC04.3405
>            if (XKD(I,J,K).gt.XKHMAX) XKD(I,J,K)=XKHMAX                           23DEC04.3406
>          ENDDO                                                                   23DEC04.3407
>          DO J=4,JLX-2                                                            23DEC04.3408
>            i = 3                                                                 23DEC04.3409
>            XKD(I,J,K) = XKD(I,J,K)+3*C200*(abs(4*U(I,J,K)-U(I+1,J,K)-            23DEC04.3410
>      &     U(I-1,J,K)-U(I,J+1,K)-U(I,J-1,K))+abs(4*V(I,J,K)-V(I+1,J,K)-          23DEC04.3411
>      &     V(I-1,J,K)-V(I,J+1,K)-V(I,J-1,K)))                                    23DEC04.3412
>            if (XKD(I,J,K).gt.XKHMAX) XKD(I,J,K)=XKHMAX                           23DEC04.3413
>            i = ilx-1                                                             23DEC04.3414
>            XKD(I,J,K) = XKD(I,J,K)+3*C200*(abs(4*U(I,J,K)-U(I+1,J,K)-            23DEC04.3415
>      &     U(I-1,J,K)-U(I,J+1,K)-U(I,J-1,K))+abs(4*V(I,J,K)-V(I+1,J,K)-          23DEC04.3416
>      &     V(I-1,J,K)-V(I,J+1,K)-V(I,J-1,K)))                                    23DEC04.3417
>            if (XKD(I,J,K).gt.XKHMAX) XKD(I,J,K)=XKHMAX                           23DEC04.3418
>          ENDDO                                                                   23DEC04.3419
>         ENDDO                                                                    23DEC04.3420
>        ENDIF                                                                     23DEC04.3421
>                                                                                  23DEC04.3422
===================================================================
physics/pbl_sfc/gspbl/gspbl.F
diff -r3.17 -r3.19
2127c2127
<             IF(CHECK.LT.0.001)THEN                                               GSPBL.2046
---
>             IF(CHECK.LT.0.001.AND.ABS(TKEB(I,J,K)-CHECK).GT.1.E-10)THEN          23DEC04.3423
===================================================================
physics/pbl_sfc/hirpbl/hirpbl.F
diff -r3.16 -r3.18
63a64,65
> C        ISFMTHD = 1 ADDED NIELSEN-GAMMON CORRECTION TO STABLE        C          23DEC04.3424
> C          REGIME 2M AND 10M INTERPOLATIONS                           C          23DEC04.3425
501c503,507
<           PSIM10(I)=-10.*GZ10OZ0(I)                                              19DEC02.1697
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3426
>           PSIM10(I)=-10.*GZ10OZ0(I)                                              23DEC04.3427
>         ELSE                                                                     23DEC04.3428
>           PSIM10(I)=10./ZA(I,KL)*PSIM(I)                                         23DEC04.3429
>         ENDIF                                                                    23DEC04.3430
504c510,514
<           PSIM2(I)=-10.*GZ2OZ0(I)                                                19DEC02.1700
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3431
>           PSIM2(I)=-10.*GZ2OZ0(I)                                                23DEC04.3432
>         ELSE                                                                     23DEC04.3433
>           PSIM2(I)=2./ZA(I,KL)*PSIM(I)                                           23DEC04.3434
>         ENDIF                                                                    23DEC04.3435
520c530,534
<           PSIM10(I)=-5.0*BR(I)*GZ10OZ0(I)/(1.1-5.0*BR(I))                        19DEC02.1703
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3436
>           PSIM10(I)=-5.0*BR(I)*GZ10OZ0(I)/(1.1-5.0*BR(I))                        23DEC04.3437
>         ELSE                                                                     23DEC04.3438
>           PSIM10(I)=10./ZA(I,KL)*PSIM(I)                                         23DEC04.3439
>         ENDIF                                                                    23DEC04.3440
523c537,541
<           PSIM2(I)=-5.0*BR(I)*GZ2OZ0(I)/(1.1-5.0*BR(I))                          19DEC02.1706
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3441
>           PSIM2(I)=-5.0*BR(I)*GZ2OZ0(I)/(1.1-5.0*BR(I))                          23DEC04.3442
>         ELSE                                                                     23DEC04.3443
>           PSIM2(I)=2./ZA(I,KL)*PSIM(I)                                           23DEC04.3444
>         ENDIF                                                                    23DEC04.3445
===================================================================
physics/pbl_sfc/mrfpbl/mrfpbl.F
diff -r3.28 -r3.34
8a9
>      +   HFXSI,QFXSI,TGSI,SEAICE,                                                23DEC04.3446
12c13
<      +   XMOIST,                                                                 07NOV00.1781
---
>      +   XMOIST,ISICE,                                                           23DEC04.3447
59a61,70
> C        ISFMTHD = 1 ADDED NIELSEN-GAMMON CORRECTION TO STABLE        C          23DEC04.3448
> C          REGIME 2M AND 10M INTERPOLATIONS                           C          23DEC04.3449
> C                                                                     C          23DEC04.3450
> C       ADD POLAR MODS FOR MRF SCHEME (SEA-ICE AND ICE SURFACE EFFECTSC          23DEC04.3451
> C                                                                     C          23DEC04.3452
> C       FOR 3.7:                                                      C          23DEC04.3453
> C         USE BELJAARS FORMULA FOR CONVECTIVE VELOCITY                C          23DEC04.3454
> C         REMOVE CONVECTIVE VELOCITY CONTRIBUTION TO SURFACE STRESS   C          23DEC04.3455
> C         OUTPUT PBL HEIGHT BASED ON STABILITY ALONE (NOT RI)         C          23DEC04.3456
> C                                                                     C          23DEC04.3457
83a95
>       REAL FLUXC,VSGD                                                            23DEC04.3458
122c134
<       INTEGER     KPBL(MIX)                                                      07NOV00.1817
---
>       INTEGER     KPBL(MIX),KPBL0(MIX)                                           23DEC04.3459
130c142
<       REAL XMOIST(*)                                                             07NOV00.1818
---
>       REAL XMOIST(MAXSES)                                                        23DEC04.3460
135a148
>       REAL HFXSI(MIX,MJX),QFXSI(MIX,MJX),TGSI(MIX,MJX),SEAICE(MIX,MJX)           23DEC04.3461
149a163
>       INTEGER IST,IEN,ISICE                                                      23DEC04.3462
153d166
<       INTEGER IST,IEN                                                            07NOV00.1839
161c174,179
<      4  DUSFC(MIX),DVSFC(MIX),DTSFC(MIX),DQSFC(MIX),PISFC(MIX)                   07NOV00.1841
---
>      4  DUSFC(MIX),DVSFC(MIX),DTSFC(MIX),DQSFC(MIX),PISFC(MIX),                  23DEC04.3463
>      5  WSPD1(MIX),PBL0(MIX)                                                     23DEC04.3464
> C---- FOR POLAR MODS                                                             23DEC04.3465
>       REAL PSURF,ESG,HSFLXSI,HLFLXSI,HSFLXWT,HLFLXWT                             23DEC04.3466
>       REAL QSSI(MIX),QSWT(MIX),THSI(MIX),THWT(MIX)                               23DEC04.3467
>                                                                                  23DEC04.3468
264a283,306
> C                                                                                23DEC04.3469
> C Adjust value of QS to account for ice surface (permanent or sea ice)           23DEC04.3470
> C Calculate THSI and THWT for sea ice surface type                               23DEC04.3471
> C                                                                                23DEC04.3472
>         PSURF=PS(I)                                                              23DEC04.3473
>         IF(NINT(SATBRT(I,J)).EQ.ISICE)THEN                                       23DEC04.3474
> C Permanent ice surface type                                                     23DEC04.3475
>           E1=0.611*EXP(22.514-6.15E3/TGDSA(I))                                   23DEC04.3476
>           QGH(I)=0.622*E1/(PSURF-E1)                                             23DEC04.3477
>         ELSEIF(SEAICE(I,J).GT.0.02)THEN                                          23DEC04.3478
> C Sea ice surface type                                                           23DEC04.3479
>           E1=SVP1*EXP(SVP2*(271.4-SVPT0)/(271.4-SVP3))                           23DEC04.3480
> c         write(6,*) 'i = ',i,' j = ',j,' tgsi = ',tgsi(i,j),' in = ',in         23DEC04.3481
>           ESG=0.611*EXP(22.514-6.15E3/TGSI(I,J))                                 23DEC04.3482
>           QGH(I)=EP2*E1/(PSURF-E1)*(1.-SEAICE(I,J))+                             23DEC04.3483
>      +       0.622*ESG/(PSURF-ESG)*SEAICE(I,J)                                   23DEC04.3484
>           QSSI(I)=0.622*ESG/(PSURF-ESG)                                          23DEC04.3485
>           QSWT(I)=EP2*E1/(PSURF-E1)                                              23DEC04.3486
> C                                                                                23DEC04.3487
> C Calculate potential temperature of sea ice surface                             23DEC04.3488
> C                                                                                23DEC04.3489
>           THSI(I)=TGSI(I,J)/PISFC(I)                                             23DEC04.3490
>           THWT(I)=271.4/PISFC(I)                                                 23DEC04.3491
>         ENDIF                                                                    23DEC04.3492
379,385c421,441
<         IF(-DTHVDZ.GE.0)THEN                                                     MRFPBL.311
<           DTHVM=-DTHVDZ                                                          MRFPBL.312
<         ELSE                                                                     MRFPBL.313
<           DTHVM=0.                                                               MRFPBL.314
<         ENDIF                                                                    MRFPBL.315
<         VCONV=VCONVC*SQRT(DTHVM)                                                 MRFPBL.316
<         WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV)                                MRFPBL.317
---
> C THIS WAS USED UP TO VERSION 3.6                                                23DEC04.3493
> C       IF(-DTHVDZ.GE.0)THEN                                                     23DEC04.3494
> C         DTHVM=-DTHVDZ                                                          23DEC04.3495
> C       ELSE                                                                     23DEC04.3496
> C         DTHVM=0.                                                               23DEC04.3497
> C       ENDIF                                                                    23DEC04.3498
> C       VCONV=VCONVC*SQRT(DTHVM)                                                 23DEC04.3499
> C       WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV)                                23DEC04.3500
> C  New in 3.7                                                                    23DEC04.3501
> C  Convective velocity scale Vc and subgrid-scale velocity Vsg                   23DEC04.3502
> C  following Beljaars (1995, QJRMS) and Mahrt and Sun (1995, MWR)                23DEC04.3503
> C  from changes by Y.Liu and S.-Y. Hong                                          23DEC04.3504
> C                                                                                23DEC04.3505
>         fluxc = max(hfx(i,j)/rhox(i)/cpm(i)                                      23DEC04.3506
>      -       + ep1*thvx(i,kl)*qfx(i,j)/rhox(i),0.)                               23DEC04.3507
>         VCONV = 1.0*(g/thvx(i,kl)*pbl(i,j)*fluxc)**.33                           23DEC04.3508
> C VCONV comes from Beljaars only                                                 23DEC04.3509
> C VSGD would require passing in DX. Not used here.                               23DEC04.3510
> C       VSGD = 0.32 * (max(dx/5000.-1.,0.))**.33                                 23DEC04.3511
>         VSGD = 0.                                                                23DEC04.3512
>         WSPD(I)=SQRT(WSPD(I)*WSPD(I)+VCONV*VCONV+vsgd*vsgd)                      23DEC04.3513
426c482,486
<         PSIM10(I)=-10.*GZ10OZ0(I)                                                MRFPBL.358
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3514
>           PSIM10(I)=-10.*GZ10OZ0(I)                                              23DEC04.3515
>         ELSE                                                                     23DEC04.3516
>           PSIM10(I)=10./ZA(I,KL)*PSIM(I)                                         23DEC04.3517
>         ENDIF                                                                    23DEC04.3518
429c489,493
<         PSIM2(I)=-10.*GZ2OZ0(I)                                                  MRFPBL.361
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3519
>           PSIM2(I)=-10.*GZ2OZ0(I)                                                23DEC04.3520
>         ELSE                                                                     23DEC04.3521
>           PSIM2(I)=2./ZA(I,KL)*PSIM(I)                                           23DEC04.3522
>         ENDIF                                                                    23DEC04.3523
445c509,513
<         PSIM10(I)=-5.0*BR(I)*GZ10OZ0(I)/(1.1-5.0*BR(I))                          MRFPBL.377
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3524
>           PSIM10(I)=-5.0*BR(I)*GZ10OZ0(I)/(1.1-5.0*BR(I))                        23DEC04.3525
>         ELSE                                                                     23DEC04.3526
>           PSIM10(I)=10./ZA(I,KL)*PSIM(I)                                         23DEC04.3527
>         ENDIF                                                                    23DEC04.3528
448c516,520
<         PSIM2(I)=-5.0*BR(I)*GZ2OZ0(I)/(1.1-5.0*BR(I))                            MRFPBL.380
---
>         IF(ISFMTHD.EQ.0)THEN                                                     23DEC04.3529
>           PSIM2(I)=-5.0*BR(I)*GZ2OZ0(I)/(1.1-5.0*BR(I))                          23DEC04.3530
>         ELSE                                                                     23DEC04.3531
>           PSIM2(I)=2./ZA(I,KL)*PSIM(I)                                           23DEC04.3532
>         ENDIF                                                                    23DEC04.3533
612a685,686
>         QFXSI(I,J)=0.                                                            23DEC04.3534
>         HFXSI(I,J)=0.                                                            23DEC04.3535
618,619d691
< C-----OVER WATER, ALTER ROUGHNESS LENGTH (ZNT) ACCORDING TO WIND (UST).          MRFPBL.499
< C                                                                                MRFPBL.500
638a711,718
>           IF(SEAICE(I,J).GT.0.02)THEN                                            23DEC04.3536
>             HLFLXSI=FLQC(I)*(QSSI(I)-QX(I,KL))                                   23DEC04.3537
>             HLFLXSI=AMAX1(HLFLXSI,0.)                                            23DEC04.3538
>             HLFLXWT=FLQC(I)*(QSWT(I)-QX(I,KL))                                   23DEC04.3539
>             HLFLXWT=AMAX1(HLFLXWT,0.)                                            23DEC04.3540
>             QFX(I,J)=HLFLXSI*SEAICE(I,J)+HLFLXWT*(1.-SEAICE(I,J))                23DEC04.3541
>             QFXSI(I,J)=HLFLXSI                                                   23DEC04.3542
>           ENDIF                                                                  23DEC04.3543
656a737,742
>           IF(SEAICE(I,J).GT.0.02)THEN                                            23DEC04.3544
>             HSFLXSI=FLHC(I)*(THSI(I)-THX(I,KL))                                  23DEC04.3545
>             HSFLXWT=FLHC(I)*(THWT(I)-THX(I,KL))                                  23DEC04.3546
>             HFX(I,J)=HSFLXSI*SEAICE(I,J)+HSFLXWT*(1.-SEAICE(I,J))                23DEC04.3547
>             HFXSI(I,J)=HSFLXSI                                                   23DEC04.3548
>           ENDIF                                                                  23DEC04.3549
688c774
<      +       V10,TH2,Q2,RAINC,RAINNC,SNOWC,CHS2,CKLQ,ZNT)                        19DEC02.1720
---
>      +       V10,TH2,Q2,RAINC,RAINNC,SNOWC,CHS2,CKLQ,ZNT,EMISS)                  23DEC04.3550
690a777
>           TA2(I,J) = TH2(I)*(PS(I)/100.)**ROVCP                                  23DEC04.3551
703c790
<         WSPD(I)=SQRT(UX(I,KL)*UX(I,KL)+VX(I,KL)*VX(I,KL))+1.E-9                  MRFPBL.590
---
>         WSPD1(I)=SQRT(UX(I,KL)*UX(I,KL)+VX(I,KL)*VX(I,KL))+1.E-9                 23DEC04.3552
721a809,810
>         KPBL0(I)=KL                                                              23DEC04.3553
>         PBL0(I)=ZQ(I,KL)                                                         23DEC04.3554
846a936,972
> C                                                                                23DEC04.3555
> C     DIAGNOSTIC PBL HEIGHT WITH BRCR EFFECTIVELY ZERO (PBL0)                    23DEC04.3556
> C                                                                                23DEC04.3557
>       DO I=IST,IEN                                                               23DEC04.3558
>         IF(PBLFLG(I))THEN                                                        23DEC04.3559
>           STABLE(I)=.FALSE.                                                      23DEC04.3560
>           BRUP(I)=BR(I)                                                          23DEC04.3561
>         ENDIF                                                                    23DEC04.3562
>       ENDDO                                                                      23DEC04.3563
>       DO K=KLM,KLPBL,-1                                                          23DEC04.3564
>         DO I=IST,IEN                                                             23DEC04.3565
>           IF(.NOT.STABLE(I).AND.PBLFLG(I))THEN                                   23DEC04.3566
>             BRDN(I)=BRUP(I)                                                      23DEC04.3567
>             SPDK2=MAX((UX(I,K)**2+VX(I,K)**2),1.)                                23DEC04.3568
>             BRUP(I)=(THVX(I,K)-THERMAL(I))*(G*ZA(I,K)/THVX(I,KL))/SPDK2          23DEC04.3569
>             KPBL0(I)=K                                                           23DEC04.3570
>             STABLE(I)=BRUP(I).GT.0.0                                             23DEC04.3571
>           ENDIF                                                                  23DEC04.3572
>                                                                                  23DEC04.3573
>         ENDDO                                                                    23DEC04.3574
>       ENDDO                                                                      23DEC04.3575
> C                                                                                23DEC04.3576
>       DO I=IST,IEN                                                               23DEC04.3577
>         IF(PBLFLG(I))THEN                                                        23DEC04.3578
>           K=KPBL0(I)                                                             23DEC04.3579
>           IF(BRDN(I).GE.0.0)THEN                                                 23DEC04.3580
>             BRINT=0.                                                             23DEC04.3581
>           ELSEIF(BRUP(I).LE.0.0)THEN                                             23DEC04.3582
>             BRINT=1.                                                             23DEC04.3583
>           ELSE                                                                   23DEC04.3584
>             BRINT=(0.0-BRDN(I))/(BRUP(I)-BRDN(I))                                23DEC04.3585
>           ENDIF                                                                  23DEC04.3586
>           PBL0(I)=ZA(I,K+1)+BRINT*(ZA(I,K)-ZA(I,K+1))                            23DEC04.3587
>           IF(PBL0(I).LT.ZQ(I,KPBL0(I)+1))KPBL0(I)=KPBL0(I)+1                     23DEC04.3588
>           IF(KPBL0(I).LE.1)PBLFLG(I)=.FALSE.                                     23DEC04.3589
>         ENDIF                                                                    23DEC04.3590
>       ENDDO                                                                      23DEC04.3591
972,973c1098,1101
<         A1(I,1)=UX(I,KL)-UX(I,KL)/WSPD(I)*UST(I,J)*UST(I,J)/ZQ(I,KL)*DT4         MRFPBL.858
<         A2(I,1)=VX(I,KL)-VX(I,KL)/WSPD(I)*UST(I,J)*UST(I,J)/ZQ(I,KL)*DT4         MRFPBL.859
---
>         A1(I,1)=UX(I,KL)-UX(I,KL)/WSPD1(I)*UST(I,J)*UST(I,J)/ZQ(I,KL)            23DEC04.3592
>      -          *DT4*(WSPD1(I)/WSPD(I))**2                                       23DEC04.3593
>         A2(I,1)=VX(I,KL)-VX(I,KL)/WSPD1(I)*UST(I,J)*UST(I,J)/ZQ(I,KL)            23DEC04.3594
>      -          *DT4*(WSPD1(I)/WSPD(I))**2                                       23DEC04.3595
1158c1286,1288
<         KPBL2D(I,J)=KPBL(I)                                                      MRFPBL.1056
---
> C FOR 3.7 WE USE NEW DIAGNOSED PBL DEPTH                                         23DEC04.3596
>         KPBL2D(I,J)=KPBL0(I)                                                     23DEC04.3597
>         PBL(I,J)=PBL0(I)                                                         23DEC04.3598
===================================================================
physics/pbl_sfc/mrfpbl/tridi2.F
diff -r3.2 -r3.5
8a9,18
> #ifdef IBMopt                                                                    23DEC04.3599
>       real temp1(mix)                                                            23DEC04.3600
>       INTEGER nn,is                                                              23DEC04.3601
> #ifdef MPP1                                                                      23DEC04.3602
> #define nf(A) noflic(A) 
> #else                                                                            23DEC04.3604
> #define nf(A) A        
> #endif                                                                           23DEC04.3606
> #endif                                                                           23DEC04.3607
>                                                                                  23DEC04.3608
10a21
> #ifndef IBMopt                                                                   23DEC04.3609
11a23,25
> #else                                                                            23DEC04.3610
>       INTEGER IST,IEN,nn,is                                                      23DEC04.3611
> #endif                                                                           23DEC04.3612
14a29,40
>                                                                                  23DEC04.3613
> #ifdef IBMopt                                                                    23DEC04.3614
> #ifdef MPP1                                                                      23DEC04.3615
>       nn = ie_x0(L) - is_x0(LS) + 1                                              23DEC04.3616
>       is = is_x0(LS)                                                             23DEC04.3617
>       call vsrec(temp1(noflic(is)),cm(noflic(is),1),nn)                          23DEC04.3618
> #else                                                                            23DEC04.3619
>       nn = L-LS + 1                                                              23DEC04.3620
>       is = LS                                                                    23DEC04.3621
>       call vsrec(temp1(is),cm(is,1),nn)                                          23DEC04.3622
> #endif                                                                           23DEC04.3623
> #endif                                                                           23DEC04.3624
16a43
> #ifndef IBMopt                                                                   23DEC04.3625
17a45,47
> #else                                                                            23DEC04.3626
>         fk = temp1(i)                                                            23DEC04.3627
> #endif                                                                           23DEC04.3628
23a54
> #ifndef IBMopt                                                                   23DEC04.3629
24a56,63
> #else                                                                            23DEC04.3630
>            temp1(i) = CM(I,K)-CL(I,K)*AU(I,K-1)                                  23DEC04.3631
>         ENDDO                                                                    23DEC04.3632
>         call vsrec(temp1(nf(is)),temp1(nf(is)),nn)                               23DEC04.3633
>                                                                                  23DEC04.3634
>         DO I=LS,L                                                                23DEC04.3635
>           FK= temp1(i)                                                           23DEC04.3636
> #endif                                                                           23DEC04.3637
30a70
> #ifndef IBMopt                                                                   23DEC04.3638
31a72,79
> #else                                                                            23DEC04.3639
>          temp1(i) = CM(I,N)-CL(I,N)*AU(I,N-1)                                    23DEC04.3640
>       ENDDO                                                                      23DEC04.3641
>       call vsrec(temp1(nf(is)),temp1(nf(is)),nn)                                 23DEC04.3642
>                                                                                  23DEC04.3643
>       DO I=LS,L                                                                  23DEC04.3644
>         FK= temp1(i)                                                             23DEC04.3645
> #endif                                                                           23DEC04.3646
===================================================================
physics/pbl_sfc/myepbl/myepbl.F
diff -r3.14 -r3.19
69a70
>       REAL PS(MIX)                                                               23DEC04.3647
138a140
>         PS(I) = PSURF                                                            23DEC04.3648
279c281
<      +       V10I,TH2,Q2,RAINC,RAINNC,SNOWC,CHS2,CKLQ,ZNT)                       19DEC02.1768
---
>      +       V10I,TH2,Q2,RAINC,RAINNC,SNOWC,CHS2,CKLQ,ZNT,EMISS)                 23DEC04.3649
282a285
>            TA2(I,J) = TH2(I)*(PS(I)/100.)**ROVCP                                 23DEC04.3650
428c431
< C                IF(FRACT.GE.0.0.AND.FRACT.LE.1.0)THEN                           05DEC01.1226
---
>                  IF(FRACT.GE.0.0.AND.FRACT.LE.1.0)THEN                           23DEC04.3651
436c439
< C                ENDIF                                                           05DEC01.1234
---
>                  ENDIF                                                           23DEC04.3652
===================================================================
physics/pbl_sfc/noahlsm/sflx.F
diff -r3.1 -r3.5
8c8
<      &                 ALB, SNOALB,TBOT, Z0BRD, Z0,                     &    !S  SFLX.8
---
>      &                 ALB, SNOALB,TBOT, Z0BRD, Z0,EMISSI,              &    !S  23DEC04.3653
24a25
> !                                                                                23DEC04.3654
50,51c51,52
< !   ICE	       SEA-ICE FLAG  (=1: SEA-ICE, =0: LAND)                             SFLX.50
< !   DT	       TIMESTEP (SEC) (DT SHOULD NOT EXCEED 3600 SECS, RECOMMEND          SFLX.51
---
> !   ICE        SEA-ICE FLAG  (=1: SEA-ICE, =0: LAND)                             23DEC04.3655
> !   DT         TIMESTEP (SEC) (DT SHOULD NOT EXCEED 3600 SECS, RECOMMEND         23DEC04.3656
110a112
> !   EMISSI     surface emissivity  (dimentionless 0-1.0)                         23DEC04.3657
140c142
< !	         SURFACE)                                                              SFLX.140
---
> !              SURFACE)                                                          23DEC04.3658
143c145
< !	         SURFACE)                                                              SFLX.143
---
> !              SURFACE)                                                          23DEC04.3659
188c190
< !	         BETWEEN SMCWLT AND SMCMAX)                                            SFLX.188
---
> !              BETWEEN SMCWLT AND SMCMAX)                                        23DEC04.3660
234c236
<      &                     SOLDN,TBOT,TH2,ZLVL,Z0BRD                             SFLX.234
---
>      &                     SOLDN,TBOT,TH2,ZLVL,Z0BRD,EMISSI                      23DEC04.3661
313a316,325
>                                                                                  23DEC04.3662
> !urban change                                                                    23DEC04.3663
>                                                                                  23DEC04.3664
>         IF(VEGTYP.eq.1)THEN                                                      23DEC04.3665
>               SHDFAC=0.05                                                        23DEC04.3666
>               RSMIN=400.0                                                        23DEC04.3667
>               SMCMAX = 0.45                                                      23DEC04.3668
>               SMCREF = 0.42                                                      23DEC04.3669
>               SMCWLT = 0.40                                                      23DEC04.3670
>          ENDIF                                                                   23DEC04.3671
451a464,467
>                                                                                  23DEC04.3672
> ! urban change                                                                   23DEC04.3673
>             IF(VEGTYP.eq.1) DF1 = 3.24                                           23DEC04.3674
>                                                                                  23DEC04.3675
495a512,513
>          ELSE                                                                    23DEC04.3676
>             Z0 = Z0BRD                                                           23DEC04.3677
520c538
<          IF(.NOT.LCH) THEN	                                                      SFLX.520
---
>          IF(.NOT.LCH) THEN                                                       23DEC04.3678
543c561
< 	 print*,'before penman'                                                         SFLX.543
---
>          print*,'before penman'                                                  23DEC04.3679
552c570
< 	endif                                                                           SFLX.552
---
>          endif                                                                   23DEC04.3680
556c574
<      &                   DQSDT2,FLX2)                                            SFLX.556
---
>      &                   DQSDT2,FLX2,EMISSI)                                     23DEC04.3681
573c591
<      &                    RCS,RCT,RCQ,RCSOIL)                                    SFLX.573
---
>      &                    RCS,RCT,RCQ,RCSOIL,EMISSI)                             23DEC04.3682
580a599
> !urban                                                                           23DEC04.3683
582,591c601,610
<      &                   	 SMCREF,SMCDRY,CMC,CMCMAX,NSOIL,DT,           &        SFLX.582
<      &                           SHDFAC,                                      &  SFLX.583
<      &                   	 SBETA,Q2,T1,SFCTMP,T24,TH2,FDOWN,F1,         &        SFLX.584
<      &                           SSOIL,                                       &  SFLX.585
<      &                   	 STC,EPSCA,BEXP,PC,RCH,RR,CFACTR,             &        SFLX.586
<      &                   	 SH2O,SLOPE,KDT,FRZX,PSISAT,ZSOIL,            &        SFLX.587
<      &                   	 DKSAT,DWSAT,TBOT,ZBOT,RUNOFF1,RUNOFF2,       &        SFLX.588
<      &                   	 RUNOFF3,EDIR,EC,ET,ETT,NROOT,ICE,RTDIS,      &        SFLX.589
<      &                   	 QUARTZ,FXEXP,CSOIL,                          &        SFLX.590
<      &                   	 BETA,DRIP,DEW,FLX1,FLX2,FLX3)                         SFLX.591
---
>      &                         SMCREF,SMCDRY,CMC,CMCMAX,NSOIL,DT,             &  23DEC04.3684
>      &                         SHDFAC,                                        &  23DEC04.3685
>      &                      SBETA,Q2,T1,SFCTMP,T24,TH2,FDOWN,F1,EMISSI,       &  23DEC04.3686
>      &                         SSOIL,                                         &  23DEC04.3687
>      &                         STC,EPSCA,BEXP,PC,RCH,RR,CFACTR,               &  23DEC04.3688
>      &                         SH2O,SLOPE,KDT,FRZX,PSISAT,ZSOIL,              &  23DEC04.3689
>      &                         DKSAT,DWSAT,TBOT,ZBOT,RUNOFF1,RUNOFF2,         &  23DEC04.3690
>      &                         RUNOFF3,EDIR,EC,ET,ETT,NROOT,ICE,RTDIS,        &  23DEC04.3691
>      &                         QUARTZ,FXEXP,CSOIL,                            &  23DEC04.3692
>      &                         BETA,DRIP,DEW,FLX1,FLX2,FLX3,VEGTYP)              23DEC04.3693
596a616
> !urban                                                                           23DEC04.3694
606c626,628
<      &                    BETA,DRIP,DEW,FLX1,FLX2,FLX3,ESNOW,ETNS)               SFLX.606
---
> !     &                 BETA,DRIP,DEW,FLX1,FLX2,FLX3,ESNOW,ETNS,EMISSI)          23DEC04.3695
>      &                 BETA,DRIP,DEW,FLX1,FLX2,FLX3,ESNOW,ETNS,EMISSI,           23DEC04.3696
>      &                 VEGTYP)                                                   23DEC04.3697
637c659
< !	ET(K) = ET(K)*1000.                                                            SFLX.637
---
> !       ET(K) = ET(K)*1000.                                                      23DEC04.3698
753c775
<      &                    RCS,RCT,RCQ,RCSOIL)                                    SFLX.753
---
>      &                    RCS,RCT,RCQ,RCSOIL,EMISSI)                             23DEC04.3699
832a855
>       REAL     EMISSI                                                            23DEC04.3700
917c940,941
<       RR = (4.* SIGMA * RD / CP)* (SFCTMP **4.)/ (SFCPRS * CH) + 1.0             SFLX.917
---
>       RR = (4.* EMISSI *SIGMA * RD / CP)* (SFCTMP **4.)/ (SFCPRS * CH)  &        23DEC04.3701
>      &      + 1.0                                                                23DEC04.3702
1235c1259
< ! 	FRH2O = SMC                                                                   SFLX.1235
---
> !      FRH2O = SMC                                                               23DEC04.3703
1237c1261
<          	FREE = SMC                                                             SFLX.1237
---
>           FREE = SMC                                                             23DEC04.3704
1284c1308
<                   	    KCOUNT = KCOUNT +1                                        SFLX.1284
---
>                     KCOUNT = KCOUNT +1                                           23DEC04.3705
1305,1309c1329,1333
<             PRINT *,'Flerchinger USEd in NEW version. Iterations=',NLOG          SFLX.1305
<             	  FK = ( ( (HLICE / (GS * ( - PSIS)))*                     &        SFLX.1306
<      &              ( (TKELV - T0)/ TKELV))** ( -1/ BX))* SMCMAX                 SFLX.1307
< ! 	  FRH2O = MIN (FK, SMC)                                                       SFLX.1308
<             	  IF (FK .lt. 0.02) FK = 0.02                                       SFLX.1309
---
>              PRINT *,'Flerchinger USEd in NEW version. Iterations=',NLOG         23DEC04.3706
>                   FK = ( ( (HLICE / (GS * ( - PSIS)))*                           23DEC04.3707
>      &                 ( (TKELV - T0)/ TKELV))** ( -1/ BX))* SMCMAX              23DEC04.3708
> !            FRH2O = MIN (FK, SMC)                                               23DEC04.3709
>              IF (FK .lt. 0.02) FK = 0.02                                         23DEC04.3710
1313c1337
<             	  FREE = MIN (FK, SMC)                                              SFLX.1313
---
>              FREE = MIN (FK, SMC)                                                23DEC04.3711
1321a1346
> !urban                                                                           23DEC04.3712
1324c1349
<      &                 F1,DF1,QUARTZ,CSOIL,AI,BI,CI)                             SFLX.1324
---
>      &                 F1,DF1,QUARTZ,CSOIL,AI,BI,CI,VEGTYP)                      23DEC04.3713
1345c1370,1371
<       INTEGER  NSOIL                                                             SFLX.1345
---
> !urban                                                                           23DEC04.3714
>       INTEGER  NSOIL, VEGTYP                                                     23DEC04.3715
1357a1384
>       REAL     CSOIL_LOC                                                         23DEC04.3716
1402a1430,1438
>                                                                                  23DEC04.3717
> ! urban                                                                          23DEC04.3718
>                                                                                  23DEC04.3719
>         IF(VEGTYP.eq.1) then                                                     23DEC04.3720
>             CSOIL_LOC=3.0E6                                                      23DEC04.3721
>         ELSE                                                                     23DEC04.3722
>             CSOIL_LOC=CSOIL                                                      23DEC04.3723
>         ENDIF                                                                    23DEC04.3724
>                                                                                  23DEC04.3725
1517a1554,1558
>                                                                                  23DEC04.3726
> ! urban                                                                          23DEC04.3727
>                                                                                  23DEC04.3728
>             IF(VEGTYP.eq.1) DF1N = 3.24                                          23DEC04.3729
>                                                                                  23DEC04.3730
1545a1587,1591
>                                                                                  23DEC04.3731
> ! urban                                                                          23DEC04.3732
>                                                                                  23DEC04.3733
>        IF(VEGTYP.eq.1) DF1N = 3.24                                               23DEC04.3734
>                                                                                  23DEC04.3735
1799a1846
> !urban                                                                           23DEC04.3736
1802c1849,1850
<      &                   SBETA,Q2,T1,SFCTMP,T24,TH2,FDOWN,F1,SSOIL,     &        SFLX.1802
---
>      &                   SBETA,Q2,T1,SFCTMP,T24,TH2,FDOWN,F1,EMISSI,    &        23DEC04.3737
>      &                   SSOIL,                                         &        23DEC04.3738
1808c1856
<      &                   BETA,DRIP,DEW,FLX1,FLX2,FLX3)                           SFLX.1808
---
>      &                   BETA,DRIP,DEW,FLX1,FLX2,FLX3,VEGTYP)                    23DEC04.3739
1822a1871
>       INTEGER  VEGTYP                                                            23DEC04.3740
1886a1936
>       REAL     EMISSI                                                            23DEC04.3741
2004a2055,2058
>                                                                                  23DEC04.3742
> ! urban                                                                          23DEC04.3743
>                                                                                  23DEC04.3744
>       IF(VEGTYP.eq.1) DF1 = 3.24                                                 23DEC04.3745
2018c2072,2073
<       YYNUM = FDOWN - SIGMA * T24                                                SFLX.2018
---
> !       YYNUM = FDOWN - EMISSI*SIGMA * T24                                       23DEC04.3746
>       YYNUM = FDOWN - EMISSI*SIGMA * T1**4                                       23DEC04.3747
2021a2077
> !urban                                                                           23DEC04.3748
2024c2080
<      &             QUARTZ,CSOIL)                                                 SFLX.2024
---
>      &             QUARTZ,CSOIL,VEGTYP)                                          23DEC04.3749
2041c2097
<      &                   DQSDT2,FLX2)                                            SFLX.2041
---
>      &                   DQSDT2,FLX2,EMISSI)                                     23DEC04.3750
2083a2140
>       REAL     EMISSI                                                            23DEC04.3751
2104c2161,2163
<       RR = T24 * 6.48E-8 / (SFCPRS * CH) + 1.0                                   SFLX.2104
---
> !     RR = T24 * 6.48E-8 / (SFCPRS * CH) + 1.0                                   23DEC04.3752
>       RR = EMISSI*T24 * 6.48E-8 / (SFCPRS * CH) + 1.0                            23DEC04.3753
> !!! Fei: place for EMISSIVITY                                                    23DEC04.3754
2122c2181,2183
<       FNET = FDOWN - SIGMA * T24- SSOIL                                          SFLX.2122
---
> !!! Fei: place for EMISSIVITY                                                    23DEC04.3755
> !     FNET = FDOWN - SIGMA * T24- SSOIL                                          23DEC04.3756
>       FNET = FDOWN -  EMISSI*SIGMA * T24- SSOIL                                  23DEC04.3757
2259c2320
<                   	STOP 333                                                      SFLX.2259
---
>                         STOP 333                                                 23DEC04.3758
2261a2323
> !                     print *, 'VEGTYP=',VEGTYP=,'LUCATS=',LUCATS                23DEC04.3759
2423a2486
> !urban                                                                           23DEC04.3760
2426c2489
<      &                   QUARTZ,CSOIL)                                           SFLX.2426
---
>      &                   QUARTZ,CSOIL,VEGTYP)                                    23DEC04.3761
2443a2507
>       INTEGER  VEGTYP                                                            23DEC04.3762
2489a2554
> !urban                                                                           23DEC04.3763
2492c2557
<      &              BEXP,F1,DF1,QUARTZ,CSOIL,AI,BI,CI)                           SFLX.2492
---
>      &              BEXP,F1,DF1,QUARTZ,CSOIL,AI,BI,CI,VEGTYP)                    23DEC04.3764
2823a2889
> !urban                                                                           23DEC04.3765
2833c2899,2900
<      &                      BETA,DRIP,DEW,FLX1,FLX2,FLX3,ESNOW,ETNS)             SFLX.2833
---
>      &                   BETA,DRIP,DEW,FLX1,FLX2,FLX3,ESNOW,ETNS,EMISSI,&        23DEC04.3766
>      &                   VEGTYP)                                                 23DEC04.3767
2848a2916
>       INTEGER  VEGTYP                                                            23DEC04.3768
2969a3038,3040
> !Fei                                                                             23DEC04.3769
>       REAL     EMISSI                                                            23DEC04.3770
>       REAL     EMISSI_S                                                          23DEC04.3771
2997a3069
>       EMISSI_S=0.9     ! For snow                                                23DEC04.3772
3141c3213,3220
<       T12A = ( (FDOWN - FLX1- FLX2- SIGMA * T24)/ RCH                   &        SFLX.3141
---
> !      T12A = ( (FDOWN - FLX1- FLX2- SIGMA * T24)/ RCH                  &        23DEC04.3773
> !Fei: emmissivity                                                                23DEC04.3774
> !      T12A = ( (FDOWN - FLX1- FLX2- EMISSI*SIGMA * T24)/ RCH           &        23DEC04.3775
> !Fei: snow emissi=0.90                                                           23DEC04.3776
> !     T12A = ( (FDOWN - FLX1- FLX2- 0.90*SIGMA * T24)/ RCH              &        23DEC04.3777
> !      T12A = ( (FDOWN - FLX1- FLX2- EMISSI_S*SIGMA * T1**4)/ RCH       &        23DEC04.3778
> !      T12A = ( (FDOWN - FLX1- FLX2- EMISSI_S*SIGMA * T24)/ RCH         &        23DEC04.3779
>       T12A = ( (FDOWN - FLX1- FLX2- EMISSI_S*SIGMA * T1**4)/ RCH        &        23DEC04.3780
3219c3298,3302
<             FLX3 = FDOWN - FLX1- FLX2- SIGMA * T14- SSOIL - SEH - ETANRG         SFLX.3219
---
> !           FLX3 = FDOWN - FLX1- FLX2- SIGMA * T14- SSOIL - SEH - ETANRG         23DEC04.3781
> !Fei: emmissivity                                                                23DEC04.3782
> !           FLX3 = FDOWN - FLX1- FLX2- EMISSI*SIGMA * T14- SSOIL- SEH-    &      23DEC04.3783
>            FLX3 = FDOWN - FLX1- FLX2- EMISSI_S*SIGMA * T14- SSOIL- SEH-   &      23DEC04.3784
>      &            ETANRG                                                         23DEC04.3785
3317a3401
> !urban                                                                           23DEC04.3786
3320c3404
<      &             QUARTZ,CSOIL)                                                 SFLX.3320
---
>      &             QUARTZ,CSOIL,VEGTYP)                                          23DEC04.3787
===================================================================
physics/pbl_sfc/noahlsm/surfce.F
diff -r3.1 -r3.6
3c3
<      &,inest,u10,v10,th2,q2,rainc,rainnc,SNOWC,chs2,cklq,ZNT)                    SURFCE.3
---
>      &,inest,u10,v10,th2,q2,rainc,rainnc,SNOWC,chs2,cklq,ZNT,EMISS)              23DEC04.3788
71a72
>      &,EMISS(MIX,MJX)                                                            23DEC04.3789
78c79
<      &,Q1K,SMELTK,SOILQW,SOILQM,T2K,PRESK,LWDN,SNOWHK, DUMMY                     SURFCE.78
---
>      &,Q1K,SMELTK,SOILQW,SOILQM,T2K,PRESK,LWDN,SNOWHK,EMISSI,DUMMY               23DEC04.3790
115c116
<             IF(XICE(I,J).EQ.1.)PRINT*,' sea-ice at water point, I=',I,           SURFCE.115
---
>             IF(XICE(I,J).GE..5)PRINT*,' sea-ice at water point, I=',I,           23DEC04.3791
130c131
<             IF(XICE(I,J).EQ.1.)THEN                                              SURFCE.130
---
>             IF(XICE(I,J).GE.0.5)THEN                                             23DEC04.3792
179c180,184
<           ICE=INT(XICE(I,J)+0.3)                                                 SURFCE.179
---
>           IF(XICE(I,J).GE.0.5) THEN                                              23DEC04.3793
>               ICE = 1                                                            23DEC04.3794
>           ELSE                                                                   23DEC04.3795
>               ICE = 0                                                            23DEC04.3796
>           ENDIF                                                                  23DEC04.3797
183a189
>           EMISSI = EMISS(I,J)                                                    23DEC04.3798
234c240
< 	  SHDMIN=XVEGMN(I,J)                                                            SURFCE.234
---
>           SHDMIN=XVEGMN(I,J)                                                     23DEC04.3799
241c247
<           IF(ISLTPK.EQ.14.AND.XICE(I,J).EQ.0.)THEN                               SURFCE.241
---
>           IF(ISLTPK.EQ.14.AND.XICE(I,J).LT.0.5)THEN                              23DEC04.3800
288,289c294,295
< 	print*,'outputting at xtime =', xtime                                           SURFCE.288
< 	print*,' before SFLX','INEST',INEST,'I',I,'J',J                                 SURFCE.289
---
>          print*,'outputting at xtime =', xtime                                   23DEC04.3801
>          print*,' before SFLX','INEST',INEST,'I',I,'J',J                         23DEC04.3802
315c321
<      +         ALBBRD, SNOALB,TBOTK,Z0BRD, Z0,                                   SURFCE.315
---
>      +         ALBBRD, SNOALB,TBOTK,Z0BRD, Z0, EMISSI,                           23DEC04.3803
330,331c336,337
< 	print*,' after SFLX', 'INEST',INEST,'I',I,'J',J                                 SURFCE.330
< 	print*,'outputting at xtime =', xtime                                           SURFCE.331
---
>          print*,' after SFLX', 'INEST',INEST,'I',I,'J',J                         23DEC04.3804
>          print*,'outputting at xtime =', xtime                                   23DEC04.3805
348c354
< 	endif                                                                           SURFCE.348
---
>         endif                                                                    23DEC04.3806
389a396
>           TH2(I)=T2K*(1.E5/SFCPRS)**ROVCP                                        23DEC04.3807
397c404
<           SNOWHB(I,J)=OMUHF*SNOWHA(I,J)+GNUHF*(SNOWHK*1.E3+SNOWHB(I,J)) !KWM     SURFCE.397
---
>           SNOWHB(I,J)=OMUHF*SNOWHA(I,J)+GNUHF*(SNOWHK*1.E3+SNOWHB(I,J))          23DEC04.3808
===================================================================
physics/pbl_sfc/pxpbl/vegeland.F
diff -r3.5 -r3.7
27a28,31
> C                                                                                23DEC04.3809
> C Modification after v3.5.3:                                                     23DEC04.3810
> C          1.  Small correction on line200 (see comment). Affects IFGROW = 2     23DEC04.3811
> C          2.  Added die off date (Oct 15) for crops. Affects IFGROW = 1 or 2    23DEC04.3812
200c204,205
<           JDEMRG = JMO(IMO-1)+(0.5 - VF1)/(VF2-VF1)                              VEGELAND.200
---
> C-- Corrected next line.  Changed (0.5 - VF1) to (0.4 - VF1)                     23DEC04.3813
>           JDEMRG = JMO(IMO-1)+(0.4 - VF1)/(VF2-VF1)                              23DEC04.3814
213c218,219
< 70        IF(IDAYPE.LE.0) THEN                                                   VEGELAND.213
---
> C-- Added die off date for crops - Oct 15  - jp 10/02                            23DEC04.3815
> 70        IF(IDAYPE.LE.0.OR.JDATE.GT.288) THEN                                   23DEC04.3816
===================================================================
physics/pbl_sfc/util/slab.F
diff -r3.26 -r3.29
86a87
>       real zc                                                                    23DEC04.3817
95a97,106
>       data zc/0.7639888525/                                                      23DEC04.3818
> #ifdef IBMopt                                                                    23DEC04.3819
>       integer is,nn                                                              23DEC04.3820
>       real temp1(mix),temp2(mix)                                                 23DEC04.3821
> #ifdef MPP1                                                                      23DEC04.3822
> #define nf(A) noflic(A)  
> #else                                                                            23DEC04.3824
> #define nf(A) A        
> #endif                                                                           23DEC04.3826
> #endif                                                                           23DEC04.3827
102a114,122
> #ifdef IBMopt                                                                    23DEC04.3828
> #ifdef MPP1                                                                      23DEC04.3829
>       nn = ie_x0(IEN) - is_x0(IST) + 1                                           23DEC04.3830
>       is = is_x0(IST)                                                            23DEC04.3831
> #else                                                                            23DEC04.3832
>       nn = IEN - IST + 1                                                         23DEC04.3833
>       is = IST                                                                   23DEC04.3834
> #endif                                                                           23DEC04.3835
> #endif                                                                           23DEC04.3836
125a146
> #ifndef IBMopt                                                                   23DEC04.3837
131a153,174
> #else                                                                            23DEC04.3838
>                                                                                  23DEC04.3839
>       ESGW=SVP1*EXP(SVP2*(271.4-SVPT0)/(271.4-SVP3))                             23DEC04.3840
>                                                                                  23DEC04.3841
>       DO  I=IST,IEN                                                              23DEC04.3842
>         PS = PSB(I,J)+PTOP+PP3D(I,J,KL)*0.001                                    23DEC04.3843
>         PISFC(I) = PS*.01                                                        23DEC04.3844
>         temp1(i) = 22.514-6.15E3/TSLB(I,J,1)                                     23DEC04.3845
>         temp2(i) = SVP2*(TSLB(I,J,1)-SVPT0)/(TSLB(I,J,1)-SVP3)                   23DEC04.3846
>       ENDDO                                                                      23DEC04.3847
>                                                                                  23DEC04.3848
>       call vslog(PISFC(nf(is)),PISFC(nf(is)),nn)                                 23DEC04.3849
>       call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                                 23DEC04.3850
>       call vsexp(temp2(nf(is)),temp2(nf(is)),nn)                                 23DEC04.3851
>                                                                                  23DEC04.3852
>       DO I=IST,IEN                                                               23DEC04.3853
>          PISFC(i) =  - PISFC(i) * ROVCP                                          23DEC04.3854
>          temp1(i) = .611 * temp1(i)                                              23DEC04.3855
>          temp2(i) = SVP1 * temp2(i)                                              23DEC04.3856
>       ENDDO                                                                      23DEC04.3857
>       call vsexp(PISFC(nf(is)),PISFC(nf(is)),nn)                                 23DEC04.3858
> #endif                                                                           23DEC04.3859
136a180,182
> #ifdef IBMopt                                                                    23DEC04.3860
>         TG0(I)=TGB(I,J)                                                          23DEC04.3861
> #endif                                                                           23DEC04.3862
185a232
> #ifndef IBMopt                                                                   23DEC04.3863
186a234,236
> #else                                                                            23DEC04.3864
>                 THG=TSLB(I,J,1)*PISFC(I)                                         23DEC04.3865
> #endif                                                                           23DEC04.3866
188a239
> #ifndef IBMopt                                                                   23DEC04.3867
189a241,243
> #else                                                                            23DEC04.3868
>                   ESG = temp1(i)                                                 23DEC04.3869
> #endif                                                                           23DEC04.3870
196a251
> #ifndef IBMopt                                                                   23DEC04.3871
197a253
> #endif                                                                           23DEC04.3872
198a255
> #ifndef IBMopt                                                                   23DEC04.3873
199a257,259
> #else                                                                            23DEC04.3874
>                   ESGI = temp1(i)                                                23DEC04.3875
> #endif                                                                           23DEC04.3876
200a261
> #ifndef IBMopt                                                                   23DEC04.3877
201a263,265
> #else                                                                            23DEC04.3878
>                   HFXTW=FLHC(I)*((271.4*PISFC(I))-THX(I,KL))                     23DEC04.3879
> #endif                                                                           23DEC04.3880
212a277
> #ifndef IBMopt                                                                   23DEC04.3881
214a280,282
> #else                                                                            23DEC04.3882
>                   esg = temp2(i)                                                 23DEC04.3883
> #endif                                                                           23DEC04.3884
228c296,297
<                DIFSNW=2.22362*(0.5*(DENSNW(L)+DENSNW(L+1)))**1.885               19DEC02.1947
---
> CB               DIFSNW=2.22362*(0.5*(DENSNW(L)+DENSNW(L+1)))**1.885             23DEC04.3885
>                DIFSNW=exp(1.885*log(zc*(DENSNW(L)+DENSNW(L+1))))                 23DEC04.3886
234c303,304
<                 DIFSNW=2.22362*(0.5*(DENSNW(L)+DENSNW(L+1)))**1.885              19DEC02.1953
---
> CB                DIFSNW=2.22362*(0.5*(DENSNW(L)+DENSNW(L+1)))**1.885            23DEC04.3887
>                DIFSNW=exp(1.885*log(zc*(DENSNW(L)+DENSNW(L+1))))                 23DEC04.3888
===================================================================
physics/radiation/ccm2/radcsw.F
diff -r3.5 -r3.7
344a345
> C CHANGED FROM 14.6 TO 35 MICRONS FOR 3.7                                        23DEC04.3889
348c349
<         CREI(K)=14.6                                                             05DEC01.1458
---
>         CREI(K)=35.0                                                             23DEC04.3890
===================================================================
physics/radiation/cloud/lwrad.F
diff -r3.5 -r3.8
12c12
< #	include <nhcnst.incl>                                                          LWRAD.12
---
> #       include <nhcnst.incl>                                                    23DEC04.3891
49a50,60
> #ifdef IBMopt                                                                    23DEC04.3892
>       integer is,nn                                                              23DEC04.3893
>       integer icount4,icount5,icount6                                            23DEC04.3894
>       dimension ind4(mixr),ind5(mixr),ind6(mixr)                                 23DEC04.3895
>       dimension temp1(mixr),temp2(mixr),temp3(mixr)                              23DEC04.3896
>       dimension temp4(mixr),temp5(mixr),temp6(mixr)                              23DEC04.3897
>       dimension DLTWVP0(mixr),DLTWVP0r(mixr)                                     23DEC04.3898
>       dimension DLTCO2P0(mixr),DLTCO2P0r(mixr)                                   23DEC04.3899
>       dimension DLTLWP0(mixr),DLTWVEP0(mixr)                                     23DEC04.3900
>       dimension DLTRWP0(mixr)                                                    23DEC04.3901
> #endif                                                                           23DEC04.3902
50a62,68
> #ifdef IBMopt                                                                    23DEC04.3903
> #ifdef MPP1                                                                      23DEC04.3904
> #define nf(A) noflic(A)   
> #else                                                                            23DEC04.3906
> #define nf(A) A          
> #endif                                                                           23DEC04.3908
> #endif                                                                           23DEC04.3909
62a81,89
> #ifdef IBMopt                                                                    23DEC04.3910
> #ifdef MPP1                                                                      23DEC04.3911
>       nn = ie_x0(ILX) - is_x0(1) + 1                                             23DEC04.3912
>       is = is_x0(1)                                                              23DEC04.3913
> #else                                                                            23DEC04.3914
>       nn = ILX                                                                   23DEC04.3915
>       is = 1                                                                     23DEC04.3916
> #endif                                                                           23DEC04.3917
> #endif                                                                           23DEC04.3918
120a148,169
> #ifdef IBMopt                                                                    23DEC04.3919
>         DO I=1,ILX                                                               23DEC04.3920
>            temp2(i)=P(I,K)/1013.0                                                23DEC04.3921
>         ENDDO                                                                    23DEC04.3922
>                                                                                  23DEC04.3923
>         call vslog(temp2(nf(is)),temp2(nf(is)),nn)                               23DEC04.3924
>         call vsrec(temp3(nf(is)),T(nf(IS),J,K),nn)                               23DEC04.3925
>         call vsrec(temp4(nf(is)),TGA(nf(IS),J),nn)                               23DEC04.3926
>                                                                                  23DEC04.3927
>         DO I=1,ILX                                                               23DEC04.3928
>            temp1(i)=temp2(i)*0.86                                                23DEC04.3929
>            temp2(i)=temp2(i)*1.75                                                23DEC04.3930
>            temp3(i)=959.6*temp3(i)                                               23DEC04.3931
>            temp4(i)=959.6*temp4(i)                                               23DEC04.3932
>         ENDDO                                                                    23DEC04.3933
>                                                                                  23DEC04.3934
>         call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                               23DEC04.3935
>         call vsexp(temp2(nf(is)),temp2(nf(is)),nn)                               23DEC04.3936
>         call vsexp(temp3(nf(is)),temp3(nf(is)),nn)                               23DEC04.3937
>         call vsexp(temp4(nf(is)),temp4(nf(is)),nn)                               23DEC04.3938
>                                                                                  23DEC04.3939
> #endif                                                                           23DEC04.3940
123a173
> #ifndef IBMopt                                                                   23DEC04.3941
124a175,177
> #else                                                                            23DEC04.3942
>           XWVP(I,K)=RO(I,K)*QVTMP*DZ(I,K)*temp1(i)                               23DEC04.3943
> #endif                                                                           23DEC04.3944
125a179
> #ifndef IBMopt                                                                   23DEC04.3945
127a182,185
> #else                                                                            23DEC04.3946
>           XCO2P(I,K)=RO(I,K)*QCO2*DZ(I,K)*temp2(i)                               23DEC04.3947
>           DIVDND=temp3(i)-1.                                                     23DEC04.3948
> #endif                                                                           23DEC04.3949
139a198
> #ifndef IBMopt                                                                   23DEC04.3950
140a200,202
> #else                                                                            23DEC04.3951
>         DIVDND=temp4(i)-1.                                                       23DEC04.3952
> #endif                                                                           23DEC04.3953
183a246
> #ifndef IBMopt                                                                   23DEC04.3954
189a253,259
> #else                                                                            23DEC04.3955
>             DLTWVP0(i)=UIWVP(I,IIM1)-UIWVP(I,K-1)                                23DEC04.3956
>             DLTLWP0(i)=UILWP(I,IIM1)-UILWP(I,K-1)                                23DEC04.3957
>             DLTCO2P0(i)=UICO2P(I,IIM1)-UICO2P(I,K-1)                             23DEC04.3958
>             DLTRWP0(i)=UIRWP(I,IIM1)-UIRWP(I,K-1)                                23DEC04.3959
>             DLTWVEP0(i)=UIWVEP(I,IIM1)-UIWVEP(I,K-1)                             23DEC04.3960
> #endif                                                                           23DEC04.3961
192a263
> #ifndef IBMopt                                                                   23DEC04.3962
196a268,271
> #else                                                                            23DEC04.3963
>             PH2O=DLTWVP0(i)/(UIWVPP(I,IIM1)-UIWVPP(I,K-1))                       23DEC04.3964
>             PCO2=DLTCO2P0(i)/(UICO2PP(I,IIM1)-UICO2PP(I,K-1))                    23DEC04.3965
> #endif                                                                           23DEC04.3966
197a273
> #ifndef IBMopt                                                                   23DEC04.3967
206a283,336
> #else                                                                            23DEC04.3968
>             temp1(i)=1.+14.432211 * DLTWVP0(i) * PH2O                            23DEC04.3969
>             temp2(i)=1.+162.50546 * DLTCO2P0(i) * PCO2                           23DEC04.3970
>           ENDDO                                                                  23DEC04.3971
>                                                                                  23DEC04.3972
>           call vsrsqrt(temp1(nf(is)),temp1(nf(is)),nn)                           23DEC04.3973
>           call vsrsqrt(temp2(nf(is)),temp2(nf(is)),nn)                           23DEC04.3974
>                                                                                  23DEC04.3975
>           DO I=1,ILX                                                             23DEC04.3976
>             TH2O = -0.0007345 * DLTWVP0(i) * temp1(i)                            23DEC04.3977
>             TCO2 = -0.07187   * DLTCO2P0(i) * temp2(i)                           23DEC04.3978
>             TLIQ=-ABDOWN*DLTLWP0(i)-ABRN*DLTRWP0(i)                              23DEC04.3979
>             temp1(i) = TH2O+TCO2+TLIQ                                            23DEC04.3980
>             temp2(i) = TH2O+TLIQ                                                 23DEC04.3981
>           ENDDO                                                                  23DEC04.3982
>                                                                                  23DEC04.3983
>           call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                             23DEC04.3984
>           call vsexp(temp2(nf(is)),temp2(nf(is)),nn)                             23DEC04.3985
>                                                                                  23DEC04.3986
>           icount4=is - 1                                                         23DEC04.3987
>           icount5=is - 1                                                         23DEC04.3988
>           icount6=is - 1                                                         23DEC04.3989
>                                                                                  23DEC04.3990
>           DO I=1,ILX                                                             23DEC04.3991
>             IF(DLTWVP0(i).LT.10.)THEN                                            23DEC04.3992
>                 icount4 = icount4 +1                                             23DEC04.3993
>                 ind4(i) = icount4                                                23DEC04.3994
>                 temp4(nf(icount4)) = DLTWVP0(i)*0.0001                           23DEC04.3995
>              else                                                                23DEC04.3996
>                 icount5 = icount5 +1                                             23DEC04.3997
>                 ind5(i) = icount5                                                23DEC04.3998
>                 temp5(nf(icount5)) = DLTWVP0(i)*0.0001                           23DEC04.3999
>              end if                                                              23DEC04.4000
>              IF(DLTWVEP0(i).GT.8.)THEN                                           23DEC04.4001
>                 icount6 = icount6 +1                                             23DEC04.4002
>                 ind6(i) = icount6                                                23DEC04.4003
>                 temp6(nf(icount6)) = DLTWVEP0(i)*0.0001                          23DEC04.4004
>              end if                                                              23DEC04.4005
>           ENDDO                                                                  23DEC04.4006
>                                                                                  23DEC04.4007
>           if(icount4.gt.0) then                                                  23DEC04.4008
>              call vssqrt(temp4(nf(is)),temp4(nf(is)),icount4)                    23DEC04.4009
>           endif                                                                  23DEC04.4010
>           if(icount5.gt.0) then                                                  23DEC04.4011
>              call  vslog(temp5(nf(is)),temp5(nf(is)),icount5)                    23DEC04.4012
>           endif                                                                  23DEC04.4013
>           if(icount6.gt.0) then                                                  23DEC04.4014
>              call  vslog(temp6(nf(is)),temp6(nf(is)),icount6)                    23DEC04.4015
>           endif                                                                  23DEC04.4016
>                                                                                  23DEC04.4017
>           DO I=1,ILX                                                             23DEC04.4018
>             DOVLP(I,K)=1.- temp1(i)                                              23DEC04.4019
>             DBH2O(I,K)=1.- temp2(i)                                              23DEC04.4020
> #endif                                                                           23DEC04.4021
207a338
> #ifndef IBMopt                                                                   23DEC04.4022
209a341
> #endif                                                                           23DEC04.4023
212a345
> #ifndef IBMopt                                                                   23DEC04.4024
214a348,352
> #else                                                                            23DEC04.4025
>             TBAR=(UIWVT(I,IIM1)-UIWVT(I,K-1))/DLTWVP0(i)                         23DEC04.4026
>             IF(DLTWVP0(i).LT.10.)THEN                                            23DEC04.4027
>                ax = temp4(nf(ind4(i)))                                           23DEC04.4028
> #endif                                                                           23DEC04.4029
218a357
> #ifndef IBMopt                                                                   23DEC04.4030
219a359,361
> #else                                                                            23DEC04.4031
>                ax = temp5(nf(ind5(i)))                                           23DEC04.4032
> #endif                                                                           23DEC04.4033
224a367
> #ifndef IBMopt                                                                   23DEC04.4034
226a370,373
> #else                                                                            23DEC04.4035
>             IF(DLTWVEP0(i).GT.8.)THEN                                            23DEC04.4036
>                ax = temp6(nf(ind6(i)))                                           23DEC04.4037
> #endif                                                                           23DEC04.4038
235a383
> #ifndef IBMopt                                                                   23DEC04.4039
237a386,395
> #else                                                                            23DEC04.4040
>             temp1(i)=-ABDOWN*DLTLWP0(i)-ABRN*DLTRWP0(i)                          23DEC04.4041
>           ENDDO                                                                  23DEC04.4042
>           call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                             23DEC04.4043
>                                                                                  23DEC04.4044
>           DO I=1,ILX                                                             23DEC04.4045
>             DDOVLP=DOVLP(I,K)-DOVLP(I,K+1)                                       23DEC04.4046
>             DDBH2O=DBH2O(I,K)-DBH2O(I,K+1)                                       23DEC04.4047
>             ETOTD(I,K)=1.-(1.-ETOTD(I,K))* temp1(i)                              23DEC04.4048
> #endif                                                                           23DEC04.4049
272a431
> #ifndef IBMopt                                                                   23DEC04.4050
279a439,445
> #else                                                                            23DEC04.4051
>             DLTWVP0(i)=UIWVP(I,K)-UIWVP(I,IIM1)                                  23DEC04.4052
>             DLTLWP0(i)=UILWP(I,K)-UILWP(I,IIM1)                                  23DEC04.4053
>             DLTRWP0(i)=UIRWP(I,K)-UIRWP(I,IIM1)                                  23DEC04.4054
>             DLTCO2P0(i)=UICO2P(I,K)-UICO2P(I,IIM1)                               23DEC04.4055
>             DLTWVEP0(i)=UIWVEP(I,K)-UIWVEP(I,IIM1)                               23DEC04.4056
> #endif                                                                           23DEC04.4057
282a449
> #ifndef IBMopt                                                                   23DEC04.4058
288a456,465
> #else                                                                            23DEC04.4059
>             PH2O=DLTWVP0(i)/(UIWVPP(I,K)-UIWVPP(I,IIM1))                         23DEC04.4060
>             PCO2=DLTCO2P0(i)/(UICO2PP(I,K)-UICO2PP(I,IIM1))                      23DEC04.4061
>             temp1(i)=1.+ 14.432211*DLTWVP0(i) *PH2O                              23DEC04.4062
>             temp2(i)=1.+ 162.50546*DLTCO2P0(i)* PCO2                             23DEC04.4063
>           end do                                                                 23DEC04.4064
>                                                                                  23DEC04.4065
>         call vsrsqrt(temp1(nf(is)),temp1(nf(is)),nn)                             23DEC04.4066
>         call vsrsqrt(temp2(nf(is)),temp2(nf(is)),nn)                             23DEC04.4067
> #endif                                                                           23DEC04.4068
289a467
> #ifndef IBMopt                                                                   23DEC04.4069
296a475,521
> #else                                                                            23DEC04.4070
>           DO I=1,ILX                                                             23DEC04.4071
>             TH2O=-0.0007345*DLTWVP0(i) * temp1(i)                                23DEC04.4072
>             TCO2=-0.07187*DLTCO2P0(i) * temp2(i)                                 23DEC04.4073
>             TLIQ=-ABDOWN*DLTLWP0(i)-ABRN*DLTRWP0(i)                              23DEC04.4074
>             temp1(i) = TH2O+TCO2+TLIQ                                            23DEC04.4075
>             temp2(i) = TH2O+TLIQ                                                 23DEC04.4076
>           end do                                                                 23DEC04.4077
>                                                                                  23DEC04.4078
>           call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                             23DEC04.4079
>           call vsexp(temp2(nf(is)),temp2(nf(is)),nn)                             23DEC04.4080
>                                                                                  23DEC04.4081
>           icount4=is - 1                                                         23DEC04.4082
>           icount5=is - 1                                                         23DEC04.4083
>           icount6=is - 1                                                         23DEC04.4084
>                                                                                  23DEC04.4085
>           DO I=1,ILX                                                             23DEC04.4086
>             IF(DLTWVP0(i).LT.10.)THEN                                            23DEC04.4087
>                 icount4 = icount4 +1                                             23DEC04.4088
>                 ind4(i) = icount4                                                23DEC04.4089
>                 temp4(nf(icount4)) = DLTWVP0(i)*0.0001                           23DEC04.4090
>              else                                                                23DEC04.4091
>                 icount5 = icount5 +1                                             23DEC04.4092
>                 ind5(i) = icount5                                                23DEC04.4093
>                 temp5(nf(icount5)) = DLTWVP0(i)*0.0001                           23DEC04.4094
>              end if                                                              23DEC04.4095
>              IF(DLTWVEP0(i).GT.8.)THEN                                           23DEC04.4096
>                 icount6 = icount6 +1                                             23DEC04.4097
>                 ind6(i) = icount6                                                23DEC04.4098
>                 temp6(nf(icount6)) = DLTWVEP0(i)*0.0001                          23DEC04.4099
>              end if                                                              23DEC04.4100
>           end do                                                                 23DEC04.4101
>                                                                                  23DEC04.4102
>           if(icount4.gt.0) then                                                  23DEC04.4103
>              call vssqrt(temp4(nf(is)),temp4(nf(is)),icount4)                    23DEC04.4104
>           endif                                                                  23DEC04.4105
>           if(icount5.gt.0) then                                                  23DEC04.4106
>              call  vslog(temp5(nf(is)),temp5(nf(is)),icount5)                    23DEC04.4107
>           endif                                                                  23DEC04.4108
>           if(icount6.gt.0) then                                                  23DEC04.4109
>              call  vslog(temp6(nf(is)),temp6(nf(is)),icount6)                    23DEC04.4110
>           endif                                                                  23DEC04.4111
>                                                                                  23DEC04.4112
>           DO I=1,ILX                                                             23DEC04.4113
>             UOVLP(I,K)=1.- temp1(i)                                              23DEC04.4114
>             UBH2O(I,K)=1.- temp2(i)                                              23DEC04.4115
> #endif                                                                           23DEC04.4116
297a523
> #ifndef IBMopt                                                                   23DEC04.4117
299a526
> #endif                                                                           23DEC04.4118
302a530
> #ifndef IBMopt                                                                   23DEC04.4119
304a533,537
> #else                                                                            23DEC04.4120
>             TBAR=(UIWVT(I,K)-UIWVT(I,IIM1))/DLTWVP0(i)                           23DEC04.4121
>             IF(DLTWVP0(i).LT.10.)THEN                                            23DEC04.4122
>               ax = temp4(nf(ind4(i)))                                            23DEC04.4123
> #endif                                                                           23DEC04.4124
308a542
> #ifndef IBMopt                                                                   23DEC04.4125
309a544,546
> #else                                                                            23DEC04.4126
>               ax = temp5(nf(ind5(i)))                                            23DEC04.4127
> #endif                                                                           23DEC04.4128
314a552
> #ifndef IBMopt                                                                   23DEC04.4129
316a555,558
> #else                                                                            23DEC04.4130
>             IF(DLTWVEP0(i).GT.8.)THEN                                            23DEC04.4131
>               ax = temp6(nf(ind6(i)))                                            23DEC04.4132
> #endif                                                                           23DEC04.4133
326a569
> #ifndef IBMopt                                                                   23DEC04.4134
328a572,581
> #else                                                                            23DEC04.4135
>             temp1(i)=-ABUP*DLTLWP0(i)-ABRN*DLTRWP0(i)                            23DEC04.4136
>           ENDDO                                                                  23DEC04.4137
>           call vsexp(temp1(nf(is)),temp1(nf(is)),nn)                             23DEC04.4138
>                                                                                  23DEC04.4139
>           DO I=1,ILX                                                             23DEC04.4140
>             ETOTU(I,K)=1.-(1.-ETOTU(I,K))*  temp1(i)                             23DEC04.4141
>             DUOVLP=UOVLP(I,K)-UOVLP(I,K-1)                                       23DEC04.4142
>             DUBH2O=UBH2O(I,K)-UBH2O(I,K-1)                                       23DEC04.4143
> #endif                                                                           23DEC04.4144
===================================================================
physics/radiation/cloud/swrad.F
diff -r3.2 -r3.5
2c2
<      &                 T,QV,QC,QR,QI,QNI,QG,PP,INEST)                            SWRAD.2
---
>      &                 T,QV,QC,QR,QI,QNI,QG,PP,INEST,HT)                         23DEC04.4145
27a28,30
> C                                                                                23DEC04.4146
>       real HT(MIX,MJX),hx(mix),hy(mix),aa(mix),ss(mix)                           23DEC04.4147
>       REAL KORR                                                                  23DEC04.4148
45a49,87
>       maxneslev = 0                                                              23DEC04.4149
>       do i=1,NSTTOT                                                              23DEC04.4150
>         maxneslev = max(maxneslev,levidn(i))                                     23DEC04.4151
>       enddo                                                                      23DEC04.4152
> C                                                                                23DEC04.4153
> c  Orographic effects on surface radiation - calculation of orography slope      23DEC04.4154
>                                                                                  23DEC04.4155
>       if (levidn(inest).ge.levslp) then                                          23DEC04.4156
>         pi = 4.*atan(1.)                                                         23DEC04.4157
>         absch = 0                                                                23DEC04.4158
>         abschintp = 0                                                            23DEC04.4159
>         if ((j.ge.2).and.(j.le.jlx-1)) then                                      23DEC04.4160
>           do i=1,ilx                                                             23DEC04.4161
>              hx(i) = (ht(i,j+1)-ht(i,j-1))/(2*g*dx)                              23DEC04.4162
>           enddo                                                                  23DEC04.4163
>         else if (j.eq.1) then                                                    23DEC04.4164
>           do i=1,ilx                                                             23DEC04.4165
>              hx(i) = (ht(i,j+1)-ht(i,j))/(g*dx)                                  23DEC04.4166
>           enddo                                                                  23DEC04.4167
>         else if (j.eq.jlx) then                                                  23DEC04.4168
>           do i=1,ilx                                                             23DEC04.4169
>              hx(i) = (ht(i,j)-ht(i,j-1))/(g*dx)                                  23DEC04.4170
>           enddo                                                                  23DEC04.4171
>         endif                                                                    23DEC04.4172
>         do i=2,ilx-1                                                             23DEC04.4173
>           hy(i) = (ht(i+1,j)-ht(i-1,j))/(2*g*dx)                                 23DEC04.4174
>         enddo                                                                    23DEC04.4175
>         hy(1) = (ht(2,j)-ht(1,j))/(g*dx)                                         23DEC04.4176
>         hy(ilx) = (ht(ilx,j)-ht(ilx-1,j))/(g*dx)                                 23DEC04.4177
>         do i=1,ilx                                                               23DEC04.4178
>           if ((hx(i).eq.0).and.(hy(i).eq.0)) then                                23DEC04.4179
>             aa(i) = 0                                                            23DEC04.4180
>           else                                                                   23DEC04.4181
>             aa(i) = atan2(hx(i),hy(i))+pi    ! azimuth angle                     23DEC04.4182
>           endif                                                                  23DEC04.4183
>             ss(i) = atan((hx(i)**2+hy(i)**2)**.5)  ! slope                       23DEC04.4184
>         enddo                                                                    23DEC04.4185
>       endif                                                                      23DEC04.4186
>                                                                                  23DEC04.4187
57a100,101
> C maximum length of orographic shadow: 25 km                                     23DEC04.4188
>       shadl = min(25000.,2500./csza)                                             23DEC04.4189
185a230,396
> c Orography effects                                                              23DEC04.4190
>         if (levidn(inest).ge.levslp) then                                        23DEC04.4191
>         absch = 0                                                                23DEC04.4192
>         abschintp = 0                                                            23DEC04.4193
>                                                                                  23DEC04.4194
> c  estimate diffuse part of solar radiation - fitted to unpublished radiation m  23DEC04.4195
> c  taken at the University of Munich                                             23DEC04.4196
>                                                                                  23DEC04.4197
>         diffus = min(1.,1/(max(0.1,2.619-2.337*log                               23DEC04.4198
>      f      (log(sdown(1)/max(sdown(kxp1),1.e-10))))))                           23DEC04.4199
>         if (diffus.le.0) print*, 'Error in swradoro', diffus                     23DEC04.4200
>         if (diffus.eq.1) then                                                    23DEC04.4201
>             korr = 1                                                             23DEC04.4202
>             goto 140                                                             23DEC04.4203
>         endif                                                                    23DEC04.4204
>                                                                                  23DEC04.4205
> c cosine of zenith angle over sloping topography                                 23DEC04.4206
>                                                                                  23DEC04.4207
>         cszk = ((SIN(XXLAT)*COS(HRANG))*(-cos(aa(i))*sin(ss(i)))-                23DEC04.4208
>      f    SIN(HRANG)*(sin(aa(i))*sin(ss(i)))+(COS(XXLAT)*COS(HRANG))*            23DEC04.4209
>      f    cos(ss(i)))*COS(DECLIN)+(COS(XXLAT)*(cos(aa(i))*sin(ss(i)))+           23DEC04.4210
>      f    SIN(XXLAT)*cos(ss(i)))*SIN(DECLIN)                                     23DEC04.4211
>         IF(CSZK.LE.1.E-4) cszk = 0                                               23DEC04.4212
>                                                                                  23DEC04.4213
>                                                                                  23DEC04.4214
> #ifndef MPP1                                                                     23DEC04.4215
> c  Topographic shadowing                                                         23DEC04.4216
>                                                                                  23DEC04.4217
>           IF ( OROSHAW .EQ. 1 ) THEN                                             23DEC04.4218
>         if (cszk.gt.1.e-8) then                                                  23DEC04.4219
>         argu=(csza*sin(XXLAT)-sin(DECLIN))/(sin(acos(csza))*cos(XXLAT))          23DEC04.4220
>         if (argu.gt.1) argu = 1                                                  23DEC04.4221
>         if (argu.lt.-1) argu = -1                                                23DEC04.4222
>         azi = sign(acos(argu),sin(HRANG))  ! azimuth angle of the sun            23DEC04.4223
>                                                                                  23DEC04.4224
>         if ((azi.gt.0.75*pi).or.(azi.lt.-0.75*pi)) then                          23DEC04.4225
>         do ii = i+1,ilx                                                          23DEC04.4226
>         rj = j + (ii-i)*tan(pi+azi)                                              23DEC04.4227
>         j1 = int(rj)                                                             23DEC04.4228
>         j2 = j1+1                                                                23DEC04.4229
>         if ((j1.lt.1).or.(j2.gt.jlx)) goto 110                                   23DEC04.4230
>         gew = rj-j1                                                              23DEC04.4231
>         dxabs = dx*sqrt((ii-i)**2+(rj-j)**2)                                     23DEC04.4232
>         selev=sin(atan((gew*ht(ii,j2)+(1-gew)*ht(ii,j1)-ht(i,j))/                23DEC04.4233
>      f        (g*dxabs)))                                                        23DEC04.4234
>         if (selev.ge.csza) then                                                  23DEC04.4235
>           cszk = 0                                                               23DEC04.4236
>           absch = 1                                                              23DEC04.4237
>           abschintp = 1                                                          23DEC04.4238
>           goto 130                                                               23DEC04.4239
>         endif                                                                    23DEC04.4240
>         if (dxabs.gt.shadl) goto 130                                             23DEC04.4241
>         enddo                                                                    23DEC04.4242
>         goto 110                                                                 23DEC04.4243
>         else if (azi.lt.-0.25*pi) then                                           23DEC04.4244
>         do jj = j+1,jlx                                                          23DEC04.4245
>         ri = i + (jj-j)*tan(pi/2.-azi)                                           23DEC04.4246
>         i1 = int(ri)                                                             23DEC04.4247
>         i2 = i1+1                                                                23DEC04.4248
>         if ((i1.lt.1).or.(i2.gt.ilx)) goto 110                                   23DEC04.4249
>         gew = ri-i1                                                              23DEC04.4250
>         dxabs = dx*sqrt((jj-j)**2+(ri-i)**2)                                     23DEC04.4251
>         selev=sin(atan((gew*ht(i2,jj)+(1-gew)*ht(i1,jj)-ht(i,j))/                23DEC04.4252
>      f        (g*dxabs)))                                                        23DEC04.4253
>         if (selev.ge.csza) then                                                  23DEC04.4254
>           cszk = 0                                                               23DEC04.4255
>           absch = 1                                                              23DEC04.4256
>           abschintp = 1                                                          23DEC04.4257
>           goto 130                                                               23DEC04.4258
>         endif                                                                    23DEC04.4259
>         if (dxabs.gt.shadl) goto 130                                             23DEC04.4260
>         enddo                                                                    23DEC04.4261
>         goto 110                                                                 23DEC04.4262
>         else if (azi.lt.0.25*pi) then                                            23DEC04.4263
>         do ii = i-1,1,-1                                                         23DEC04.4264
>         rj = j + (ii-i)*tan(azi)                                                 23DEC04.4265
>         j1 = int(rj)                                                             23DEC04.4266
>         j2 = j1+1                                                                23DEC04.4267
>         if ((j1.lt.1).or.(j2.gt.jlx)) goto 110                                   23DEC04.4268
>         gew = rj-j1                                                              23DEC04.4269
>         dxabs = dx*sqrt((ii-i)**2+(rj-j)**2)                                     23DEC04.4270
>         selev=sin(atan((gew*ht(ii,j2)+(1-gew)*ht(ii,j1)-ht(i,j))/                23DEC04.4271
>      f        (g*dxabs)))                                                        23DEC04.4272
>         if (selev.ge.csza) then                                                  23DEC04.4273
>           cszk = 0                                                               23DEC04.4274
>           absch = 1                                                              23DEC04.4275
>           abschintp = 1                                                          23DEC04.4276
>           goto 130                                                               23DEC04.4277
>         endif                                                                    23DEC04.4278
>         if (dxabs.gt.shadl) goto 130                                             23DEC04.4279
>         enddo                                                                    23DEC04.4280
>         goto 110                                                                 23DEC04.4281
>         else                                                                     23DEC04.4282
>         do jj = j-1,1,-1                                                         23DEC04.4283
>         ri = i - (jj-j)*tan(pi/2.+azi)                                           23DEC04.4284
>         i1 = int(ri)                                                             23DEC04.4285
>         i2 = i1+1                                                                23DEC04.4286
>         if ((i1.lt.1).or.(i2.gt.ilx)) goto 110                                   23DEC04.4287
>         gew = ri-i1                                                              23DEC04.4288
>         dxabs = dx*sqrt((jj-j)**2+(ri-i)**2)                                     23DEC04.4289
>         selev=sin(atan((gew*ht(i2,jj)+(1-gew)*ht(i1,jj)-ht(i,j))/                23DEC04.4290
>      f      (g*dxabs)))                                                          23DEC04.4291
>         if (selev.ge.csza) then                                                  23DEC04.4292
>           cszk = 0                                                               23DEC04.4293
>           absch = 1                                                              23DEC04.4294
>           abschintp = 1                                                          23DEC04.4295
>           goto 130                                                               23DEC04.4296
>         endif                                                                    23DEC04.4297
>         if (dxabs.gt.shadl) goto 130                                             23DEC04.4298
>         enddo                                                                    23DEC04.4299
>         goto 110                                                                 23DEC04.4300
>         endif                                                                    23DEC04.4301
>         endif                                                                    23DEC04.4302
>         goto 130                                                                 23DEC04.4303
> c  interpolate shadowing mask from next coarser domain if lateral domain bounda  23DEC04.4304
> c  is closer than search distance (shadl)                                        23DEC04.4305
>                                                                                  23DEC04.4306
>  110    continue                                                                 23DEC04.4307
>                                                                                  23DEC04.4308
>                                                                                  23DEC04.4309
>         if (levidn(inest)-1.ge.levslp) then                                      23DEC04.4310
>           if (shadint(i,j,inest).eq.1) then                                      23DEC04.4311
>             cszk = 0                                                             23DEC04.4312
>             absch = 1                                                            23DEC04.4313
>           endif                                                                  23DEC04.4314
>         endif                                                                    23DEC04.4315
>                                                                                  23DEC04.4316
>  130    continue                                                                 23DEC04.4317
>                                                                                  23DEC04.4318
>            ENDIF                                                                 23DEC04.4319
> #endif                                                                           23DEC04.4320
>                                                                                  23DEC04.4321
> c  Korrekturfaktor                                                               23DEC04.4322
>                                                                                  23DEC04.4323
>         korr = diffus + (1-diffus)*cszk/max(1.e-2,csza)                          23DEC04.4324
>                                                                                  23DEC04.4325
>  140    continue                                                                 23DEC04.4326
>                                                                                  23DEC04.4327
> #ifndef MPP1                                                                     23DEC04.4328
> c Interpolate shadowing mask into nested domains                                 23DEC04.4329
>                                                                                  23DEC04.4330
>           IF ( OROSHAW .EQ. 1 ) THEN                                             23DEC04.4331
>                                                                                  23DEC04.4332
>         if ((inest.lt.NSTTOT).and.(levidn(inest).lt.maxneslev)) then             23DEC04.4333
>                                                                                  23DEC04.4334
>         do 50 i1=inest+1,NSTTOT                                                  23DEC04.4335
>         if (numnc(i1).eq.inest) then                                             23DEC04.4336
>        if ((i.ge.nesti(i1)).and.(i.le.nesti(i1)+(nestix(i1)-1)/3-1).and.         23DEC04.4337
>      f (j.ge.nestj(i1)).and.(j.le.nestj(i1)+(nestjx(i1)-1)/3-1)) then            23DEC04.4338
>         do ii = 2+(I-nesti(i1))*3-1 , 2+(I-nesti(i1))*3+1                        23DEC04.4339
>         do jj = 2+(J-nestj(i1))*3-1 , 2+(J-nestj(i1))*3+1                        23DEC04.4340
>         shadint(ii,jj,i1) = abschintp  ! Shadowing mask is not interp recursive  23DEC04.4341
>         enddo                                                                    23DEC04.4342
>         enddo                                                                    23DEC04.4343
>         endif                                                                    23DEC04.4344
>         endif                                                                    23DEC04.4345
>  50     continue                                                                 23DEC04.4346
>         endif                                                                    23DEC04.4347
>                                                                                  23DEC04.4348
>            ENDIF                                                                 23DEC04.4349
> #endif                                                                           23DEC04.4350
>                                                                                  23DEC04.4351
>         GSW(I,J)=(1.-ALB(I,J))*SDOWN(KXP1)*korr                                  23DEC04.4352
>         OSW(I,J)=OSW(I,J)+ALB(I,J)*SDOWN(KXP1)*korr                              23DEC04.4353
>                                                                                  23DEC04.4354
>         else  ! orographic effects are not taken into account                    23DEC04.4355
>                                                                                  23DEC04.4356
187a399,401
>                                                                                  23DEC04.4357
>         endif                                                                    23DEC04.4358
>                                                                                  23DEC04.4359
